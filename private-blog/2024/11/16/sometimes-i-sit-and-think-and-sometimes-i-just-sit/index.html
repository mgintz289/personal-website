<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ccd7b1a151d4ab30885b29c599cb2015d0f6e25c8196c52dbf9eeff5e0adb5a60eebc8fdf54e14054e6787d2d4d3984a9ee7fa75b02642e3c6015107b1c7018416931dba1b861254434ca54b25c67f744809bf72aa79b66ab1d85736f7e05a4ea9f62b5e1f241bafc0c3bb003e784df39ea240d51f73f9cf505f0706ef7c45e0139036bc7b00985d47e3b0dd92ff398f4c6a48536fe42dfd144831448a95acb56b18048d79a9d7e901e73cb428cd3f08f3989c30eb6c24b07e51f8a8021d77f717f3ac072fa8829aa0cde932ae5807a91a44411b8bf0d0dc7386344c83d37ea91fa43977f3032797aa80f763ce3f77c72b615f48a077a4f75420698a2c9b4b644d00442b2e3458aead194cdb1bd8a811caeed1bd00df592ab7b8611e2a106c0372ac61ee4a644200949f94db8fec8e7537b14d7f246c06a9f0c11f831eaf8a63f072bc1c9739e34418ca589eb13370b604a1ebecf314f0d0f28afa581ead4f3065a8630e76c9c71d8425a7f6fa3effafc977bbfc7a88539152b0197baa03ed3c4b0aef9d4733bc4f59491f94b3e45ca4972dfe692751e779e1fa0cfe1b2ab214452d1e4caa4f3fc0b1ddbe6a4f91977f8694c67e2b9941fbb4f3f51227effd4bd21fe9d7019af824b1310f97723acfad17b10467a25324fcdc62ac7fa0f2423b0bfeee1bf80f82b45ff7baf6389a188a24f803d9e076f2447e12d0d6385bae1805eae90e7799efeb78ab5a5c1244876caee72fe089589c6967294e00bcc830bfff4bf09cd20bb9ea08191714b62996c2622b06f1a44589a0a26d2c41765c824cce8c6e59102979653cdf9df230038b88dfd0062868622784f0cfd10c0ba67ce0a163139ad72a63b022a1c27721ca32062c8a802ec9d6cecf20170ec9bcc36b2d81055593aa5b055b9b2e186749c57686012dbaecc9f1191fe478119ea6134efccf6c09a59677e900f92ff46f64cb6f2932712b863f7c8ea76cff9feac8f22fc5fdcbc947672cf5e1e662943f03ceaed658e89e0b53ab0b8279b769e2e1cf467dd038c94892147a97ed6d81601dc18fa558ca26006cc6fe2f05b777f7a7e0a73c93784ef30672e5ff425b569ce93e4b1950f8df525f52c1695545a8ac57a00fa3e20e011cb29d19f3b6e71944b5d54d25b33afa2605f6df021ea4edeb4e2d6a90dc76390a55bd365d57aeb35f7cbe843e1a071559c5c6cd901bdb62aa5f0176e2dcf8f7b0ae63e881309baeecb82deef611768dff21c28fc2b6b02382979370b22dc73ee1b190c5b278e62cc7c8a08764ca61c053dff7d004dda7de821cfb2a8b387c425b246527a490b31df5e34184ded047a844cb29229e85de3669897835c929fd7aa3292f8508c6826325a89abb65cbb08af1091f71a2dc8884d5345a77c9120250b1d54bb31fb4770cf4577f5132cf3dd2acffbca214925806a43b342c89eac3ee4853c694a061a8bc1162fc5bd04bc0c8ca2e1cc310c2c6d8670f56775b76613a0da362bd61208f18b035754a70af2718486fde6ec2ac18b525fab76809a7064e8b66a4951ea4bb273017969d29d14a3b1c820fd2a6252fd7ec6e4fdbf3896d18af878e1ee80eab9d729856cea3c2ff1429313df184d5c7acef30f212d28f1b71abe4c1683a02e87414ba9284233f08c3d33ba3ca91c2ec8b741fa3c024df1e6dcd734236445565391486344262d4262f0b7309a3cd7ac8989ba96641559d791be3ec54f458f83b99329ddeee1b2d3ee4caa8d7f86fae50e2328788611ac140d5cbb67ef946bee7d5e3b89e2f1ed2d2d66e8dd83bb98eac5d25ae4561bc5a41ea99b15e1334cff54d75a1d5ed435fd2a44652ac0dea955885e7004c80ba80cbab77057545ed0dcf6cd57c9bf543db1c2c671f4b7a9e54b0d0d5dc56910106d81442ddb7de3ff28d2497bdf1d931b231cf3d34b10c389768485bcbb4cc842dc9015e4fc6f569e1057ff8f30dfa033d2a8dbe3345a3494e686e00c65fe82402c37b74ef3a5765d80706410095d9366e4391aa2d51b096235374cbc91aedce52d355b4e69464bf47ec75a9c5c1a518a05ce2f1220df38a30d7118ea24daa27b86c1d25d47568e7878591220fab5e4829d7a7c2dc517cea7b8eeae9fca7d5f640a2a24c7d05b32189e70271c324163db8a0669bc1ca31ff5b89e03469ab14d0a1e8c12760a4536f2c32f57681de9b99d74ae244d9c6da19c520dcfd6a30faeeaaff4593266e766c7cdd2d33f95218156a36139794662bb7ed35afcfbd6f03b0db1c843049940af9b1472ccf7b1524fb84fb3f69b3ed54b21c154d3581567d5536f56f0b008b8a4d4f2eaba13ede0604e756cc9d3913b135a96f61135744fa36b62f0cb7a275acad1d7de40d4812532e28547cecc3b495006fe7e0b1da5272235ad9ba2cc12e0c7ffe0d479f4092b9882afe31c5e3c5dd9ed6d193f64a585bee2ca58c263b6728c95f14b69bd594d6dc4d891ed91aec11265d63e906e1e27658391c46856baaded6c88618816ec08984dea6f896f5c27251e6828ce5f98f9ca124e806a5083d0dc4f7c683fa56af5ed7445e5e0ea47c7a9b6f71eac5cdf947682fccb6e43034079153ba21e725fb01f62319b4e52b037ca4fb95b46fda653375ddeae2244ee8d75bffe26f5dcda2f95f3f9db861027c56d3c598e3adda3d8e9286a49af874ca583f4a80ffc21f869ac4aa39125412327d29dbe9a4f76f1bf121d9e42b5d586f4de138c8b00f59090a4a97bb92278b21bcff97fabd50415c7c9f52b6781c301405dce2c51793929bf7be5c1e45d611b77e18ef11d99e97591c8bfd3832eb4ebcd0059417be45e81a37945741a8d270a24423b7642e9ba39b129af5bdecfcf68661a519970c3d2e25da61f046d8235662514d8d947d45d641c7852b14c3f2acab834968366c80af08bcc6e07698ef8949c3c4823cd90226d54a7116dbd4d91eb553222de31b58c5d953b0245dd7654b9604c397b060633a7c0d88066391c876a51369bc73a74a3600e90e81422f9adcbd9e5568098dc74449e310d3ad48f5e4efe11e550af698e944defba491855f84d0e464a992e557e8cb7f3a8a13b4655481360d04a4851cb9e3092c01aeb7821e4c763655b22b9e461b39197b685356c2f0012b705a02d80d4d3964b632f8cb0f84bf14f80bd81b7665c75842d0a942f1d35b30154dd27bc93640f67d85a2863496a2a3448615b32336b47401cc750d81fd73efa967e9da28708ad51a5b71679b9b4198d905b118763eab65d3d3c7b151e71702c0cf3b8ae21160f3ee74372ff1250658ceb4828d1dfa227705d795280f3130747cbb1d4e7cb26dce52e69c7b1ccb5c3c803bd5d8a95ab72789b764f7fd73e1cc827583b4824e40e700002c8fb4938a10921445de4b44bfe543f8ce3003491109c5a97fa4241e156468029fe853d653550e6713a895100633a92fc476a5d2873650a5c629ca6d69d38ce799b7add71b05c615f4b16e3ebc4e2bc65c026b0fa9a7c46fcf6c77b90fb361cc73834f64091320e5aebdcca0811eed0596864d3ceaa70cb38a2c410dd3558accedc9fd2b0c07051a49750134bf286f3df84c1de15d4f189c410cf40b0a4b4fd02bbcc561285c45d78f128e2072c680ddd0f3dc7e1339e5cb0aaa18ab2bb485aad2a8299415418bb904dc93e48044dd9e33a65178b474949e2df510174d901ac2104330efe78aa50109b5eff3ab311b9b8949d516f1379dc4318504cd5190683a2a075583c0ea67114dde016d5794a03c4b0b33af664ec551ff5bbea047fa02488a471786ac3fb22d85277d1f464754c0e7dd891580ac374c8e350736751c31d3c4eea4943bb5c5634c34fbdb39721c17a9e378f673ffc64fe759b0cf928811f32960f3d93cd30532ace0b4a377ce96900679f12ca196e778fdc0f430208f5a6e03257a5a06834276fcdf2e7240df86887701df08d346960d44a1195d2af2587c4e667ff305cbf87a905d10513c3ef26298325d1e378a6e1fb06f0652a00fb1f78ed72af5ffb2eda3a0b1f18a19b8f662ca07f5829c8f596c052f92d220838346a6a440812431c8b61c01cbcf8f30b91fd433dbb43ceb8f48c63f221011eac4df48003fe8a5500caeae3fcbb542f3280e5a373b4020ab38c3864eb10df1393941a8b95e7adfbd42f409e23f937a7f06d75d55552f82ec4b68090627f965fa731f45218537c3dc9f365c3eb5f52b88c603a4c61ba60f42126391a4d21f94173d1e931f23008814494f7cf109ad700b83c49095f551e42e3eff3d53a5312bdc6662268cc92aea8ee9cf9db7224fab76a4d9c6775e377affe4e10680d818d74948291a6ca9b1fc15a327797c025388a3fc463443767927bc2f4bd960e9f4766c7dc63aa642dbeedc1e0dd661ad16592d973bc5908d66ec8fee00f52349d227c87f5e00884a4c846a4c5eb3b2daab5369d4726c3e6f53875f0c07e1f661c35b7416c3700630eacccb86ac84e6f6682545f7ce8841232808014b7986c7003fd8e097e6a2c4061094697d20cce9fac1ff399dac501f9240b2ea0103edc487dc5028cd77b287940ace8fe0a419c79c8419f7cc5842482e6c9472c570a73a84bd405bb9deb6d10d6b920a87166530ed75223cf6a86fa17a0007c1cc7e1cf8727ec834e76740537396fb57c19c6fef9338effd711eb45095fa2bea483dc106d721a321450217891f257824685757ab88f909cf67a6425466937feac6a82f717f41e7c7cb8e4cb8768558387459aaa0c0319092dfd130cdcc89697a6cd9035bd494e6ff960340fc9ae5adfbc39bd0ac94abc8bfadb9df15b2d877b9e12d46752bb63eaa9023442db14cc1eaad01f98dc9ff19515572de79dd002c83aa9596f0bea97d8bfd48eb170ec3bd1b6ceee32b1b76f0eae5584dd3de3972db85af3fbb24453d70a09fb0de82cc485464d68e739a256cd2da62bfa9596c3b82d2315f37d5a4df51ea46962bbdbe0d7964bae7a9bf9273cbd7cff230ecf979a5a5dd159bdd1db85901a5b356bb1304e60a3757e6994de78a9fff835e819f568755107366d83457e9004498469321a86eaf9f631905e52eadf3c3d0c545fec7bd6e8442e86d56b6999efd671682fef07511fde72acf9e58d74c8d83e6fa41fb13b965d12a0c01466775bcacdbdd84cc83205279b27db3e72dbe0cb56fbc076a9fbfbcb0bbb1670f1fc3c6080f095a6e6cd448a56fab7535780692ab29d5a4d64cc9b6326b9fd97e8a65f33a125c81a590abbffce53496e57af8439dd20cc68d5ca1fb0da3ae26953b47939cec13c7c3834bfc9601dfef7a50945cfd632ae6df5d01a140fdb44281892f957e117ab2ecbd3bd67e32a5317e5a4e2beb6d12b5b1a6261f1cf7b1ec46be3b4f580bcd4e3b620fa243d11f63d2f6a9278615b62e8c1dc0ff62d5e333d1a122670dd80edb6844b8a89d237c287ca4d37e2ee2e9ac4160c66c3b89c285717e1bda3e8fa61b9a289d25038f5f920a7c6d603eeffbfcfb3b308d0a282156c5ab84d3717d15146f82ee9f4e1dc1ff30a625bb18c20ae5ab41081576d1cf3cecd5f8b2824787cc3bee05c1e65a9281f4886ea73b5a7587db1bcc49b1fd8f1e8676a0732be65f01bcbbc7dbe0c5b6cc37e0332fb2e7250278d052b6d260fb9b50949debe5e7b794c63f8b7eef42c78a30a583bd5b4ea899198bd33ba5cba96aee5e433acd29370e0fd1e43cf890dbb8891313d6b55200d6f2f0da651df0ffa2764b755a8096b61d5f2ae0c227175027f380c09d15a4bac12c8d156ee31abd0c0959ed7329c979024c5685802265150f1da75ac7205de9588fa1c579b34d5773e2e471db52aae68f1869d8d97331b2e0a61b268eb076a8b945f69147d9fe80cf611f3645f69cf166a024c65a500d3931fce65d5bc017505df5941fc190dcad9b3f30849cebf8822e1762bdf71ffc24782e53cee86dce17a84befe5d75b6341f50e750b866d0e70534e4907a6f8bd9cee9b4ae10654bd203fc2d00b5428423e2dfd01642c6d09100e7b7e97092a7494fc0b18a51e0dc2bcfd4c1697a96a8863e76bd92178a4afe06326ccd23160c7a00a526db24150da3d86485c9d244eb2bcee07831765824367e5aabd8a74a6522e94df09c5d47fbd741c69a7db24add17bd7621576da91cefd6bdfc0fd70b5809ecacaf8d51b51bf42af6eae3a9edea2b9516034789be71a47ed62dec9022e0175a22f7e233ed3f8016b1ca4a68204a00220804dc167a9b49064ea36d5ba7e9ad5690eec78abd854334ca36744bc19a86c4633ce59c504191cadd8e2e496ac532ec0103ac58beb086ce0f026815d3083172c775b617dc7e34b11cb673a66c200f713c14e3c136130d98d9635b8128d19fd83d6196d00ca77c07c3aa082b52bf3ccc225ae43e9f7fd500dba364549bd46562aa6adfbaf7d20138e2203d2b2074b9768c931715a37e8988f952732820db192d792ca48f61f3749e93fbc52450b2626edeafcf92a8d2c4b8a28feb9654791a0ac2f2f5fe076af99db4e6347eaf417fef9ea1770d2f0a4ff023f9c1c38dd25b703940b4779ba595110595722426da726c0101232b62736305c41cdecb416214d15a5881eda753cce6ecaec9462592402a9a40e600ebd3a76aea2c1501a111881d3104530cf76dccabee5342de9bebfc4db13f36fc53f8a83f8f540d05224a41754d2256eb8d95664da103487fa7753976472bc4c6072d15402b99daaec820b6e95de13f9015cf8e678c3de8030d34ba1e585dde98755ebaec52df189a9de7614787f082a2db237febd41b145b1c5d75ba37ed62114f33c6978e93313d88cb2bbe0d0d6be388901c2cfb8431b1233b6259800cb8b7237962ae794ae052501ada1305a03570742d38e1e371b5e1dcb5624692576ec4dde705e473ca64816824e5a7ee4cf262a8d35784768452972e8f7a19f3119d8aa813d267bc7cccc13a5cd8d18baa039ac0e678fcede5bc9af0354c1fadd5e6f1a31b76037459e9b110d8bb8125f7bf6c2c8ddb374cb17d2755e8d77accbbe0713cdd6487f01eae7d32f49af9dd70e07b59b46958e7976aed63eb57d32df074d6121a8f7a51e27e1b39b32cdef752ef2dad9056d47146b66d1c7b78f2a5d9ae85e2367acbabf9f69b88f849d17fe2e79623d117024c5de83d5f252a696c580f9b5d15f7d6fc7528ed288502af2d46a548edb7ceb96734baa0467f92887d0f865f66ef9a3c9b0ecc7bf657301e1deadddcb25742b42e34fb702df1a0c98a851239190afeb884aa47ec592ce2af3f2ac5bd2d5268e4300f0a044c8891baff36a9bc4c2046817fea8536aac0d3a7756bc45914bc5e410c6843f1225413c04581b701140219f39bff1f4bb5efda0b8645ca112f55180a99c87be6d832c22a55498e0f8fc4c6236dca68aaa363385866539941fa8716eba2e7ac10b0a49c683146da336edf13277cecf21711c84708d9a32f8adef2dda14e799cc5ad54fce0e2acf709d89fc4d0e1ec0b013b7430730a94021d6d6d68103db951e3038aa7811bdd75ad80b8c782d2efad0086088d9308a2ff7d76e9a7330645bffc2514e976f4862912bfac377ef541bb12ab4cf55b3d585ad5c9dad230290cd6e3b2300369427cf5fb459aa6ccd66194caf357118b298429a1ed691aee30cd6cb44beb6610722342b3640c53cd60f892d2ae916bd5d3b3b9064fd68c66b4dc6b2eb0b6a309c6dcfec48f0c5622d4a51a2fee9d6c7e8e34d7e6680d4f5c7320fcd78e3afdd9a79373980f1bbd20f8852b9c7a9d9ca63099b52d4bbf3943e1a0029ebfbc80e2a58ff09a251203b901b229ad86cf69753b4ef29de0bf6703c8beb1f7770b9ddc0f9b97da2aa38bfc3975dd6551e315b05cdfa9cbd5790ab6b7c3c35ef1d1d57ba53a6430a1eed81ff65b56bff5a3dac7ac1b4d7f6f3a1677d95d2b305f39b2ef4be10c279c046591ade921e9daf1f2f6e75fa67abf898eeb0bb2ef420639562df8ce5eee9dfdb0ad89b2332c2a3b723e70c058597124bbeafe9891ba19ed5d140ab88c680b96888c7474978760d2c19e592fe80ca6eecf02b3e2518b238c2549bc0bc843180dcbcd6a34865688557b70e478873a4830cc169719293616798a6341898192c772c2368dfa8bacba843ffed8543d44fb712dc1512520ba8829f89b251928eef88b673847d1cd277258795d2a94bc5c7785451d8fd5f399afb249bed2a1d8a610ab692efb9152a0b0006ca7408b412a69cc1d6076588f6b4024d08643fe38129f40a5d38b81f0f6bce56d8e1b9121ff2fed5354cb12442d5b27b6a9130213eb0c87f7aef3bdb0bd126bc3aed41f93bb43d8afffaeb3e99d31cfe06b597ea554f128de9087124270d7da9c3039b18ebea64d1d3174b684b441cae1584cbbb9a5de13482afe5450b2013c04b83ce205d073fad246cf6fc7900e19278490e5c143ed04b60889a3b950d06884b0e6786bcfdf627412f4c960d2c5ad7887b124e784cbcfbc7c9f5bc6340d5721c36dd1a65d203ae478d4eb6614697fd25e7e1a8ea2120d4fab978c2ec9d3f6a1ce7bed83488fc8101c71509bd0eac08e0f4e8a408ccb4acd03217b5edc06a64f4e1feb650eb6b5188f9b41e4963859c9ba3d8bf3f97550a2970d726cc3bc826c7d8e36b11796e25803c4ad2bb99ff3e005adb439d744a2b85226598ec7f95aff3a5b8fd4c675b1f4d380e8cde0e24008365dd5729d048971c4e6e63b6eca3dc5de265409928ad33bde0851640c97b92182560330ecbf9035bd573c8829bb6ef3570f1c9eab9a07b7184117f98b05eb52da8158b96974b54a56e51320bf29c21e49b9b8daf675b9b1f27fec67e519dd95866cc64c9aa6f97caaefc6e488e11169ae7ede22b8c83609928b6b9a7ade857c6c3fd5e1035a968c986002d6efe9f6d35d0385d9f63b38d59f8bbe93416d47b8e621f231c77f0664f6b7c04483404b0d174103493fb0e08cd183bb7db5d136dcf95f5a31a1140f57a6ac9eb71e2347ffa88d29db0fd9c74f977888cd3a565a3a4bd78ece8ee74f6d8038e5a8a45b0f2835550097cd39495215a15d1228c069e054d534102cb720816454b47961e18ff5c41d7c4a4c3615c6d7f57d28a0ce972acc225e2b2dc0535d0c5cae46423ac235f4ed7f6abaf9edac0d6e26a1c485b282c87ab2f6384700c54bf4a082445aeff9e3724ba198f6ad7ddf184b710616d2d0f9ea7a04870bc7b004b9fa40128bafcab36bbeb17f8129236387c94d726c357e87452f38d467f3e3827504485617e7b87bc6f9432887d6c2c6146ef29261b8bf0a3c5236ce363c34171b13d40e8ca3f7ad5654e8bd891c085ad2360b477f06dc1fe404c123088018a8f4194d3c33f29e2149bf0e46886c6440da009dfc7e6339f4b82e9731708c45bd02651d8841b8405c90f7594be6b014f38fe972f629f43986aaf1b3b61270bad0db1f6aefd570684128e855b1c7dbb178f6320f6ccb0fe35399fc192c3967af22c670646e1203ccd8631312ed60c9a578dbac16cdcab3705cc58719019c79f15e732b92484464fe54c131487cdb4b754e76db2fe1a9cda1850cd0cc281dd0460b6fc986184e46672976953021040d62f5bc5a0ca0c85ea2ca2115f141273e17e4f72a1b479bb39f812577ef593632d96e34ff4b2b1b65f5460978d61fb76f8fd2bafc4a616786508dfe3febe5645a7b242977907cc9df2c5588c3ccf31241a7d0c6b62663b5ea64f8636d4ad00322a3f4301b27e043aafc4190205cf038a07db89ea5eb67bdc6d15b4c5547e564554d7de0538ebadb9feebb1d93a934bcfea8a6d2c4bf5882facccb875d4cb6e32d476af552fd0a4f27f9e713aa3e0145b23cdd6c8c5f6adacffaed60472af5aee795f8c18a691b83253e30f235143674afbcc14cfb25f365d5ba3a59999efcacabdd917c5f01883b974c8d15a5f2aa99095a8080913bcbf40d45135fc1ba76ca5a9d5fffe14a6023fca01a01588b303c4f95afbc37943719192c2d85b8f58987fa90654aa32f79fa5b65b74d144671ea901b4858282a1d538076b6488d50291e590a4b3311814fea520b4c313f00d231768871007f58d79c16eec01bc66300c670901dac2a3165c278244bb6dfad8d5e06deff9aa05a89904de75a415b27f80c3054f98381e3ca46838fd90ce51515cf8dc1bc2eccb7e8e37cb7fe95307985e9d42863f27de607c6d3caa5febe8bdb9d1df988ad2cacfe434a9aceab0c0ed752cb039d77add4275222eb6d89b59689130c0fddfa00a99db066f000c4d6b2db1b7d2ada654ddca48c7def24699006870f5765486b70974b963460f2256cb66924fd307a8132ec6d0bd9472e09af9d24c86ee3d4e50655346095411d240917122f02c1a903bf5f1a6c2f38df12f93bf44ba77b277507d1f0e92ef6df4c5ec8ea098e551f22e5bb61f4944b36107ca4bb82aaedc02b19b7ff40fe9db9496014ea965ec98d98e1ab9b4a7cbe46d4b3b2b03d91029ff869c1776fa6abbc5bd38fd8d4a865becbfa15cf0c95f451a168fbbef524bca346d45f38292936ee19c2eac2b1dfac125817924f75ab1898bf81d7fe3cbe6d6998c72b3592cb402839411bce42bb7d2becff90b39e540aae6d6fa0d5b50fbb3e84acccbfa39b228215ba9ee17e39e560f0657650e18d560a1476ec3b4162621068c2edc8dd6a4c804abdd1feb367d1471e07a3934809dddcd5dfb64c7d6cacd49bd3112916efe04d63b9f7604be1ddac84e6265deb1d3eb9b52dfdf8b18a6b70e4449b859c6d9199b2f5c0db4a3f9e9c66f0c58b0128b45141dd2b38b3183e79b44ba1daa90fc05f7755c16dc7c54e17d11c1257f979dcb3fabce309ca822b19826019668c4da89afc3de46e58424b0effe6e5464f8e475c22fc42e732a5107fdc11a54ac36a2c6abac5b141d0237a09824d1ae13a9f13036872af4f1ecc290860c038664246793c50af447972bf1256c13c84155e8212ad88101bf9e2243d294f63b3e76364d4d4420a5681f821e24a886bb9676a5bd4ba3a43821baf7456d9c17e7ddb53b2ddf143a00df17fe662ca7b9d5990733c94cc58a9a5a4fd5cfd05c71d2ebeb61fbf41fe9263a647c4a29ad6d845b4429b6fa1d7e9d49dc4526f051840654191d9d8a95857ad66e2429b678330d278adb08004f3ecfe388f65622d22de76bd6ac432b4d97ebd4a8d28ffea00c78b54d4ccc3876730370af7dff47a182cf8fdbb3faa7eceb8bea5cd2f10ac8da3593bfebfae4e365380cefe5f1963e0d35a9e49bacf1f4764e57df4f6e8cacec55418a73ba00b5be068253e26f5ecce8d16888ecaff667788f7893bfdac9814183dc9174410a739a8fab95147f85dfec32479715feb8e03a01e880178719ee5fc3b75c699cd2c736e4eef5e3980e81dcaabe17478785ec09b15a1a7b0b25900c839774d8e4a57c9f84d0b9d1c8d37069b6e33935ef3e3535703523fa663d264041a071b91d3f7dedc1e23c399ed227be932bd6fbce1a78fbe8f5dc1c28f7d6792cd8c5d1236ac75168ca23cc3681823813df43f82e2ade037fe077216dfbe7cf6b287ac3c1024e179dfc0ba6886aa48c4947746870ffae05a01ebdfb421628b76ed3f492d7e69127e3ce000885f8fbc37d4e1350c55c3fe1d63289843ea456ff9f3f81530d50059b49476c24e5526fe2b0efc3053ea77c44c766cfffa90b7566f0072158104d58a110b2916ec853db94b7c0f08e9fba0731f0c4f9fc168767e21d5ce5123972b594da38c841398c6a148e81390e5c2f508952944927cce28609af577a052285a8649a8c4452fba303617cb055adccbc566678b33fbe39b25b3aee46e408405ef6432892cd0e2f2b1f27691f36f03c1df1935976c90d1d70307091295ef00b57c671c91af3d98e4dce48b2cc0cd77d661fa32e7b88f71d3b4e7eda659e060e6c3c65f9003bf39b27371e88cc42fedf97b54bac82afe8ac1f4e3b892fe34f3f647181b76ead33278b5b82feb3febe67a51533c85b788a6ca9b20dbb549be7c6e149b33eaab393e2f95e22a314256796d53ba5c8103d6b5aaee9102e192355d1a911b87eeb0ce5a73cd26eb61fd37cac8f070eaef458d5f30b9610c2c2c9eac72fdf6ad34ae8a2509cf4ffb3ef70bff1fca537d713b69d3bc0ee4aebe8d6d630b12b5883c918398959d7ac5c27f93bc2bde4c2712933b582837c7bc6951097e6e38ae0ebbec7e139132657f7e4ca2e423fcb739ccba12018a884daf3b6da836bfdc13b55c7fae4c664df1edcbb2d51e262dfdc78","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
