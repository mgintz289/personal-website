<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"128a3c7194a54992327890eae0763bfdde4e5063ec5551c63e6bdf32d1bfada849eba4c5ac17ffb7d43710b7fc11db96cf5cf43e64bba76ba8d595cb34e28db023f12966a548eaf40d2a67ff233fa73be708fd96a1aca7470b23baaa40208112d1fcb6445690c6e0c8662a53e3637dc03073884a6f1aed7b385671d63260bcbfe077f6029bbb576fda347b2e102d8b3c7e63e8880fe7654f01420e631d2f983d95d3a79356e8bbfb9af02d7fba9ff71034a92dd639ed4864328b7ec34e8157cc70663903cc1bf3c13054194ce82809134ea935fa6ce503a28d59ce21115c519c5f03474f92a9ab158c76006607634848b8c4877e2566a456d04fc0fe76ebe2f1ced8608a87da633d4bd0690e09f6184a6f150c2a428c32b10e120f784647002e1db38f9d0f20daa90dd93cac6cf744cc283b246f211b2d51a8fc5f1ce798baa4f6cc237b543d520fca24d384d36196592be620f4e26f853163995d2819b9893c531663fd262d3426ad2162872745b1a46877f5ebc263cdb159ba3df8ab594e0e167914e95d8aa9721664a1465e70c2d5e45f0e0e457a410e1b11e9103596fc794bec1436af4a53ea8b2c9e4672dcf771ca0759e214b921c7cda496c35bdcfd9bbb44055b41143cc48f6557d5ab913d5389da8542675745e90e31f7c85a0305cb15322482e79362eb85af6f0735fcbf86265c3aba2c4ef45aa8b1e23f6e67d7497999ef14880a1f6b7ddeaeeaa4e196d2f16090459ef982a56933230175d14ffcf07f13b94d9113f48d681e6eadbed1755f7ce0f84bab7508e5c316a2a5305aaa7ad4da60b9246913c757eea3b0a88a34b19b119912dce70e8ce58c6958d429d44cff2f4d2d92fd9bcfe8f06b4bfad3ea39286fecdc07ecab12e8596d8045bee41807dfe1de9df9cd44e5e6d8ca4279805bd3745cae042e4da547e102a9e168b38dcf50aa65032f707dcffc2532b46c42f25f80ba92e4fb104b7671a974239d840e465dd36308133437ae639f18de942b3a39db5174b44ff001b1ec50d16e7d5c131ce4a05952cf94a08f1246b813557311e287761555fb66d5f86701c31fa015a42829b2b14de0fa0d160a27992e3868ecbc9149638d3772746fd74c23b280d555945cc9090167c3149558ba3a10a19c999b7edea0b7c56f737eb57834959769a999acff7fbd0d94cf6e4e3981ef970caec3b0a076d9c571a9afda60095af5b6839d3fa2bf77a33edead5f2e14d684c5b45a4d32c14e887ef2601319772b4e72dff6a276afb866004321ee5957394f5fb74aa3d1b6234b901de7077b67a193a8d0d5f641d3aaad2eb03996ed1f740dfa11d9e3b2a1526a1be7f19a9eb3c9e9498af35e04e6083ab0fcf75f590ef8b24b3acb13e572510f24531e680adff05c5a1d6e7cc5d6ca12f34c27dbe56af17f1cbaf9f0aae7381520707c57a765a57622fadc8c22c3b5501794002b0eb6b402df2c40c7a0f8cfc7594a7b313163319e12aa51030b66cf39bf766959491dc1c5a86a32c9e6128b5f1e61712a3ebfeb84574969edb041f4d3a82cded82ca69e7741e448187098107647db4c2fa4d0cd9abc028363983ac30cf3c8784aac51272e8d937f4bb180f173e2ab5e74a9330c8bf038b7090b1ebd303cee0739cd0e7bdf9cde435fea4d2ff34bea5c03ac99777d15950d60c512075b48a95c6c01c1d37bef2a4cea63e09c357416f32e4da17332f7d1c6e9b0c86adb09d3dc467c12ede60b491d66266da4ef6de6f7c8452c6225463fe6eee2fe069fee7be201bb256f416f6a4eb84278865dc1dac0b9c049d92113d6eafb809db66766fe14dc87da96a60b66a83586701d8283b6b1e7257ceb1f37c800d41408450f94d32fc5a77861c8f7a949cf2854b444e76edc1214bf95719086587df69dea5c1d26a1971f4367b539fb0941f428b6b62aa67696f60a669a7e27c0e1a8015a7daab73dcff7b9fc94fac4bca67890f5b85e1edf4f82787e8098cbd7577086da11d2ce6a846fecf996b690c119621856bf0dceb4891a8d75fdb4450f27963cc7f629d95fcb83b4083951a2bb77fb1d7a316406ac6fb396400c5079172482c207a7ce856c16f132379837f1cb7dd5900b6ce37f11d27ed9b93a9a00f52afabc36ddbd512f8fd06d0b2cc5adf9a635bc6b174f909afe28ccfc180b7fe4d4866c4cc0c55c435e7a41c677be2ef466543493888ffd3a127d89d29aa1b13f0208d50f9eabebc5a290a86dfe49ff2732bf9e56b96379d439b358317283254309c960859adb5b2724219ebd81b7efa4f73ce5602666b6e34662b316d79f730c4fa0a81783ddd04000803aaf4c92c80f7ec9b3ba2219966a89b2be7bc57a4763f304b434098087dd835265565f802aaaaabc6688ca25ed01c62cdca04bd4a0dbe61dbc0674eda8c5bbf78bc3d2c1a7586ffa8c171b4a2df84f98b1f3672a2474f35d471aa38f9807e11d43c0b81eb9eb5f5849b75436431f7991f9b04e9920e1e58da95835ca46fee9bbdab7e9329edcc87de981636895e8f75a0f7af5237266615fc9b971f79c854a9f89778ec02ac9b4b2f36bd83e17e27523910a76bad71b31016aafee7ac8416669941d658689ac937ec5ee0c987f0390db9bbb7d0509c02d1753022316d9352b75cd52ae704554f513b9efbe86f47f18897c041ed5c0585ed228a71e2503ff9a6ee1601d434f6278f4988cdb63f5ce4ea69d81d9bbe9de2f82eab37eaab8e717b01ca04636121c0b266a208fa20b0cf88d9b408d6a9718d6c08c17255ba2226cbcf5206ab105242db352a4e4c2ec299df1450aae5cec57e1ad79f1d468f974e35821cc8a4a17d11a37f13d8dd8113822fa694c5315153e2f90acc0bb1cf4921d25c75c177f6f2d7a05c9a4daa88b47bab8654d2766d87f67f1b7c0ceb9fb822b009874db8233bf39f146e6dabbfe46632d3c81e41269451e137e43cd37804fcdbd8228276119709d6acda8a6465d0761ad3480ec7e918c521df6f955f3a0254249dfec7bd93c01e187eaf350a9b1ad9c5f6ef45317aacec5d3e31ccb128d1c46a91d246add594b0b730efca7182e139e08bb87fd1a04993d3adc7dd3da070339775051a145d713bf5f11709b1d7c2741c5e5750e4a0bd0f62dccb4f4fbac7a84a8a5b4d979d3256e6f8908fc14f90930a8db562c18432c945190e36c51b3e1b88cd38ad61e8b84fdd6b573b7010b6ab646022b1efd74877782a691317618f98c79f541c9d087979c3283a480302509313b422cd489afac85471592c477900f716f3bc31534685e8b9845770f27109b9af3bce1f3f43d74cc2a398d6f4f16662c6ad324a3675b7e98c8df20157f3248c2db17b38eeecdb09cd4418dd097c0d98960612d6368879731c8b6c29074cc64a113997fe420bf8259d57631347e9dd779c187badeeba2d12e893b99efa2b0b7f7cbe02efb78f7be18b9c67c0a5778e49b8bb65a4a5840aef6bb16fd9d10fc3b7e76b096946f62997e0685d61b3232cb97b48bb3afef1bf646243e2363375594c65425086d8187e15ad910863414f374055a245d5754febcd6d084aa552e4624b270ba48f00d208bba4482f0496fdff546f862ea44a69dd24b937e4159d4306a4e419017bb5cf317876ab1282eae31c675f78c8e75d7bcc5e7ecae52144636496e644d8f6fe3aaf5d4aa2f8a4cf06698b556affc8057376d3fc372ff7ddcb1ce8cf5ebc21b65ea6409ef90d8abcf0b3401cfb1f7561c92fa2e91f609cd12d61bb2fbb548e01be3d024674c081296cb95e8133852c0895380650823371624c33ab98e0a6372713b0bc5d4e00b473ce210a8f24b5a54ee4bdc21ff505c35cc5e4ac91d49d2de973e93587c79203b24d7de2deabf5769795a4adce63eda19fd442e2c885d0365afcc3e48f94407223c258c58422f1d6d5a80ee53e8e2412462fcad5155555a0d353711eb79475109075b52c2d87e6735400f40c7931ddc1bcc79a23a7cfb61b2c48212c61388467a83aa065e4fd0c28c01e0bb9fd3d6642832691fe7fc171c7ebaadacbb302977abea5eb3a3c55a500bf62354ca8eb78318dd536e0d4f3cfe1e3aa23e1faf3662a154832192fcc5e56b1dbf1c805ca1b9e1ff98cef378107a56dd2296915b49f60cbda0f6ac0196bd7f0614f9521162108dd905a40feb4726a7b5dc09b37031ce2447d652f6feb2ae82633933cb632c7d00fb47bc9e1db0b72c377adcb77da6974297670cea4472253aa158091df41f5345c0899941b82f427d71cadbe76e2ef91e2f809f269d9bb96ef5b11be7b570d95438419936c00c3bf23b784899f831025275a99ede808349090fb460bd1c42b3f84feceb31688ce6154f9e5b3e36bab59150d4b1c189d1a1903bb4cc8aa2c48789c6f7e59d91ef7d8ade73b11a7f7ebedc958d2949444120527c02120d63059734d447f8da43be0ddfd9922c399e78795e7d76f12a717c515f73b9b78684ed18ff5071746f22e92f55692987276136009e69c054ef959f6f2c1a9820cfdd8974991965fc7d00708142f3799fe5ea68b0130fd6253c670138f301f61f949a2440a682918c3378c25c8c1b164d13e9363223e77e434532f136dff833884b0768d925d93da8e5bebf1ffa08f0b39eba24c718395b373b45e5b1078975b102f469c0bcecb5d06552bd4a1302add2de3bdcaffb902f9de0da688fa18dc18690206e6b74b9b469cbeba5a7233df2422ad23178d9c5753cb4aeac4dda19befb5e35f531b6b6cfe1aceb0fc7c98c19b00f614398af22393ed9d41921b592a96705d82f1bed1b87f0ce2f218fdfc1e27f029258fc5d6eb0180bc1fc2485ad100b849411049d4078ab0ae4540b6971cbeda060a63917214ce659003d764f4e28c2d23ab900202d105df2790f120e30e3ead20d2898ca88153604debfe58e15f6d8055bc00a8bd841582297c47607b47c86909476eebb6bbbc7cce6cb27cd0c20304a855008868ce6356b608d2e41b205af1f9b3e20b900730c16e9adab2ab2f24962cd4c6430c7c26a43cf0f5271a7dcf11d135317f60e4757612aa058b0e5776809d95d336c268bfea5efd4d61b7f147749f045195056c6d6628d4b91930e6c1a69d9fb51a1fadd4570bdd53634423cee131e29e0f982128e9e1088bbeff19e89dd0aeec8596a27b8d1b7b2fd7e09f8afc5bf17cb49e95441564a28cdee77c1fe42f7b14fcc72bf14c7c9795e67b4f7f8e78ed88ae2caecb52f25759467bd61c28cc650a5df61cd9aa151e4844586d7b2623194ca47fc33bacedf193648cf8b44c3a1a9c3cc47b0d87ef07b5f6d491081590b4dcedd3422edbbc4912ee1ae6a2c9bae77b365b6e193a5c0c79742534b989d216d1c76c4e9d64d19536d4b26d9693b3e5160b1aef41205eb846470ec61d8bfdf05fefe6c3a7d9a0f510169a055b703fa81a0b1c4b697f005aaf456ba7c9722e19871589b2cbc6f647e443a7d980b186f2d48ec18b9ab16493c9d0be0c4de1f19bf3a8849195c68ded0a1881b30be6f7cf7f0efadd1da1130159650f0197a3178136ae99a3087c7f5aa1aaa9047c2ca6dad5c8915dc0e662422f962a5a4196e902fd820026652b992f058699f53030c15912bed10c90e1b685145c3eb3fb7f432610b1721981666bdfcef4f03dd9bcb636738cb686052c2d32a0133e8d43907f4db829a8ef470e186b092d6ec03a05438f9f734c1ac1bef1a121ed7fad1c28b5a9f784a8821c0e24b8798bafd9ce796b5ac725f8e1def6425661a0de7059f54d09708f0e3d8580c8dd5e2a9d3b604453565c650de1c2e5e832e81b0f6688b413b1fcea45b7139c818e37a82f3ca38c2f506e5bbcda0dd2899470407e1bb9d25a8c415cbfc169534173c6b3b35544273b8f77b62f053b616688f8e555c9aee24b2e7ace9ab6313adde2a209aab06400bbe20998554a9944d9e8d8e3aa388a3dd8cd07512983a0f3b7d06e5deed74d31510fe9898f95d64bd91ebdd4c165a5393cca7d962ec43a8bbb12f8175b686f984922cc0119ac9841edfa8bee0848cd0db06c96c6cd1adce39556ddc7a8b2f5cecd3bde3ea04552f3eb6507b2cf99773f056cadc5f8d25fd1ab933e9f88f7f20e0ce5c2e93f3c03a4ff8396490bdc7e438109d8498dd2d442862a2b5ba7cfde01f2f7ebf731aca37836467cdec3424449c9debb6239a0f2976c610079c4e91f83c708e62fd6924945e27f66c63fe0cdf8bc1d84ece762df8e0e3ec2a27d31d764beef84b36fc3097e50994cec3ff5aad3b277f1246ffc693676aa4ed98b62b9aeeba0eadc6cb7a4cf5e0795c8d05c39c64b2c7777cf5d6f2513df4a5a9d5346ee0ee29109305c8efcfec79824c0acc21c76c86bc32a36359722f8e7672ffe97e47339152abb6494426edab00b85b5f4b0e326260634010c84ffbfaf7e5f8e5ec66155b95cda1dc9a770a240e1be230bb147896f999f1e7c85e7cb0c04c7746a2ef774daa5d55378bbc37d44a03540bc147cc20daeb739da9a3db65bc398a2323950f7b1e6d1ce377485d60f20eb653b6f9214ede67b1e1be99b69ab6b3e8026bd19f8f7af0c2c4f4bce69c542889db6fba21d9ed180b852988598c33bdb30c5768a95117d1f35f94d10baac5c5e5200ea2e000c9490dea805ee3c6126a6071200afd99d374ed72ee57bf7f805fb4b87801b2c69b0273fd5f8f1bd377c37f8ef5672c84b840594c6d9e8031a915072d7f9334ed921638ba4874e11c35c46f8c9014b5aae5d0997996f4315d33a64b38dfbaa4a1cbf5cbb467e23ee0f9a43e13d03d39fdfe0a34adf9461d150f68a693b34a4fc8bebc4c21c7fef589bc320465e1f4ca51aa77fedf644fb20fda9be51a354d487ae012f09bb793cd96fc047eaf5ab75eacb9820c8a2968dd2731534c2765076f3a39192c0b869b51817085f95c94990d4afe6ab921a6b262009079e87dd82d9131f4c0eb843aef7c5c56ccb9537ecd82f654ecbf5b3d95f02fe2a3c46e5d22c6d187cb4546e9585c0d81aff1fae49ed54860af517bf8dd9e94235d2cc069382c53b9a8c036da9968200c081f14e9f223731e6f16ac5867bcda32e4c8d4eda44f74bd6c17d0c4957d5ee851806b51b3c881b3a9a49add5c6fbc60e59bf80fdb3eaab2d96de73275842695ed2e5bd4d7ba585e8950b7078a93f5adaeed7e8d946f736073a4023cd0e16cbaaf1cf111b8f8bb3dc147f287f705774462ae20a49fa977dbc68dcfcabfa9ad706f0df755e901bd9091f7e08783359f5b1f260d564812fe2e377f0eb68319df53ad9b7e5e5eca001fcbaeba48d946a7c025a2be84f95341c2effacb9820694a646d9f7fea80b27879f53d3edc7b4a6e674db546e0e9639a68b154e63dca4155ba190ca8c78b6c24e410bc758b379d164745f558a94b21ca75d45b71248aa788f3d6aef620be4dc15f747dd4eae48f483499e174c905665dd9ed9d91f808413009c171f39a50898f53eeefe5cb728661d66771a950c04bcc0979b3ae136d77bd5dc139c8d53357d21650e906a2a0bc7e1575ce41548cc1dbc41598077c75f74fa2058aca36d11637860efc95f2a50ce370a933a7cf27176a72d75c06aa2cee665c23ff6554bf71f4a80743bf22660dd01b31001074dc39c2b47f35df3db8a45f03d7afab0c5ad8bcb3f6159c3366b5c234deebcf3525822654621d1ec218d03b8407f0339f9d79b0d89118543b1e49956dc29ce7d95fc8c44324c3ff9919bce15dd1cfc15603020b4f4b98208c967562df0657e407fc95724aa737b265ebd3b3947f714ae34cd1997326f15c3269e2df8ca6af1f513e6f09b9fc526d8373cc7b8a26f380dfaa6075eb53bba38f76c3d414c42ed8950f54efc529dfb2fcf2ebcc1f7742ea7352599f06cf00617620d9c140148222500df9aa6e3c4cfa1a29d11a17d50b19f3c5a0fafe7c3adfd15f2c06b84b6b0f9fef4b7707f33bbd93452402684b03a5f36bc411f592df651e8c2dab91193ba74292276390359cda7489f226212934a08e6de3a2b5d6e01eb4d64a577d3df1d952829387f096fb3fcd6bca6172e98655cdc5f3ee5a079159ca75096488f4129160c4a5c40e6c3f1718927c85c1026213cf10f54a214328b3455a600fc5a1e8a234fa9eb621bf8edf013cc48087d58b8cf7117bb3d28213cb4a64c99dbfe1b698ae3fe6f2de2c433aabc18525c605e13ff56dbdeb10f90b6a23f798d77999d5a90f2c098078ef3feb8e957aa9e813682e1124c9a3a36c779a22fc09168ebb23ea444496229b1f5286ec1c7350f27fdd37ae770648b984694d7d3e954cc77f68962e71119f1b541cba0b76694b93e23cdd31ecf7054ecc893ee266ae73c3d74192049bc7d8a03855d1d1fe132871f6136855b9e363dc3b5b840061fc10742999a73e202def49f6682f43b958c814964a64ddbb04e8e4bad1d4dd04eb1f7cc8792eb851476f7a3df207d8bff401582cacff67aed118e946bd85a6197effc823b27494c4aebbd7f51ad52da92c7c41aac20d36da39bc882452bdbfb80c6d880e19d6113aabdaeba0bcaeee8eecb30feab3c9a881f25b5ab98d21cb74ceab41bf52c40dbd9e7c33b55aaa6ce1484a4010ccdd8c8dc2ec45ea2b1d0d11f70859a676758a3a3197edb290fcee1cf0bfd4e95bc1753a8537eb069e19b001640fdc24bcc4793d286d0c8aa9657fcb95303af1c9b6c4715633770ea1776253df26c7394260ab6de696b88aa3cc417246bb15f847c7655111ada161e716e17b63321c4ce989b5c2251be18222e21966006f94c2d234d70b2d7a05f5f8b36f757ff84e77b9850c6bd938f9de4a49582a88a27f32ae6d7aab9d26584c63a566b275d7eab9cd276f5cfc851211f2b062a085128873c7b1658d0a7a32850578a3e28f8577dbf6091219f86407da6f93d0d6a6f9b538d9b60d3a44b80b6f4b9ee1dc51ad4beb44be3b9eb4975e2e239646e706f5a72acae1df444cb414ec2ad7586b322bdbb448b46d9ed50053d9a1e6b85bd8c9703fcae23b1782182e8fe4d64bc1bf4e867cfe3a20e404a2c604a851f24794b69fd565ee9128a6d627f487145d8faa49de81dd7a05448a83540b70b835f123515a5e7beffa247ad9d61bc8011f3bf1fb793d3390bd26e1fa8d25555f02db72b1ab09ca7fd828d57dfff7eac61cb26cc58dfb47c22c104474b1507eca5730adebb45785bf73477deed0ad5b7dd06e03e696a6b262e60dea158062feaff39d7f097b8fbcbffbb62f1b64686d26e0b1dfad187fdde6e60bb013c104f90c59425ebb802a1bc78d592c7d86a71ed8b74fe52f438e639e508dcc7b17c02691099d41090fb2d4dc13ef588fc93ececce3a95b205e7dc3c5e22fcd4afb135d2f9108402efeb734eee0484aedb209f259632870cbe808eb7da262bfdf69a8e30165ae6345526c2fc7e0a35b0676a6b99aa4c24b9cf490585cabdd6feb7f14483cfbf2f8ce4571144ae80f87ab695a19c40228608a7d41959a3a31bb11828f848971ddc2d8363334d8307031aa6e0d4a28a5aac05dfc48c4dd8c791c6bd61b856f40a42dd10ea543a73c85c5bb8dd5032112872bda70bfcca4514823744ed7f6da40056fd89abc41b1a732d04bd7501d914b9c57db6b3585ef625a0a9b7afc5c4c2f144216167afea9a40e151eb5834c64c5ca0888f6c18dcca254e762fdddafd92ddbe50a3818ed34482cbefa0c4f3aef766d487d65bd42fdee586ee98e23a18a7c8414fe6f3a2144e80360e5a045da4a821e4966efe64da4f954f216b32daa72eebf50742668314e0f719386f4600d436bf3e4f97ae3f6edf748534e8d1d5a15ffbc28056b6b8beec64680b4e3dbd219167dfea16227eed83c1541ed90038d884c6da25e19d44b61d0bf4f33a582831fee7603bfe852b6619236ba7bb08e591dd0523f0546b8df65debfedd45f092de6def3cc118959951a022c0dbdd15e22348b2874b799d98bb048844c0c9a7319b32bf2008d938b2641b1cc1bc8104fb9e70917070154dca7ecfe2ea6c1d48c630a8d77a0f60c416af7b6580456abfe63888d947349d540c49d47ed4a6535d096cb92ab2f847f2351e921f326ec46aadf0258e3066fac519096b290812c8b6e8ab81a99dca357e03af2f85c652cd5cde745bd1479585fa413b0b01904b550d2c4dd75bba523d150ac8c9b3045298f69d57da993b4b79b803c9c0a748f306ddeb454e85a3d9ab356ceacdf18d6a665c7279216d86aa330b44b4ab0742cfecf1fecffb0723ce24011db752789bf49bb45721829205414a9827d7ea6e1d182cdc814c0da953f10f9379f5204200b595828dc9bb936932093dbbbed032dac696e3e8d393e61178aa23dfe75f273b5e749f1f25647267059d32d9e0e0d55b53d442fb3810f6d4c1d87f1118e26fc6ee6078760b87a2f15ac132807f9a9dbc205b5aba711ffe3ec98737003ce2446e0da3cef63b16fbd95b534dce4ccbcfc820b210adc07959a97b0c694f6f8e9555cc4bbdd6e39ab5408f876f32ba08f49f47988ff31b4a170dd56bc65539c0309d386ee6868bd5ecd0440aa0b65e9b10bd5472f67b8c1e8b2d74e0c62c2a127856a943f493160a2484b3aea997274e29e3a0a325d7a559f9cd31f43fae00e4d49d5c53b95e550f2f97c288382214ab1ffaa75a25d144b65ef29eaccdd3c6a8a92c8be178c1de56c74c82bcab49db1a8bfd3e4f49375363f828ca49dbe911d7f8ccc46e27203b3edb5b3ca24af650c1c956c1f0d5a65a4ad5aa8acee8cb258cea298185ff8f99480e53fc2d604734d4d2ad1ae07a22005f6c154d42e152e37356272d895e45b926846ab858398409656641c9a99c343641bebff6215311d9b97d3c5deab2d47f49d99bfcb90476b47a23b0f2fff72e5547e702104f04c00a325306c43a1c2e85e14c9cb30bd094a310850272efca705c198fd4dae0067ef42da270c3aeb15f4c588ffc4cf927ac3a8d6bb912f7101924b4c3a2c112d44dbcc77535dc1965d9bf406501a6f520a5d761a3e3d01ad0a479b977ab14bb311addfb103016e83b93de8c4eb34cd6ff32d68bb3342a570bf6d651d1625ab41de1130369927e36ee13b94cb7e1e87f8563ee70282a7aeccef8c4fcc8e80e917b14ccd0c03f765e52b9ef8921cb3b6435eeeaa1354d35e8857a8f1e1506ff42f40bd34432672932a964287f4585e5543df7c615f4150278ed28ec7963df8cee51dfa27160f46bbcb6a42398f4074a44ba4c7b2bda913d1a225cd94705643db2b0241a76998e6457abfc113d373ff72f90ceabbe131bd2b5214e1c8cebe95cd874e2dcfafecdc7c77fd367d43f8bd298e84ed2768f469d50f16720a0534a63db8f11ce4d48272be18ff27434b6ba6700cc882875865ec9f8404a206d7ca2d9cdfb62c993fcb29306b217cf8082a9e55a3471c204593bf488318c2c9abefe01e1cc624544517cda66472392cae59cabccc3af285a8c706de006ce7f98e786b20e3f5601b5973d340ed07a1a7aca229db86617a0b73db307eec0cacaa71ad30ca1c2caff9eeb2fd2f5d258482228353c0647ee0bff5236c0448a91132f032b0d95737879088b6e234ab456ab252f48b9aa04dadf85163cd2f994e7fd86ffa2edfe784a38275a8332fcfda52104a62046026c21e4b9229d45d97fb71426ed4df803521297bcc9715c819451b5639c0977923b8c5b024f394aa399881289e04828ac41c9cde2b0b6c7127942649a7a6588051256b4922fa3e8d33c81c5fc108177c9e5adb9a6f50eb14af0dc3fabfcd8433e314c8781350f81edfbae263868da2d7162f90ebd7edefceab9e925867a8fc8c10a4f52e3ba07d13c0f3270954f47625c1cca52eb29ccb7c112c439873bcee1320489812cc3405db198a1b16eeaa146b383a811a38ecb9299e319f870ca79727bf168cefd757d6c2a32e6449865779126727a19570f804b8c1869aa271fea972290f8cfe51a18a9f7996352cb321002e13b4bd47e392aca2fc24c61dbffd49bc1237954da4eb5cc52a4605f30e9bec245f11239a5d0b75cf327345344833cda76a331dd38377e29e29a29e350d52d6e84d41dae5ad72fb52bd96f25b8fcd02845ab9a09d3619900971826dab624b86dd8549b026bf7c79f0d4b1a58ef7cfae2f15317704342a06bf8e5bc66a00ab4567d01d9d34b98d72f63d1fff175ae1741cc168335d4b9555dc921b899513882a5b9e9e87b89647fb274f183f2ea349c787c6fcca4a4509141752e4d032a1f54e61e534a5e3139bab3c0c01dff1bff54a7eea9a67","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
