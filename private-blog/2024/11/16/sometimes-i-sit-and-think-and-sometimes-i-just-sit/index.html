<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7eb1ac08ac0e4340034ee573c24ea8b14740ec148ab58d59a70a68d60a81524d6577aa4351ed0ccb65b94873bbb9ed2049e6d0c699b4aadbc853f697595d92f8a865d7b24a569dfc0a7cf51d8246108bd68182ffca8ae66945215d2cf51f125e8494b4c632c7c1c023d18ce3232f5d8ed1ef1e4aad4e026af06eb2e77aefbd96463dfda9e93d4d58c7356bfdac77dc7dcb4ccee5b95eecd3d8a02ec7ae03d81d1109a8338b220ce2c876ebc5ab593dae9e7b899d5be29ec8c1b35cf3510c7cb07722411271cd692664d13529c58b37f368b2c5ce6b44e62703486a22a0e05c6a13ed9ebe8f76ef54b97934d9edc35334ec25262604ced66583217e16329a361bd21302ad316c905d74e27da88f48bb701e5cb5adffa8a77d13dffb9993b15965a0430d4b0502dfdfaf0d77a895a501e549e390126be07e11706906de36f34c3cf989769e92e0d98dad128a730431b635134619c3aa0ce0582cae657f035615c8b2125d65ae3abf3e01bda9e87be6ef58c56d5c31b2b83a2e1a36e92c4833b2e0300b3b1eb09a60fdb5f41f23d07f518bfcc595359cfcaeeb7307545ea0292877dc0a3a9d09503fdcc69ae8ea8901fa1125fd31deec087622d2953ba0efd94006986ef8d0b4ac4dee11c1e4967a9ad26765dbd25b630995d0eb87c136803cce833830e8066c02275f06b999a731fe98a15d0412c74267fdeca6330b4652594da2dca5f1dbe72c382820843a5d393df658fb36412a7c80447d3cc7c900be9b171fbc96e42e58dca90935e7687a094efe003e4ecd645b5c68e5804e60b48909f943006c86fcb6d856644a12f0f300c6e52a3c2c16942a11820d36146961ba6ca10fce0a632951a5453508e2153961afd67519e41f930e04489e02d88f7edcd57b6aa805bd63191ebfcd43a27527c3c9c59c4503c5c87a7cf5fca40a9b312dede6d02d104c57a17d876609d164ffb8cc5102db40006966ead5eeb4ec2368e7918c315ebbf921717023c0bb96fdb838d52a8a351ad4193aabcff3461e60686acd4b4f97db285da6e1546f68c092b491354935882802709a7c97dc435cd43150be283491094dca4da37e627929f4ed64842746d33449f3347281ce71643cc316b7c08fe06632b1c7527857a080223ad20684c7893501aa050c48469b1223eb869864502224cc0d1a8934f4d32ed6f5d963aa16ae56e14f9079d9352ca0548f56a5df35a7d9c9110fa5ffa7ead149edc753c5866f7e50577c9942fa378b329ddbd4bdc330396a609f7555af903704a34eaf451f82f40246bed87db147c6dc09f0d20ca8464e7baa0bdff8f1717e211b2562d5596302e862e94490cf7e0ddbb01eb15312e863fccd7a9c43160c7bf64a15b966da49f2fd17689781635cc360ab5a0c499f7b0b7c24c5e943cb25f37f5024ddd67b96af4de0700cbab468126f15e0a94aecec4126b32e7cac4be1c7c000f3712773e7f2aab3dacb0095d972c84e624782359597c2b6cedbd5a44607a61671fea3b374865fc5a50eb76d6c0d1d71b0a9b660a2efa62a50110c14008223ae5b9a0cce8637c8ffb3c636d34ac8af989d528bdbb4235e2970181cdb4140a31997cf67c2b997efee07f378b89c18816f4437f3ea3dd45de65fed36b2015b181bfb4ff90e61b791514035c88c5fc9228fce62c04b881ff92a5feddb1ecfd61d0ff022ec3dcb46335a8b95f53eac844448bc985d4be13f635cc9d976d60b28ceadbd19e6d09ef989fa30e9c9b7625a0bca464d3604b8cf1f0d6808b0360ad308c68c953e24d2e473832bfc6de9fa7e95d4bc18a3246089f0cf64e57abde51461f9e7e4dd1b9001226256fe29b5b59baf5132c52842705370cc8729eded5a7b6f2c1335fd9f119f46c7c6c0fa4829487224125c448fa6efa8875fed2ac9f81f57f61e86dc03e6b0cea40e8dd5f182b0f44c7e4231ad4c424632e3c416014b41803fdb8d5f2a798c38320b5c04e6bdc472e9c597a71fcadaaa82421ecc4169db0220a2cbbbf0eafe0ef74ea8f507ed71e062451315ca42de71c9f893ff1ade830b2fd1d01342c208c379762f4e5898a4c1068497b9a2bb4705d0455828c4952559c7add8036584bf8b2d2ebc8260969e73c3c6edf3167899b5dfbac8966db4ca540a08d83b9c1122e9f0eec2923d0497fa3aa422b08ce01b55dab1138f966f09ef2bda98e370821ac316d99f19b03556a87ab30416480094fb967d576c0215092be050e66c35ae8771bbf0d8db14a8e3d5f932c7a09f5a0292daf303b1c4a6ed3f37be9000501963474e583ed76b617ac984e32c87fcb3953d9291db37adf07e83fb306a0ae4564a5bceb6ae468dd7a151ab9131fe18c1bab95a67824afb7b487dae6b5cf20c3f197dd5b141ee18fcd0f0b3839b34fcb747f59cfe8d252667b1e645126c3ea25d60102c727956ce2a0bb6a21c7a1e13c131d8380765824fae435c3c21590bec1c230c248613e1dc3fb2db2751a2c62ceef3c52f6866a6c1c372c57976ceba6ae7a0098b71b7d40e53bab1079db8cba11a468a0c43134d40bb2757dc6bfe770ddb49583f13e0037eccec3cc3efb9698fe6d45bc2347b8b7b8b9c728ae125ac2bde8f7aec12e3f188f0e0c4e50554e8e05bdcc4df248b65ac8aa0069d2e7e0c1c4d0a9d26d00c73d83a443219fa4d44dc9dab8b62d39f62d656d245933773d79d39dc6a81c3a0a342f7ee15356baba1e818d5ac435623d5a674565c12eab94d2789491450c9063ef8d44f9613ca93746352d7889a50bcf62e83b514361e533a89f8b4b81586fccdd17c998909e595ba9ef96188bbc51ff4bb79db9db56fe0adaadeb5265a5abdf9697a23c9baf19271f518b64b66dbcf330a1f7cd26c5c2f1c0f3c26e080ff444a63f2e333a096b6ee07c05f131df778d5f16b8c6ba23ef39393f69462f314f16c50e791308178cf2b062de52d9769d764693c8bf5bc817e6a59f4d3a6788e0db0863d4a1660224e84d99ff9f5ebc37ad908bd454a3b70f8074c52abb79eef9a6fef4234f7f809e9ad6841300b40d471c733677543e8429c66ae49adb62d1bb550f1e081602e92ac751828ace5c742923829fdba1c522bdc81c3d83769533e751dabd3a490aa0aaf56917c4d3950d488f53aaa34039cdb37c9be998b563beb823d1619fba288b5e59f3d357b820b4957c41a5dc22eeac5e0f92412bc2be377870f5edf6bc43f1a811440edba5c283166b8a67e66e1ea611a01b86b9dc4228f0ac2d85a9faa19b29ffe22455fb4fddcbafe4fb401ab58e5073abc02bf970a0a4ef7c3f2132906c10369fecce2920acab1db2f2cc432cc6586e8b90e11f2496eca160159cb724bfff1831ebf66d9120f93873ab578d3bd846fa7ef95e26ad7bf0c03fe6d8f8e53807f253b680c8ed334b71c1b4fe9a57fbb7b6b878b74eecb3d52964b827c48269ef7e1355d29fe9aa1adf3930013e5dbc0a3f60cc4fd63809b1d26257a9a6e5155a2d6a5f1fb513d4a24f74e47dffd764e0cc0f1ac8568afee5c9061d2264bbb807e62c022dea4b3d1b38bf3f4593d54dda69ac48e131f899608f756a53ab8bd8b1bb306e22e9c50207ba4e1f98584871ddc7527797e54d5f45e73b4fcd947f80a49cf829df5cc0fb84f42f2e9015edf32656c4ec5217679bf11de9efe6c8b435021a9ca436a348451c55b7ff7520aff8aaa043d079de6eee0a455ba3aa6a3ccec54dc01d49c2da89c43442ed1cf3a5be8670689466311be820d73be74a8b81a76089982abf8399d4bb8960786b954c5005cfd5654ff2f02012a7ce285305e8c3bd4e1d54bd99ada246c2d46b7e786ba174927976355b2fc2f0bc166592090ab86074ada4a58c286ef3e0d0af5e4b4532ff4b997fa8fb0af7387b52d9856f556935b10e10fff56fd38886bd4185e9dddc9fdee2efc19fba719ae67e8a930ecbb552061dc31a4228b1c163484373f9ace422226294e7ceab300a3a3658bc8f137931e257f7def616bbb1e8405ae5ef462d7b15ca5a17692d17fa35ab01a36abb868421765344e363f69bf5c3c40e3746a2dd3a8987e73ab10a7c71ac6685d9398731f7b91f67fe6ff1eeb9daeb01cd8c5a44533523af0e54f8bc0e86ba3b9d436ca0c3511be54c3007dd7efd41649b991b91eb1d8affe93965e33b854ca6d1c0879d26cb40f584acd9a45c002b8c7c4b3a15543922402430522edeb026b89fa01172757c41fbc6242a8940f01f028743d9300d13b29d55ce61a8e739b60cfdfa111ba1f6ee25eb3f5ffb08708d05885ea701ba4b141ad229c6063a79ef4cd8622b7cfd04713d5caff686a8a6b083d96a14a8fee0da2252c573c589414eb759b16f5525d78882f125b7facb80beea580521bf0f4c5c9ae2eef1492400d664d008221d9286f47ba20c97b329c9b0da4d9b6ba7cfe7d908898710ed3981954c39d75e81b1e5b7412be8973300c7684083e04056bdc1ec8b67771a075fb5f38d5c1d241b6f16f2bc4c629d1e71f40967a96abbbac3106d27213596abd0e420dfb8a8579d4dd9d267621967ae99377f8da7a6b4fea864d8072ac2d81fbc44f15059fe38309b57d80aaa7f944453cfdefe43955512d10101d43747040662199ba66293943ba63bae2ebe74b77be99cb8c48dc9515193dad5930333e0eae20e9c1bbffd67c7c7fb72455e211b91a9aa7de21073b20b67df8d796a4fba7a70a6e45d6ec9260614372f976583c2279ea3c383dde58a3ab5e3d62dcaeff98bf1c601d8c77d9bd6ef4d7f05afd763d5475d60c94aa2a2be923c0db257ab8c880ad3a10fe33e35e2e6a179352573876d74e2b766d252bf92b7448693155cb1c41a699e0d191885a76fd40b4423232d4ff998cfb8537f6ab7c8c6d978d2c922572e0250e25056ef139b59762b6b530d95f57716207a63ce33ad41199a5fd9463a2a1b603a117305702c520083822fd65c6f478f956ec04858fe76d2cf5437fd9e650afb862c53baeb7eb71f4e30d724cc0fdb65d56e2578443b6ed4e06f2a2b372fe48719519e9dcaeb17f5a0a139e21ce4bc9a429e6871a443eefa2bad8369c965668ff0c447339604ca6cb6073d7b5a350b208b17710582e7fbfab426f96def4f266d02397f7a1f2562462711e64ea422af441445d7017c9df0f041a49384e3a298fa41149820dceeb2207f79a9b5f9acd55df25c157119f456dab697bdecdd05d18632f8c31a854efabc499937f13792a82332b16e0d86a5bb606aaf3c46f0c2ed5097573399d297034286bf48670e7943044fa8f7388b2aa2bab929f93b7e41155f5f1ed6d97d65802cb3da577645a51bf587a2eae791b5ef5564376917d86a45da41accc7d4efffc7b70cc0592789fb57d021f13ca6fb102500ba35d638c8fb6f9d66f4ab5a2d060b4c8183321e325a486ecc995780c23ac82108633ed88b1c6395a21a3898815554fcf75037c425630a75a5480e9009bd157fddbcc5f3d2375eb508b47fa1f98d83ccf94d4692ada16cb6a32fec67612b39c33bff52eef618fce56c31fdc1f2d70760dac1fbb99625ec93383ca10a4fc5c66caf78dd98618d967f3d4b789fc219238a82510ff14c2e8aaae1dcf5283767ebccdcb4ac534ae5418ec82ceafdab39352e62f8e03a5dd2e7ad4f2c6621e79922d6f25e175d664aebc8e73546b4a3026b46759df52facb319134d3a9b5e0c6c06bc582b20e10bfa25ab1b7f55084c0d6c259b6cb1885e25844246ed423c0a981651b18e97606a4def925e1fc3bcc96726af197db41a68b71fd5c5794be5832666781df5e88bb2ad3006fb65d0533644735332296cdb241fb663ef73f7d184fa9728222ed89a644f8e6cb0cc28ccb63419d776f601491a1c354b0e7fb3ff1a2c5a46749777313f977e9beeed7a2751d41cbdf7de061fdb084f9b06d97669db606189f7832c6d1733074ada79d7075e1d496f6581eaba21f629c0d08bf69ae4e44fda0583ef0f23009a9ff6973df75d5d7dd42ccce295fe107c921b5db856f380e97ce15c78f27e48f310afaf3b7a7e3e913aab95ef6f96ef794060d0009df77dbbff072dddc471c2a28174725eeedcd6548490577558ee67f79f207773696df0c7fb11203a4b6834ba7b107852aa845455be7216b9a82e274604625191b610a44d86f8507729bdf09f1ae05738ca0a5927997eb7a9c64aa798afce3697b28eff2631ebf2d75ccd883928c5ccfe442212ca42442803569319c92d6ccd73c9d1b3e5e59ee9019af57037b2741f3388a4d6ccc13605e828cda53cc0d881a9dc5e3fd9f3972d4c3359c31d14cfbf4085bfeb84d96662ee28749eb9553c08f2e3b7271beb342a23eeb3ffdaf0f157d75b3a9f45e22d9ef13bfada090936af31fde0168c0bfd6a1265246782e7e971700c324ac3a5dc1338ff69484e1eb2a1682d89b6ea7703ca09aa0e5fb9298e0615f899f76bf3cc41374d797b31ee944d09283f94c76fab854c4557ea7c69ab518c24db1b37343da53ff4556e3e3ce64edea08bdb0178f88cc1e663639033000ce03b1944ca5b249e43e997f6ac2fa60cc1ee4c2dd3f0aca91770b300a11a0c4e8cf69128461b3fad8e81d49968b8dbf9a738769d306f3ce01b02dc983696179874f199c3b1952a36a6879e49e714a8c42bb81d6a1f7ec32994c7e93c64a2133ec5d7938c0f18942dc54e1537e54291f1109d8417bb2f7c36ce7c19a9fa2fbd3a44fb96ed3141697b4c7f74ab79de9a9bfb17e7693b9cd1d6c559160c45e9a47656522d73c2ff4d9ac658b5175b6fbb6eb50992c176ec18787e1f3efebdd3ffb922e2d8ae5c6797583c738575af67135541c9100b423c0b6c8ded338d7c29d3cbce2716300407c559f1bce6de1bf8fae779d60b52a5fb12c9fb007e7ab23a8518a4125673428e14b4b78c67c49aeea9437018aca36588245b0eb7273925f2cceaab6f7c72cccc845378e86677a08a5d718bfb05ae781d54040af11c3e287d824c34bc7e0647c6dacfa91ff41898fcadd550913a085b073b2706ba45e8c9550254d3862e2e7c93eea54455f18942d9cc781f591f8739055ea88e4cff78ccceb764792a18703373dff0107cf80024b03be54637989d2b6055ca42ecf14dbcafa5c8707b4e50dcbacdf1a53353d8147874ecc14d1afaf7a6d3a4cd2e55933d1b7a737c514cbd0f7de431fe422ed2976918afb8ce3b69ab5dfa1c45335df7c003f73403dc86d4b7111ce76d04bd7b70801e3e729d8850ac6aae6a662e248d30fb5f726998a200864a1991a5516a96b6f1dee21f7b826b87b4d3c8f16181bac89e6f73dd3d9aaddb83f112db831a7855cf26bf5fa7aa67a0d40197c38dcf7d96ed6df87ca3ac84058b94709c38ada8b1b1c0d76cca3c98fb888d60860a193efa8fbb5306ed636a839f92fbd3f69aa40c69257262244fcb6e9f43cf98704ff0434e0c1a94c33d3e6a2d9d2ff477306d893a74b53aca7b0733c4401f4dbf38382a34dca9893f9d4f87ba5d19f733df72a8d43dd5f97e4a19a75c74d52d00ef12957d8da6940764348327a05874285861954c3e3ce5e3edae1b1655d4a54d37d3916d83c90856984dd97eb1daf29e51fd2db3d957df2a08dc814cec798e4ff10dc117cbe5fa450dab0c6912dfe9936722d8937c9a4b5999157477607d9e1605367c48fa76bff39bfeeac5996768d62d727d7da86d8327e455acf6c4eec3e2804b13ed2b3eb463f79581457eac1a47b2aca47a1ac916b4299ada3ad525fbf2b216292dd8b53225f72aa5d96e0f192463efd8036e0ee954746a279b9cbaadd7ed617c89d6ace3144fcbc26e6e9d5407b43f520f5c124480b7ffe5be9c1c9e57a18ed21a6bf4a5c695f7c35a3ca26e2068939d38d73366d26bb9af433450ece73b6b6e5201aa797ea1d973cf781c5715dbfd05c0740eda9abbe04a7da24d28ad7f6ba11965ebd4a6b766f42a9662f4be4f3a4dc01dd08de5551099ab6f6c640134995db8f91a488a92ad0357e4aba692526d6091d4593e2f542f1fe3d4656805f874a15b8d1f93fbf59004e3795afb721aef37eeaaf7e2ef9e97bbd0f23ad71adf1e26f2a7645323ae9615fef65a4a5bb74669fb8d961a038b2ac7920dadb79797b8c029f7e5cf165cdf4a47a0638779b1e619143e185feabd224324f6c0aff58f8ad59decc67a62dadf8035e16ccbc12103bde9048c276577cd592b4aaa11783423e7cb004220f103809d9c2082e928d56ff3444f8d65a5ab04b0ef477803b86196468223a3761650595d5177820dd1a459792bd2558b5caab3a577e521df1b84ca36cc306e2965af3d360d60247cc54fc832353e8d06d658f9eed22236dcdb1bfc4f2be197ef6fb0919ab178388732dfe98aa14152e1a83cb78d4bd1f8cb088be446e3d2e91048db85949954383743e7a8011b3d643b0e87f9a9b95c0446591a21914b5b63e746b7adb7ae10b179a4ab957e0e1c79921d5bb903d6e5910f49f93016d97a53bf2ea011721dd10895a8e370336cba48c87aaf31a4e469a66d6a76a68955a824f3cb6b1fe396a0e2043a9f655e5300437fa22b30c6eb2d20990df84a1e91b3dd179becce6cc47beb2abf571cc1ec3f909166bfa5c82f90c97fb1ef5c845bf8b8f735fa74bcb4c955ee25c81e576dbb50b21f62e868c692c5d7307a46dff3f1dd020fe1616478a45f9b0d07663c0eccf43b130c08767710e58edf749aaf6ac6704b2840ca0de4cd72d97c74114718f045e24a7ff36f6cd1191a82bbb10a9a6465cf4b1a0a24293e168330cc18b1b1599385d935ef928b2bba4ad1e61967e54085cb86bd0b2f2328238438b6e4f6b9b7b73ccc66cbc76f19f75182d7dc41ca836f1d8e284db1f8a70cde0c143b085bb571ad84bbeea83bb5b29643267ac8499f9729025f69eb19ce0e97f4aedd486b20c9fc61d896c257ea6bcee3f848451a94a139ac3159f206c331abb3515e3928b5a31df7fa0b0d7fbc6a645a3f536d708bc5a69ae68fa31f5a170bb4dc908b656f1c026d848b2052fd5c0c084fe43799796cce3a0478ccd91e036c1cc334372dd9dc653e1b0546382577333820c08682f16ee6a45f196ed1cb5c0bf93d8e65afe1a91735847a333a206edd431c3729a0d09f91dece8e244dd0ce1ae228a53c72e4ac923938a5be829bd7deca3effd864bc5b208fb0b8e0cd6956f07ede1c37a5ef6962d3e7ec4eab493b174d212a4ac1ada4a96d647586b86df26c2d580845b4eed0545a4b88b743aceaf8003874ce9f10a2e137c465961b9c2d131fbafdeff4f10f1f7c1dd2d26117ca66d64d582ee3af96fdc15c60b0d9e46741369c6959c65e8e773d06378bac8025e18efd8d667eb38369d7f2f9bb6ccb24f323a410c1f95e77293641e234df828c0c61228ae107a4f882be36165bdfb1f9fd0ce2aa57bfd87a2b28382a7ebe3a6273631b204a9d63a60cb95fdd34a0da0141aa5485b99a1b8ac8309d840ef8f7a4e44029543c8d7da3a19a02a8e72dbd4661f609848706443ac19ec2106bcebe96cf1ba0515b75c37ea61585c01f89f2d9f6a7ca5ee8269ec055a6efc0bae23196e70f0fff33af585d918673b6e9b98d45e3b01a017759c93beed5613cb15e31fb1797815f7973574ee0e98204dc118fe3fd26a4fb998c05bcd4aecc7c83a72852180ae03b5d5d86028c71aebba6acd57000d9c8e6e76dc96777c292fb8796054ee4265663bcc8a0818f9acf4061ba9c6011ed0b910a2cf268fe9a774f57c1635eefa59575679c273e4cbbc8417ac5a80bb158079b077f03375a39fd21e1dc28481b627e912dfc384d1d27e70a4eb2040084db06f9897906058e4b01b36131ca3d42807255512d27a5a5e772bbae3377274ae304e0bf80ac2e2f9e0138b02bf52464e4a7e6a2f29e07d1243f0dc00e47c3289018c5a68846296a4fac0b13f799735ed559c66fc109a38978dc6f6f03b6e6ea6c66db477e6a4b2452ad00afd531be2299ac21b702339f9a0ee879f0f8263aa7916b8420b8c23e45d18c662b917d6e4b8984cac65b6b4df0ad61e40bc40dce2a534b372c0439a195eb762a650214b8a0f007aef8a90a61d3b4ddc4fbf74182a6fd443c9b9fa2c9beeed43a45dfaa728945ff58fcd7b5b24fc4bc222e798549e064f05070472fb2a91345afd425ee01fff9c65464124fa9e5cf76392b351c8913c8425c70e9e93186f48c8c4ce2837f03102480762984a5516ecaf6c62e69dc1a9d9f83ef280fc2f7b6602976f60c5acf327feaa8c7241ed5c1964e9d43285a5cde6db33a33cc5330026c082376748e9c6fd626e13cdbed95628050e1ed1888137a2ad6b3886eba34e213798f01d81e40a92eaaf9f0838077fa44f54bfb39d0e011b792db30534cc477927d7b7917d839f4301342a43c10ca3a44c0f8994152d128d5386f1ba76d27ae0d7c6b3fa41b974a0431d7a30a8cdfd72fd363f33a2a897b85a6a7cf867805b9fbc0c19a8c6c27c94331b412b083011a10c64d36b2c761e1219383f974f826c5f36e29002a7de7e0e61336ff3c4036cca1c6d2990626fe1086b42fb57b21503d249d098f913ede6d62326f1f31eb10359657280ff8596a9337359be5594b2f858be56c1f16dd1c0b90229c7817367cccd847c6021f7d20d68595ffa1058051d0f8d788dee14786e6c3dba85d3d296a3a9baafba873c1bba5fce5aacbdaf9c1fd582267aa9c8aa7167a381a2ab07794037219118a86a4e52fa3828b3559eb526e267ffe81aa4479d5ffe64b1e207a10c368417ec88ffb19bced9a245468bd8f1f73ef2b097353ed064f41e18f66cf495a6c6820a1729b796e519dfc4ab21e2b488b05802f6d3c45e6ab5a223dae614dbe6d38b1330609dfdb376ad1543cf94b1108ee9a7006bd66c4cf3050cf91b3a5af775fcdc03ce1a9147a24ead165c734a769e99d8a9754c482af60cb7fa6e9d5c29f8b63da43d81b6eaee42d7cc5a0cd366b1d42d022d644a9ce93a243f158b186cba452c75e7551ef5ccfa061984af0b1199d9ed9ca4a1d3dedc9df72a6950f2a7dc100a83e2deba23e703a5ee8c7c83e7a52cd9a665ba9ecf6690d8eaf376b33fd994df0c4c0f045ab682947210f3017fab330b54681dac35f61d2d7936c7dccbe5b50bcae33ee6b3f262cca29f0a7c57b98d626a0e5411401087051a098637b341cebd7c170cdfc981d5f1b33e6ee9a6bf29d92b4cacba802d8f0b7543ab271bf0a833e134bb080d094a13d31205aff079603d8bb63efe674f098716def4be60e21bd642139dc19883dbf8f1b6ae40f77bf90b6a12440811c8c91f077c63bf9a1c673310b1ecfa56234e6f29722b8215d24e95e6ffd35a3e911467ea6191f73699c45e57de3160ddfe707acab959cb73380950fad8a723f4aff2f0a60475bccd5784552df59d595b11f35d714ca20a01953bb76a6c2c49f127783aed3bfe9069c2389528694f7d5e15d7c1369db6c2c4d3aae27efe43b492a24a564d355bc6dc3c74326b008e0b696b2ab66b8f1e9f4591a39a1f506992d8afcef22b6fbae91ef314063aa98216150dc130e64f5983cd9bb11a8dd5c92715de0f04e646c2a95436e949b1a7540f75d573229785c71fd557e7b863b6604700e6d918b7ee1337234c5c986d91fc38e2735896ee8d75514cc0b13759afd887da80509a1d7cf2c950a59744c765c135f9047749b7ee91f7d73349305500c686431bf95a6f3fdbd92921c832d9374a4a6fe749369ee064bdf383a414df7c2e0fad8484eab9bf38db227400c92d7de79e35c1cb5979d54d9c4e03f14ae43ce77f9611fa9138b0c98cfd3fe89432a70cb7cbd55f975bddad02194bd8b9f33fc0e4cd2101e0ef98d2f72fa882e6c4865fd65813ed069cafe675981bf2188006167fc0bc7a57e48abc0833613e636f8207faaf4817d6a2360d4d5f38916dc436e26ba995a777a5a8d505a000f8c97d3b7d506f12df1331b8a8609e615dc4b44068f36af8207f30ad9b919c2f6fb478a4f781177755095346250fb10e1ba2909b85c09bd554f4bacc200c7e6253388fe53f0ff41e8092df6857278a5e5827163a9b181b55bc402bfe5270a8a49490a0323de5d861c4a0652df1f4973228649cc9bb6a6bf4f38793e51a3f7c62ed1938ba4dad47a20f5a1ef2db2608f187aed1381014ca3d0b9d0099903f6a3b3b6a0d6daea83ffedfc0f3e4a114aa5c425e17e157d4ada849c83e3f78ce0c383bd2c510592a7afe29aae86e26a2e30c5ad3e2ac393e37e59bc8b8e5339a189d9a85c6cf426a834e358dd84abe28128c4be","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
