<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"beee9dfebe7a9102e4a6a743671e3a6e976be6d9d405926cc78fc469164b8b9c59be1a3983a8f9eace4fb0b84141ffbc9f2dffa4b79e3f3594f578edcf258a1226d7477d3be710735369577967447370747648745b036e6cd3a3f1e73a63b0a2007d203ce307db732fff91276e238e916c2e16deb714491f9966efc2a6751166d345fc5a5059e580d827b46a6a23f140e0c6a1d228a27996ab4857bf38f52329bdc828b10eeb7f992c3ee3c2e4495b9ec3bbfe1a055bb6cf62642df4bbdfd9ae0d7769ca775ee6a13c75d1ccf74b0a5afd541d95736861ac538913a66032af029762fe9760d2bfe5e0c47a013ed74876c416fee7348c1c2b7e86deab78100b4cb1675405e469ad28d95091fe207bacb98931d6db1c1e95fba5673c8a8d66985f088a3863e68d1b86d0a423cbbc6e2476f7d01ff047c1fdc897be1db796293c3826d7b25ba26f439e8570eb0d4fa33b3038dbef39f41620a1ae0a391b7ee4aa4c05cd546d710140c793124302d3106ccd732757395df49327cb9d980be59d56954db4183f91a77ef46bdef640ac53f29cfae386502e4f107217cd65f58cddb4114a9e5759d3d39bbd78e18ede5b7831021c1ef2a5376ddedd0b9b25b49a9121c24c38851e163bca085f29290b3841d3062056d1049db6ed92a73a60d1fe11dfabc00034cd31690c7a26c1f4a994dee61fa2bfd6ba812e3aedd88b7ca6486e703cdedd44bf2505dd397e5754370308251943a0b1978f3f6c8645567b8a37fafd1bfffd3ab7c9624708ec4be3b698d5e2e75e16056e675a4f564d7e5290481961ade273854cc10c1315db77853d6be7048bb098f106ca57fbfd8b2f9f9cac3f2a83c222539ea556ad5b00bd46409802c3a59351a4b2724bc772ef3bebef2e9cd70c156e09c2c14590e2474ecf952e8e4a6740e394528ba1c47924957a4f8bdbcc26c0b910754997e22d18aa9e9ddaa584aa39e01c6b89d739c6ae8c41c672b7e7c2dcea01dd809f4ce476a6dde71f30b1d3c9cd29943e0b0e5d4dce41e463a6c43f6e40abd27122c19938dc40e68213696e2c3d6ebbe8898481cb24514f312ab6d9e43a3e592dd3e284cf1440009237b66d24fdabd36675e1949d6ba2dfaa59d66d007d41c0fef978d7ddd5400921ca783a0556bda1f5bf9ded2c33fc98343c3c1b00c9ae912b22318ca7f818f517d697c3581e9e5d7a7b6d25d77eec797d01cc1ddb8a2f5dc15293e34b724e796a412e3ff4af509ebc5acd391fe5458ee6eb59f28f33122c7d6f59f59f70a0dd9d0f60b1265ca29541f537a95851b4d23559c5cb3f7b6b00d85f48c85925238461e117f365b02a1e50349b4f5f48c865d96a8c93c18ad3b6e7846990385a1e995ef88c48841b26e6843c2c1d765bc9ad909b6173fe85721e93a91ae61d2c66395e31bb7e71c5745f9cce579556dd09e4c41d8d73da68ba5a9da76935c4f55d449b917d12d364530d94307734e6f4496b77334a3a40236ceef090b9560bcd16a7238b5fac629734f4372bbbbd361f1582121327dde228b63045d77491ebd1c9bb63d04942ce125ce24d1dfb82cc43bdbd71578dc9657a68ddec7be4c183059dea19a9a928c55aa2c24ec1ea216733a80205caa96b85e08d5588b57cba791b3539d5153e0c3422cb5b0529e7edfce57eb6b8166723d839f39453259eaafa65e27e9e7b7b3724c567afe3a2c5c031782da03a7d4e79e923202b32239de66a87f90b734031680b3753cbf1ccaeac3f5cba297683e63461d59e32b6e42558391ca41be79c1059a4014209425867953fa6455e5b34774939c0a26eba9d4072107568d29f4c7cf0b00aadbb7e28591d7627b8c4eae0aea91d0ce822fcc3c0e5110192465fc066f8b49d13160d5d4ab2af3101e1a34c291554a5da7ba0e7c12d159d1ce742cdcdd3373964d43087154d3854393fcbe8db06572f5b750f7e136d51bb808f934b82baad3a20f12467300c6708bfd0f71be1c423b7010ba89c964603f5d4c9f9c4ef9ed97ce6a12f3c6695bb307579f898e13b00a9a11fa498e9fb93dbbfb5b39079ad034c2c169ca39f2a7ee4b76617bbc4d71481d1354a44b443ed1ec482a65ff7601ed6b3642f221e10b9b76db4964455a9f221238d7650128b3901ddcf6107bb856010557e6790c826c8b4a02815f8b662eae570f3e1323f5148fca9fb3aa14299a85675ed5f477936a63c8dc40fd6220d19b1351d8fa8cdc8fdd495365cf0411e514bef559ae1c590489e467c850875274ca61f23b7337ce43c56fac735e8666396c7b6ad232f9a4079f76d30e24d973576265275a7f5c7f868c9c3df28d0974794e87f888710cc8d7bbbf2fe6c6ad7368f4b1677d60061d41413335da3c9610a845eb95fe05661dd8afd484c17a27d6fab12a18d9db3fd4a9312c4d45d97f1842eb562ecb8adf16e0b9ab6ad8e5130375271ad0a402eeded7e7c431446fbefaf75fda3650f02d6c7ff54db34cc00909a801c7da338af4904819f80b27731f92a8b753d577981e10a2d8ef797833bdc7908d696a28231661315da5f2bb8940b99d39f3b6b35a8bc03938b9a1e5435a035f652b9489a7f80162bfbf10e55a1a8793057a3d496bbcf599e24c53e1068249f294ceaf156ac09d56fb822d13cceea9c093e479567f8722f26fe6ab0b964296a007b7a967f6b3f8af548d9883977ea6cbeeb066fa38b84fe5e239e148a17075a46b9fc501de2aed1181753337cb6556aed85461a91a590ef10102f9b9be90c3219d07893e045893c9a30d68b95c8d491a05299be893de6853c8e8bc4fb7687c58fde8be311e7eb878614d96752a16d426db2d255b8fcb65b13203598904e3ac5e47cf884310f9753bc79ef0b460eb410f5b0867a5b35caea0b189eddb626d3efda54be30a66b5ff3033d533439057ff4060f8e3cff4108658a6c3a7bb6d8c3e343958540dc8e1ef0c094515f3d97147d5f0ca9f66e1e43461222c73db1c94512c4c02c108d440d85ae9d9459ab2f007590d33f780a0c10e720b4082186cdb4431ca3f53ccb7b72e6b2603959a0c42bf5151ae3f7e6dd8dffa90f563dc246b75426792211306488ef3ef8bed795dbafd27d6048e248361d10b7d4b180ccbbb34d30c67e0352dd2362cf6ce840b57f65f2d9008036271d7b1b1ad3e76b0efc2a8733defd305efa76c1196179f5352d66dd2e2d8a7b62f6f53cad54b60f9b58b02b429b5aaea9c51164cc5254b6737a5deae65ad667227e8bfa136b543119f3d6b65ab5e5589044c73c1f435ed3b06eaa37b5963b61fe059dabc5258ca067766de40d7e6185ac719e58c8b899b727ffe204626298bfea8799d9da68c6699b9211db7891a077a02562b145bf7191eb4c382584a7c9ada14956374634ba12e98e18cd151d877efb8223e92ab74c0c950a9f563df93ba6956064ac10a6759ac454edad1cbe8b0a464069a79089a593283f38255e59a683578613b4acaf379db6d6983db7e5b28cc4c9f5870277e57c95fa9ff20e7ffb417ecc65e6fde615370ab08354656de22dbc9e5679b0eab4181c37447ae4208e64e40944ef5f6dacfd8242bbd1681d5a064477966fefd812256ec070042863b6f52f4ec7d39ead7014a240352521fb495a5f62e187f8bf4e1a37e2e59f50bada25888f41dc57e808fd32b4c90d85763b243965527fa624126c027854025021c8d319f85105d738d754fd337b549463aff844ce29a55a506a7bb7e75c710e21860f197d333073aedc5ce234fda9c0fef25aa5375b0a3c5d033c06bdaa11dee54e05c4dd5efac2e6f8d4311aa36ea5f0a15e0ebea69f2bf3e8c3f3271b5563ee2642347a64022e2a4e39b20bfc23a348e0ba28933216f300f54b72b763a5a1ee920e5e9757605522069785fda27ef0753d36948bcf5047259326d6863be5df6332ef9d981f8cea750c6b8584e59045f706fcc2159d82bb481d127c0eaf18a9206a0a9ad44caad9f5f37dd81ca32333c07bcde05faf57ef9b6972b465597510521672a1998ae34e826d975b0ac4ace6868764ad9c428951c8c9e8f95e36f0520fd69cca22128a4124fc3169eddb3b43bff7c6e2f085a2648504920c76def5da1c19772c93010cf6819897b481c130dcc6b2a4e216273be6a84ee1a158b199bf5f080326f38218e027177cba9395ef4668cb1f35e5b22cb2aebf8dff6750cb796d5e1b6546cd34141c1ff67b41d65cc3c0067c5caf3519888fd24b6e775dafb0b51436bbc2b3cd8394ec6d0f41e22a92e5e0b67c17ce16bbc0bb8ad8b1b06dbbbd945aa5dcd00b37af2d55b88d201f861f0bd8efc98c45b3c4566b796d12362966e4d0cf6e9d55f9b0e10a7c024546e24e059550a8612eb2404c9760581b8be36e747564284b5ed7c1beb6309621969fff3eb8ac9b4ca2b11bb2ec0ad50b44af749c43f9c1eb61c780d6b6d4ba989a9df99b6979f44081fb868fea75ed5f58615959ed8f945f529b58ea3a6353781c7f35d85b217a104df53c16423924d6a28c752a011b335d223e54eea9a754cd671ce69a04a3af15cd00fec6e386eea6d7812698505509d0a4306c987afdbab297aae73598d542fdcf9b61d91e92564dc9f5e994c922a24f984189f1bcefafd24369768e896a24973573a84e0e16f03f309b86179b8ea330a599a13c7847f87f2f87f162d8dab4a3f33a1673676cef8c3da17b7341432f14ef51a078df0982706c58561c65af4029ad9c09706a64018c8500d1a0468d3ac0589d0e1e99fe6bc91b7bb06a437a3be15df63a06902f067b15dc73188f9ffe553dffda3c8502e87206b1423bd5a657bc323aa949586ef7819ddd86289b4092ced3e7466d13177f11817517f965fdb9a1e2cb457598c95e9360224311519fecff8cb49b2a52fab259e1ccf13935c21d96eeb92e6823cee8d9136d10404d84018465ef3ef2c2d22d1a01fbaf22115759997f4883613327938501ccf9f62f4c210e981c7f37b0fcd28be563fda60a2be8e270114dc84dca2e675bdd1998f0b9c68fd66f9e3fb217011a10672d6b1261f44f8a18a688e182d63476653b65000f433ca44b0d409eaccd090aba5c85ff7138733005e8b8b493fe67ddaa33c34ce255147af2c724880998d833170ce1b83bf3c54bfe835cdd7973769f76f436d7ecfd4e9f25f46b8dd6db997b8c431f8bdef9e620d8b08a27eb914da1f1616abb82defef1cf73d4c0d36545e25373fb266a4e067185b99525e7e6ae092c435c016358df59c6f26598ae4ff483112e25099ada3878b915293ebdbb77d315c4d167e0e6f44369d5613c0ce0ea6876bdb4ec397c171bf77f9a5cfe3348baec48dc9aeb43ed50660ecb6a17455a03eb87bff28f85542bca4576d7c0928e48f583a3f209f9a8af5c8cf43f2be224177d6478a90f0522e636abc2e93de9df0860a82474c25518233b83bac71d9f7c4ca1160592c6a7b9befa9ebafa905232ca0ff7d6df85a752f7e7c1648d2f0de8e4da1c70cc190627e0989a3457b8ce21c0b89b30b258b11bd1d7ce7aec519a1bc65d84efc1f9caab0cf08bb2f6c777bfc0188b678d2167455a378d5e6362a08bc00535cb62427a0bff7699629358e32a8badb86537a6066a337ebc8c00c74cd85fa8521be040a4d3cef6b283d22a199a714133131acbf25a606bbe229569ecf95cc6fabdcf9a605860c394e1ce15634df180cf277be179fb52213eb5aabf188cc400ff400dbccb33db9d93e9e950e93922321eb149e534fb8b8aa59758332bafa2d237fc6875420d3f5383a1c4fc421d633589c4599303894275a6654e5d80600708b0acd7894ec17a69aa20353d86386b90c515e40cc0e00edf9b74ccd25e4a0bd4dd447233c7f1993f552c946697efcfa04bc89a0697bad8748ef14b4e8e528c8872bfa3e998adf5c3b5e55440829861e53ba17f3bdc43fb797cd2c152046de373883f3a315d3378668fd95bbf2e00650080bd3bf9b9806c0b6474df352d9698881546c7df9e89bc485afba8bdf4e5e0d8785d3ea18e1aa3f7fc51191967bc3569588bedb811f1f3a0f97da014ade9964c84c4d872422ad36667a81b38024cf5b681a41d5bd36d176dbdd193e7d62c0a5ccb257a5a40d60ee26acbff39d320fe82917af86a9715eef79a8fcf4cf390fa3ca7eea7fef4035b222aaf776e429a8019537472059962c876c373159545957bf9dd354a95c9f820cbb19bcfcd8a58f31226e94323abbefec174c65c490906ee8b9eb385314656332c0153f77abac78f0eebf211a62f94ed5571e1c69bf26e9e09e2fce6308c53cf47c49ca736fcf496ea5ab48150b378b11b32f70d2d87960620c70c1e99e6d8f27270656a618d744f411515a09689ec173acde3b95d465462176d14d2fe85289b199840b6a382f0fd15bd12882b91333b1db2c522f1f21dc9831f8315d502baa135c4afe491cfca3e3fed84cbe6183edf8a4aad23cd0b4da6d6c7f670ac6d2bd8e605eacde7b3bd35183ff80471f25c2ae56d72467e8fa82eb1b89015be37b3a6e210baf5f9de810c26f8d384ed478adb1714f17ac3242e09d5c0cbf26e2e4a638fd35f2e29f133598fc9e9f103cb6177bfe90840d0a790d2a179a6383dcceaf0956f65826ad28b3351b30479eeae33992580b9c9bf0885668066bf5b8a41b24534430380fd460cdde3c4135bc368a28ad1451633beacae2704d095fad2aa6b0a815aa08c56d88c7eeddcaf991a420fbff05bb22d43f70421f6eb7614aba9319c8e47169b19af664a8d05911328abc04094501cdcf21b579f8a4b9c655b39fb8500a1fa4f48d849f57405f2116930c56b782d7c6a8abbff62cc881c11faee7de15fb246debf4c9f224c653cd391f25f3f4a36a16ae8bbb2c3dc54375df250a4fb5d98728467819a9404038dcd2a64aaf3b7512ee3afe6b243b3fdf098f6349eece03f288f037d80b83db138cf5db5d90b8fe1d23d4513753f0f410cdbc7d1e1e398cbe14886f3c387a03ed4a238000d5d6497dba03f12da35aa2552ce5c925ef35a1be842d6601704141659ae9dd53e8d52818450287a8d2cfc70de312a7725552b40557bd746378df98a179443c92f6092ba3723c631e815d4d6c167117eb6ad9a2400baa59ae60cb90b49ad13346cf07ee9e807dde5b240b7d913aea6171466e6ea2ea059ee04c452f4b03a0481532aa54fea51f53b6358ea99cb626a2a2c2d45d4a7565bffa72d0715d1d88ebe107792d5f2a50d2d7000ca9b76f827b36b8e0d62fc0c7c414acb2e664c41014b5d699844c128d2259bb66cd1458ae729536759814fd2bb00656cf569da5f8800b7da08c4d3a6069d1dbf230c65809bff31350f1f8c0320743873e83c05a078ea286f805a3f676c22479dfbb4406a34e2906ae99785b3b8eb1278bb4b813c27b203b17987fec45f861d8e570e58c35267f1b723081259117815e5a265daa06b47404c4f75c8efcdd3dc0ca832bb5561d05ec1a65b0f4047660a8092c85fab4ddcd913f706950e94055c82c1d7e16c705bfccb35a2483087d7f9326dd35ec028fbb4b017f31afc4bafd464387671b1becc9e7c509d7931b234ec4a21520fd77adfe36afcd9ab7862fa806d007af8635244ad41c5be6c457312fc56b22c64490cce2fed7ec17ff8ffa7a62e656b4df812e6b620509a370f4214b2d34fc3ddf20cb58b420b7b09b705912431234817e4736dfe19a47fe4ae309333e06b2ac14a9faa48ff3c1f2399fb569a5317236268a35f0240c91548f593a8de3dd66589a01c654b47e7e2292a5fe169ca45aaee829fecc8b9c99b65dcb3abf5ba360108dd4e2bd6155117f0eea57ce861c45f5e7936d8f0eb22c2988808b4128d52c30d4a18b513e1486bee795f02a29c076a6d934785e39cb133f0624af64ae51a4de8ff2e93dbf792899bc0e7f8b99fc83a0cc92f7d8fd397d8abc00a27f627b05d1e2571fbe692b9ed612ca03096142fe0a154ad09ccb340563a72673f2df4b356cab926f120c22c9ab4fb9d9b22971f43cb88e356c5defc8dad2e619301458af4ab024d12622b8cf52c4aa77b966da38f9868de71d3e0b6c18359a8bdc142ee4dd91dac2e3b5dcca7cfc0ac59d6e68fd7483878a1136ac57c43137a0cad6dce11ca414722460b610bf3a57203642bb296b2818bd64e3af8e87ee2bbf58903d2b3d9925216291b1f368a2b9c2c134ca2fba7efa4b96006068dbd3ea0346a8a5cd588d6b65d8823ae55d3d0ebd8a44adbc396c4092d87b6743ab3e893f5030340aae662f294b8fa07ba6153fa812f9c04422132420f2bfb815502f265c343a66187cd77da37a7b7021fe486137b73938bde771be66720bf592e4f668e8f555e4c7b98098e6e712083b70c702588bb945199f77ee801e6aac7ef0758ff54239934153618660249b598d8489f6d871ed625c2dc2d4a50038d1aceb519d693a7b7910d7870204a39e256c14d07343cdce9318c9857a799e5c77ea7951d069ad3076a8c233586b91a69f1cf2782eca80e04567a561ce4780dcd84b858c65463dffe146ccc0cd7e73ed1c7acb56e6e2ae5c36e3c3c35a0b2b6ef701e1fe18b24c19ea122f87d8f4ebe02f5915210d96228488941eb54fb9cc8ecfd2dd5b1048f718d4823031ee3373fe14a919882df97d216d4821d7c2c45fefafe3128a4886f2c2c0eb3a727baf5dc3b48728b38b02ba31de2a69c93e2d0f4a786a877ccc3477dafef67e35756c19a8c43eee2d87bab673e5115c03ba237179c4700e2f9fa41d4500342cf3cb402e6c423f5396d0ca61261bca8c2c295ddb0f91f166061816086b6531bfa8c6e96001b24adbbe8e3928d4676fb17ee68f04e0df1d82df4797195931f99bb943f693a149199da8fd18fac6ab0db438b6ce94b0fc4df4910232b15a029a2ab3e90bbd4ed5f1d7b7aeaef54031baa82bc669d6fadeaeb130db25e0a17e5d8f574e19b61bc99c451884eab0e14b21952b352139bb285dfb12f6358f1fe633c50172a903d0c6ce062967af8d09420ef4492807a4fef7d2419022ee8709bef5c0fa7184731f2594512f0ea4511724fe464006e2bc6b96ae970c5534f2f9b4022640104b00775090c0b665b798fc9cb04c5786304d315a08c3f4b5c0643fc0962d98ffeda6e30f6ea6e4909d75757c331b2f8e1426e5427136cb85a323f4c8f83226495a6335efd9235a12ffc99352938f11ee62fb71ed29ea09615f9330b47704030cb900114d6e905aab3d5ed47dda7d4ed7757745fd657125e3ab8589f2c16dbd8e217846b23d8d36033b56b60aeba470f414776ab22975653777ef57dc40dca25561a7289e9a9339695ed4f309ba669d061aefbc92ce5d00b8ba681cfdc121cba2aa2c4e5084ba11bbd3235edadc0d511869f18a4d5998180ce0b487aba9bbc1946cd8b3f429a0cf164b5e59545830b069e42863a7bab4dc7fb90f8df4a9915855e885fbf0b3b351a6b67668f6e2e24cc11325ea8fc099badff9f87c1cc4c99c9cfab6942a8ffc3de663fdb6f3441c4bd79944816296c6a9897a3eb5a02b36d8e7a825d6e6a61e4d2025a21a40ff38272e07b62b1f9a32e4eebd033f1b927c1e1a1205791ae8cf1d515329f9cfc5d60ee30f972ca36db8abaa5d8d0949f3b77a81a7cdf25dab53303f0dc688431a27df1c934d08894abcb41be6b3e404978acba02dd165e73b434aa9d4f29eafdcdae2b477a2c368111c7e1274152442c7a3911afe02292355214cb3378eb29cac6a98fa41d96c88955d8344741abb90fe9fd5ec36d65fd3b7517756cea0a699dfef2eeef809eddce00a9679ca047493912a7f3dc8d23b929e3a11fe986682f34e58faefbf0ae7e59c085cbd4cee3ffb33540d2c2f6f473937cec2dc4cd56994e01ca5f5628b5c25e75d7f1e8ba0630deed7b4919b97df8e54f2736364e32ad2953676c432839a513712d7d44b5104d9a0c47b159b7ae053b3946ccfcdcbcca3699bf12a2a119d9d580356dad4eeb50d223fad6b97c5fb07d21c718e00724a23b02d0e9f61bb6cec9f29948ee8b94cbcea6bf5431bb35394d7b16e78c5489a8f67caa14bd3bc707ca18531118ae12daef1f13f6c67815784f9990f647787cc0061571d37f1bb711cc648b84d1a9ded69d7067d926df0bdb0cb386b356fb91ec74a7e3f326852621ee2f46b3fd0b7d2eb7d88ce0b46c576df6ec0ec95ffbf6c9098cb741c95af8e12aecc7819a73eb7c92be8ff3656e2c6d1df21229bb75ba56fc1c74feb8a16e0fa6218084c7c2c44f15e9ae6443eb760bcff06073f92df7564138fb5cd486aa48ead6fd6fa0f8a534830a653774a7ba358c1ba6e80101cea7312a4e5dddbe976ebfe0e3b9f43536efacc9d1c2837e5fc3585d5c5bc68aa540cca3b144fe556d5d071ff0a077011af57d123bf12c01553dfcccd0e1139d232e65702afb7409610bd875d34a4e409633de9b9fa1b0ac9ceba102696bb11de067113291c96d908af8e350c1bcee5637364b073a3984529a0be1578fee9c02108d14ebd4c198e6cde8fbf0da1e11665230e39ab6cde8364033e262fb3b52a0ac9161e71b19c11903376befad01ee86008b43f7cfd36f0b9114c9e88667ea8890cc17afbf523233b172461a7b7a1d6387a9d92a422bb4798404fcd7b942871443b4571b3b0f8d5eda82513e0eb602f1026845783aed47510467a2c29bb2584360301ad807b9df5492097175d09bb1196c73ce4ffbf6eaa4e8e927b2d915c6a2146f864ae4ccde628be12204d8a68009db7f69b0467d9da20ccd5305a85484f2d7d1242cc82543f0c117ca338d97d2a55ab74c364fa19f7d81776d7dbd0420145e12930bfbcf279b83658e5a648876e14636eeeb8a72cb3aece571dfeac566645e39cbf2ce6f8f60c72119f18ed3d4412d82e1faeb5ad4dedaac0db0d3cf32dd08e633464e488241c8281f85ae63d62be677d567c242e3697c631aa5f8794810c38e37d3d84430f33a47c213349c7e9cbc9b5e46864f221f1dd2f463a53bed1037f1612a52140d578317e30e50421f36bf35f12de83c8d0181285c7fee2e161f2572e5386181a302bbc06a34b93097bdf0d6a258e53cf98b653a515d49a01755ffa96342c357fc1cea2a6bdcca7f58fdd16a3762c0668d67c5856ad55a01e2683a56f253d7826a4c72421319d2f1caa5fc850e137746bcdaa27ae083f24ce3b6ca2f4c259c67010efa5c9ca1a32c1889495ee947d3040bcec66bbf5746b510bae45392a1b8f921f34b1e5904db6b7a4ca1fc9df85704d0f2f8cf6646dd9f9fb7a7c45ab69e32809fb22cc4237dfade046af191db311ffb3ca8ef8aecce7c778a54f00c2e52bc76ec310960348495bc7c87180ebfe68bb3de4d6b2f1c8000bb3cee8cfe239ff2b090151fac8bd81a140d022ff99ff6607b4fd4d2a419d30363d6dad6d5ada6ef2a451312ac2c25367899afb4a508f8cc46904e6ca8a7d9d4468b310cb10c00f66546d4c89812b0d1add218c336320255ebe1e65a0444f590da43318fada7cc52bd9bc0422d896d4ba7a3c3facdc32fe059e71e616d177642c7a62dcd80a3e26a4ebe243d5080fb856605b5f87723c831a716efe5174c3cc35430c3b83740f9100177cea979a807ed0be999c5e1399559f96061dbfa3434b8aa626f8e8c328eb4dd41d06b76b8fe0536a05141520a77f652b13b5c04daa47b210ceaa75789ead487ad7b4232674307ba7822bf8ab78b4e29730c4fe4fb3e2096086e1145d9192b7a76ac4c274e4a1f7fa8978e600df0ce0affd1fc444e4428c53bd5f004ee426a3fbfe4628ebf9e871d098bb5e504dbf33bd54be009b7ad04fb4d111496d99a527b7fe0a8f090753239ef8e86efd00a9e5f5875ee1c256a0cdddf757a1c33e09d067fd214c1424bf069f3b3066c00079fba8f8e72c9ef6ff506612c791209163344648823c6db579b719398b0e6834b944eb4548c65b9fbaa60bec553bedfbeb0d51a641b4e9abbcb7408981e00a779896d08aea4701224ffc966bac176246d4bfcceae40eee82cf04159f9e283953ef657e64bc4727b446f462d4e4e012e68b134014fd952c44a18cda801da92a2d6cd42258d0c17182030a04e9a3d9d312be75b147e284df339559946bbe12feda4fac624eb2d714fbee9f8242a545c1521e7e5614ec629c654e0682cb154f8f4e6349157f44bce3ac93c612fca7e139a6c965af34a9835f5f5ba98f53a772f688b061c10c98d760e87fed87f190776cba8e3baa361ca6a64480b21eaf786","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
