<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c3f370cc354bc436140bfa64f33f4696a2ffd306d156fdb49cdc229d174f5745d27d6aa93847d433001249876a8c950ca08aa397b44b10e795155ec352b7f0b5497f79fe3bc454502f7ff7b6bfb92768b3b107ed7ee568f68fbc50c3d5ccfce22c36622c569faa693566f317acd5ead8cba521b068d3c1df13d2ebee0fc3aa5b52f256b43311df664f3a49f1f645dbf19516827a25ee8beb3831ab27fe5be613ac62cab144d46c245712bd7f6b80089f09ffdc104e3ba6202638af7cce82b5989192ccd24c773e3b882d93351ef611bc2e8c96eebe3578b32e140cb8b1553fdbc4a35487fe24e18283eeb755a642c4be368f28c3574b0036924ff261ff9aa71ba7e6e1c765fffc88faf2faa6c8ddd5e25b10c92cbf6769b3a8a6438faf752cba8bd480672eb0bb3e9bfa23bae959ddeb0ed8d9d7e069a53b987fd3e1d0bb7e9151f91c91029c2708807dd9395c4112674aa1b6c94f3490cda10c8553f03e217f63651f47802d4f2939e5a6468e19b5fa01237fbeb4dad372d16f33c68d07eae3999d3762bb970f6e176b6cb696733755f3970857dc8bda72c98e54dea03bef332f52fe3ce26408c9c5c7a72fa33698cf151d10ab7bd4171c2281f9e6cb037890796f842d2c7d32d679b6e15b71d3f91c0d885c45e95e505dd3df916dd2dbd86a00c7eb82e19510400106307a594487d81b343488a6a9fb83fcd4df6864933f694c502de2525529edcba9d38dcf924befaf3f62d0a7c3cb8fb768415daed9e6addf2952e2a8c3ee15d4fbd5fa83036c53845c4d43da375bd794b0599d1569d0a8fc2921255153e5ad39e8bdce6eb9a1d4f5697164fac569e3a7e25cf496bac79ce0b4de9f54fbb4f5a49439c0a0e1254a267f5e568194da8522f251ebd390039ead70336fd998149eb8cd425accbc54f8f822236d4d906962f57865616221bcfd3cfa832bcc895f05e1ef7710ac59625d14def4b63b2ec4358387396179831df2bbf3116d69dd39531435fa2aa5f6ebc667fca0568f1a2e4bbebe4732509ffac2c116f996af06f467411a2d9fc50272b57d601b92c68b33db6b0fcec079b13cba56f9c25fd09bffb09e985f933459e93ae5ecd1ca7a6c0229654c44f958939e2c06e4759b2f31e89f0470b6887c61376f3c1a29518e79bff31494d09c232bdab97eaad4cf2515047a751f10aa43889fc3fb78f683d95581544e45fcadc9b6284b7c0835efcd6a2c203caa08f4634eac8a11611329ec5498c6dd3905c5c343dbb8b6ec4e2614c886bd1b6b6a306b8c19a00383ff32c13e8aea86bfcbe347c5d9d201d8df3884afb0dab3c26e79eeb87f6afafabc7e9efa5a2fe7e0ba1f5c9d7838a64126c58059d119eeaf19f10d40abf22104778f06093927de455413fa1321ef1872df1ea65d4e62996393aefc3057ef3ce96d39e42f67de2dd822530c5953e86e938c91200ca244938dc9aa90001238d598151acfd4df33e1623f48c34970555ad99586b1b2f1dda39830def9a6dfc73f0bd476a05079ef2c123c265d820fbd7c9003cf7186af2c0a20bb4a758d336b41a034e09d045c22759cb5e23b0c733f468e4febe10c72d107d7b7d9b017060b4d1f3b8b19b080060d30bf6f7a0129fb832864735a1fdfbfeeb8abb51da651c093a64615378eaf060ac3f2afda7abc8c89f67dd655b4d7693313e49ae4b1a3e7a6b39c1f100127b4f4cefedfc0e483991ad2fded074be0782c8eac44e0e705c2e24e69dbd8f6f5ea32334a4579104c0d1b5e12bab7b1b944cef4765823f2202fa1cad539bb74e1e08466e9e4efad40d469c56d6efc4c6f59055fe07d87b9012cb5a9a425c1594f50a275c284013a4d4ce9ded6354deb24dca4ee5256e6b867e9b3bc05db6dca1fbfeb68af6f1efdcc7c49ab5d3b2ed0d0fe21ff155fa5e92fd36c00450adbc1a756fa8119165e9f2f0d1bf8900b6ea89e1ceedf81efa28325538a46ecc6ae5751c06c63cd8e1c99400d9ced91ac714ed05084e1ae8d033b892eb2f5bf4d6efe509f67d0e3259b4e78677675eb0d2b7227d63b6af07bebae3e6a8573a8d71518b177101d2eddd60eca4565a19e5d9a17ecea703566458ad81c908cd63a23696e3203d9ed0e7c64789e296a30b864fd7f368872b337d3e6a6c4e045e1d34dc47f749671d290ec6932ec118630c3130cbfffe391529973515b25a21c6307272c6abfb45376516a4fe50687348e2c334656e567c0c40c13b824eb9dd4033f9b4247a94db3d28d42f7bc2d724695cbca9eb6f6472c279eb5ebddc17c361e9583fabed3cf793be856d684494d87f3ec77f4b5ff00c686414bb6ca35191b9533dcea2f6ef17a569d5c818da4267c3f9b674f22a8bc5361674617eed03d96dbcdf2fb36ad71a588bee36026d862d7c34c5dcb8ae57bf1435459508e42dae8565df7a176643c098d9416db5f0c85b6d89349a0de7d3108b3dae659724680e19974d2bc0ed7dabbf8802d4dac483343f61162fc683b6e5799f93c28abcff818efdaf74f4793cf0d59f87e198238934a4421f24257317a64a1b4898e93975f898041156567ec9b6df36dfce8646fa05ab11ac1cedcaea0893df3fa385a73cdd7adb0a3d357fe9553566acb503fb91258e6c94b6b95fbd40bc26cb73d6066db5d6df6b5c10e772c277cc06e2d2d12c1f09c94f0aca44e4c98f7d02979f8730e40522371a4a9c1f2e25f6b062ebd2fa9cdd54bfadf39d6d12728bdd19d96d1e52e02804476315d0e54af5670a1f1662b0f281d5f52902df864f727a76f5d1eddb73e6cc3be0d8a5340766cc84efd3dd4a0b4066e9e898f689a5b1e81e5f8f249876b6c6ebfc46e2f91632af82482ba5995fd9126ec2e948b9641909eda923d639f06c1ba4f4b897b8be82fd0b653e76fa6203159fe10e9647a4282d2cd171be1a98363ba1d16b067f9dd9ff915e936f5ac4eba5dfdb522bcec3c8ce1709d277b4cf5bc06008203d0c35b2c06bb72f15b4f99498456d0285422ce35fe1ed4bc1a0f94a0d857980bbd4f2ce345e3eddc4be61c895a1a1fab23a9a80adebdb61aef720966781fca4177fdcdb409886081b178c501d1a6b9419015e7d00c5cc4161b5084fed6333676bfd0882b2c38b310fed9cf1ff66038a9b3933d2cd44b161f5d5c17defe4eb389302c889478f3bcc13a634203f5ddc9c800db7c0b8a881719a155794b0dfc167f101d6debde55c21d2db269d0551159a4fc9f1033bf5b30b9e2bba1e3f16af21757005b911ff695d3b7c4e4258259c224bb715e32ceb2698049aaec16345ce12941ba9632448bba2bd7a82438563dadb1e477a25ed4b45482e68583e9537f60d9a8ee9d2dc7e073fbdacfca8c56adbb5f22ad7e6dac5554e04a092249c95978a69741e80411dd0b42cb9f885d4b08cf469ceab8d0fd581c3f8103ce12696406942548b4caf5034b20948ad6bd6c08354d97c90109430a6c722f11d4d4ff923bb6ddfa48fabb8235f232582ec91d8ca98e84a8f9fd46f4917d78e3c6d5db0d1446c56961b1f2c726ca6ee4cdfe97718feb86f315887ce4db7c5d92f4658c56f0c6e65ffb59c1cacf91eca13ef0e980a6ec04eba5d8e4d4124bb106cea9c8ab3631367138f86a98f14cde393d55ab094cce19fbdb4f9d2de25f72af31420d4a34a987891645acfdcf62adbccb644b30dad065e1aec39c5ea298bc62de42914d3c1c782627f9e2b91a0618abb0d4c067b939d8aef1aeedbcc119daa605bf455f81a5b412466703631ca5dd9a849d75499f51309160dfb27463809684d922cab89c556ef883b9886857399dde1fcc2bfa0974a80fc43c8c0f27a08c05c25ae7a298d3947e54eaeb6c6913f05fab026c942f6d2cbe88f4dc8b35708bb5f37362d4adf331123041a2543b5656775f7bf7e9e7c1b846326c7ef8756404a3d7c99f8ddac24596b947072fae82f33bd36f649aaa77ddb2d307c8e811a176b60bc35e8c03644a9a676eb35881dc017b7e9f3263d0e6d34dc0f65e08277bf2d2002732e6d28a006fc965b98810f499b5a2772c5ca18945e36830433c8e4c771f62627ca91ec9bd8166f33abd9ddb5168577c6cf92a65a413c85d05fe67f2218f4658196186f79b6e08f6c03a14216bb1262f42df788c82a4f22856132acb32b2a60744493c61cffb571d4c46f1189f22b42e70fe38bacf46fe8464622e46b214f29b4810a844ebbac3b5b3db5c6e9d8b683eba84b86af1acd668e29b5968cccd033a1d8ac453ab9e4034a9fd05dcba2b8f14de3294ab73988f7d7031b0d7de162f5f3e8686262e62125be1c743438d414195300b42d222624107deedf80f5f9bed5cccca4be8b28453bfca9958ed02ec88459f05be6518b947d1b5228f5f1a0ac27deea4d8d9005e9cf691f88dc8fe5bb6d145cc5439c51cbe0aa75f5afb776f6a0c149066f85138b34ea42448a87d2cf5ea6d526793019b89146604f5695e087bbd446cd9fe8174dc862b1f45e6f527843848bfb5ef130d7268440f949ec4834699b64a6cf25a090f170a14824ecfd686f065fb8d0aeb277dbcd6ba1d7cd4ae2e3f28f3ef0310e84ef56de11f5b776ba0f0107ae4ea9c9f91d6167a88e522304d856c6af81fbc48b617bedd0807e22448cc42895bb68a12e7907354cf68fa90ea32c2939d93de21c14acb1320aacc28065d55e64ded93fcb5d90fbf04e5a008e4168fcbc3af97e1f7653f399d87a8f3e408643ce93427b8ac4e6d13d507a034dfb57e1c35e18039a1c67d04d9bd9f35d570503bea2489406c3ebf24bf314c085bb2a9996645aa6f1c602b828a95df36df98cc81376757a4d8fa98d6b405b2d83ebcc36a5a80275ace75d04cf20572eb0506efe1c411deffbcf7b8ec153d9407b96d1c866d33633c4a517202bde81800fa4984fd0807e8d42112fab6925259f63013c77bc947fc586ac00d2de9e83b674d8d48b39febca7772e8d316c179bbfa86fecd9e7c18ab98ddfb8890ac2b3811283762615a6aa4e02420215081f67916d1617b86591ebc7c1a9ed130e6856d3f0b41aadfbcd51b4347b105e1809bc8b1ae3a879b17d07f17202c333607cd12e3274df80f0587042671bca09fec823ba80fae98cfa08186f0a2bd8cf58be0466c479f113e1c44a736595dc10ad8b460d6c8158977f9c7866e4e1d434fac06923bd25c881a26309f6d1d9ec052c78296100a1d20cc6d643930daf1686ff2feedbdc6ed8fc7235a62392b207c78aa6996d2f623dae4210a81cd950c7fd451cfaeeb40f8ea2e312d9f8f90808282ba69a4e6b1927a0f14e29a0c14a338069e3d576b88c4617657f7867f0d8386ba84f5cebae489a6cca33d8c465a2578dcc8e3f368ff744da9e2b8f5b9a25779e44b0aec002eb5067fb3de3aec6790e03e84d3a407f7940fdf359292b628906df7a5b4e535a5e4346ce08afe39a4bc83601f6d3bce053a62952fbc20bf0dfda8c824d148f73547f5c73879d1821eed65002c619c95a8ae66e8b31cd2bd7457801a9455905522f73d32a13363673ae4ca10f0a5639f558ef3728444b4c9e6d19ad6f2e656eddc7e4d1aa5c103513787fdc6835fbdd1958861442a8841da8e6778e08085ef6b9bd2c132d257ad49c78aad9dd1c4609aba6e39d7b8bdeda11a662b46da12b8080549b1bb88d54d4aac06d90d1b587c602762ddc7542b0eb7d0a260eb44adfb39b52f0251cd9ce993840570c22229f05ff86ad9fa8a4a0e5b27d13f4754bda2cd7253167cfb7b043858be8a1b79683c3d7d9ac5ceedceca3218355d0fa414e48e44b58440aa1c43a43a1fd2694954b08e2e29a7cc74e2f7d31b43b86300877d848aa0106e3eacdb195c4123a87a09addc29862baf7782e68dfad3c4bc3a47b48bbda411df6acad5cf5ee7dcc5938ca3fb869eae0bf4b0876b7c2da3b87cf85388004e34cd0001dd81c52e749e17ef6466759b6d5132e3deff812c59e215de92281f4e11071c487971d46b28837fb0d25b953a4a42fa728d9b1cd3c9a466617a3311d4fcde76a0229d1efa403d4ea87e1f414736284526f3781b32876315b0eebed7116cc89ba9a372000e5011efddad381744850d84b3b194961a56454a5885c464b3f1c1c7abcc553c29a6ff123c252ca5d3dc87ede9c608a83bae8c90be727b072bd6c0b7258cd23c04cf01ff7f1bc103aebcfcd1ce0fa2601c8557859f8c6ec70cb6d0b7833c73eab345172b66e07a052b8925274f8fac5422167178a08aa39217e7ff4f119fe3d3501f6b9171676063f8a513739303240c7ef5cf232379bfbb6cc17ba38b086a0494d2c2c13600dbf175f1f268d1d5f33963dc6fab53f8483cd22cbbeaefd077423a14455f6a3acef33d4687b1c642ab342594e12de8af6c6356b4f93805686b053cf027008fec42e5c49d859fab67ade2556c0b94604af58f00bd421648e0387decb3f2b234f9a1554a460163e9f1c017f3e59e14380a9b4ad8efdc285239737593f0825597c240b5800c06176595d76512547239b819737607fe99fb1a5750b2781a054e3d644c0f8b2909f154dd6711f8fce9f949a286a1fe495bc2e906e9e8a6f10ec92d977807ed75049dae9c877e85ad6ebb05711f31f19e47a263f13bf0af4e92f549cf55c82ff077dccdad82d8fc93268f959d50dbab500a338917c5846b06c3abcab0afcf07fcfbad3d88f175db96cc26bd00c8643fc0ea38b849d9c1b09317aca4c37efe36a23d43429681f6b7e81f01093af790f4712fecab7ac8c6b96c6ca49377e7241338d4d033f3d6925cb3818bf6123e187b1fe0996ebae0ef7c896f05211d627834fafb89efc2380bc92a168cc48e6e8b055aaede3915d8dfd14ed2ce999edb992ea65522fd862cc3e049327a671434083f941ef557848f83e5162ca9755f122aac2172b4386e8c090383199568ebf6689c336483984777648c1144afc0315164482092e4752a1a2ee7015731d5864ca6ad3491f7e0b13ec45e319d65a6ea792ce13f035d9f7d9a63b84988dd9080f1f0ac68367462130c93e7ca34ab839a4ba4abfdf1266947c4ee27317ca8172b22bd84f9e59e6f022473f4b35d1b5cfade9b5723bdeff9e6a5610b3b4ad904871a094581d0f82774bc94c712095f07022a7c48cb9afdb81e85c48c3eac7ba9659970736efc3aa67ab0857d418c3c4dc3332553c3425e6fb741b28fe8444a1ba3be342c8813ab569fcdd60da8c8d6aedb101337207b980b62fcdd244c35d7bcf7caa4a95dad3f621451b60ea25d58cc45875fcc5a20e4c2237fe0795bf794919b3785f30d884ec2ee52d4fd670d3414c3b29dd39d68666f304f04dc25dd582117497a6231282e8fa7e8d0e091ef7c49f4bd1d1abb28ac7ede529c1994a9f0376a9444cbce0b9ac68248c9efccdafe98c1b4757ff1f051e51404bc19c3ce41500a8092c4e06fbae1f49a967a2f1bd3e9db64e95b6cde288bd93f1620847fd3510d2e9a6d27a21c0a9c1087425361977bb985cc351ce11650f3bf999559d5b63cb777721a18bd37e491fe57186213f35fdc1af6a790ba2dd15c9f585a76a8392bdb64e7b276dc8de92915d418a9c2d0aff468c6451918724c6f5c39f94c11fad0e852a29e037879669ec38d40b80709699e4c2e3b89c757c7659154c9646ef9cee7fd18d81a2a8e2a4edca5274f1285d5797da81cf6c1d49800c254ffab81b36b662b9f2ccb1c991637d876de7db317cb2354ed82eabc62c3bbc5ad776b65998128de27e5a99266adf679ae6e1462ddd4062df41d94929b1f5f620303e1e9f4e9e51b6ffcafef5af0da71c9cdca9557d11f96e7fb8a6c6894b288b27414d5eedc2423b29a7598a3371e221b46c96fd618f0bcb3c4a6104c42771b146181a35a6815c34b23a8361f9a1a20a9e95235e2ac2ba646250e8d20d763f38b679f4c0b4bb73348a266acca54acb780160146e78187a584771eb4f109241af923efeaeb7079e7814e52bc68a7fe07622db00ffcdbbb76bf70931663cf2936a34b4b1feb05ec93ca9db1ca3cfca25280a73f712540e97d016ffe91bdc75c01bb390540072ce44a9978e4fdae8d5687209b34d19651192c127ea97ffb4b9eca0267a637c2b9826cbd872d3bb36e3a4bc437cd8440c5a7f19176134d4cfb450436febb9ead0f8f60949af64d26817638a4eeec9677561ab661f51bc4d88d53bfb01c3e1018117236e539e47cf291b9955d58effb40c39fbba426bdb4e9639f0538b755c72ab880fca04aadd519a549116236082edb8796d76e2e043ba6aa79a5dc8963c0caf5b3cdb39e967bdcc2257e00cdebaa8054a1dfc8b61fcf9a2351058fe7e1a20e0d63661eee6221e22d84b6801533d0a9a03763105bbb5af56061e3d2438126983bb18b991564dd4baffbe9899b422ad7a2658194745e8c86c6e3a24cb2c7add37791d6b91561007fe43c0a37be561eb7c1fc29239380dbec5120c40d605560b31dc599f84cfa31d3299fd2565aeec411be2954273a637afab551342ddc6751bbb37c9cc746864fcaa81219d614eba8127c66d07cca322f8517f3584da628d42a4c63ebb7380d86af5f3ab23a89e31833d233ce2b50a84d58176bf49ceebfcdfc70474fd254471c6db21711def95f3c8e41f5464d1b520dea1df756aa13bafa191ceb23130bae408b42e19d4a754d286d6d8e64ebc2742ebbbda63ab2d549c8be1397695df9931267cfc477acef439af09e784d6b06876a05c98952d8de269cbe522edc0b9e77125db5814c05bf7a9d2151f5c788c7b39b26daec57ea957c3d30b4715eb0bbe444cce54b9093e07248b1e638be5d78aed514edb5da8a3e6af023f5b31fdd87cd38b9415107faa70872e554f3982d06b56aa012898d38fedc774b146d96e23f3d5e49100f299d6cb5ff5f526644828004dcc678f669ca2b835eb2de0cb67d8ed77f8de1c6a33913f75bb2e6c4b5fbc77c248db4523cacef3c91e2c667285df166e5f19327108e47ce20d9eb635e817824177b40355714a9f9efd90fa00c0af6aefd3adfb613287cf014b4ee35d6dd471d4c98a4e73864ac2dcb85178eeedfbb9bc1673678e3d27a85f9a4fc8b6e53e08d2668191b1c2b902d35e530b796f2a03badfdd822bdf599119ff2263ef0b2d827d915861f327044ceec6a7641321b8174f014beca945782ed93b30347cbb85afcdc3b7b742a8027db46d6cf4d218a9197da0d68e20a09fa0726e8cb5ca6115586b824fb5719a21bf919d0e1d3d71ae27893ebc06361aa3e5e4511e87ac4f59be9aa22eb28c5bfde4cbad65dab02c5945a917b9751b87fb21fe9968c6748aa338c06a82738f76793467d39ba228309667e8b43f65171b9b5e09eddd299e057feead6b6c7a8062346332715a80092bdfd2a2fe4f88e5997c79f938bd21cbcd0fad4cb8c0652f53586986ba410245adc7bc322adc09ddb4e275f7f477874502cfb35e71651e00b1762178d72b63dd64e9b954097b3ae0b88fab5f6f19c896e64d653dfdff2223542fa431c2c822a06a22e277e0c00f7836317d993c0c98f6cc342376d99990229d2f5c6905ebc860cd21991a1b946436374436de2223391b9b858348bbc9161f6649bf480cdc3bae75b283818e945a04321795eb0bdc3adeadce86554fb3e5234d2bd08507de62d196b0d872576f21066b9bfc93b0fb50acfc540b849907aca9441ef2e126a451aec6d754f369ce1c0020a49adacdfa8a6123b36656e105005e621355c8476e6c8d065e504080857bc6b8b6fade17f36b4d0fda50d027a309bd174eaa6b87354c8bb81ecc8578c58dbc2c05c0ec282f23bdd7c9dae0f5c751c7b4da34a074d2764d7ee1acbfd2856ace375b587d8e720479f56aaf42084ae09e24933ded8e336fd70cce503549f6d3fcbeeae2001d307cb247f9d0eb8c37e8ebeb986d59327fe903364819ada5530f25136e947ddb825ee857a06bb04ad5fdc87113ebff82373a889bacac57571195fa4f25905b4705513d97cb2c41908661641e5c1ef066dd31730329318c88a8ff77678e506bbf4a129145023007abe7f4381c937e1f5218d4f78e53a3f1e08386b492c7e09c01d75d8312db394c0b18961f75f36370de3f9c4e1c56fa8a178d3a291d977af8c0f47890cb89c4a9f8fd1419d127592ceeb79711a6930255d39c335362260c3cf69f763d569c89243a87d661d9be7b0ea879c253c560d521bda082b182efbeed970981322a3756769ead4a9a8d3e7a41163176a1d99fe5f47f97244ad2dd9f3429c99a4d8db224112c5334e867cbb2147bac822ed502dfd80e9f6c54a289a8c24811ec50568eee5add543f69131f12e2fba8a478f9a05460b3911ec9b50f52145c4b0e89ef2f0acfd2d1c08a7c7eff99372e1900eeb6fefae720b607010957a6bc2e36316de49e5d90dccfda989fc813bcdc00b8e9332f3cc3c3f4f83aeea3ccfa72bb36e01f5a21ef3ca81074d74dc5a6c9b6b39ad2c6fcc6feafb61436fd97d4ef5408ebf5fc12d255cb802f3c85bf83f2c74b04abfd0747758d11798b85fca850657c73cd3469b842e2cc821ec27182b50c5acdd7828b11cb2ab3c80836d26cc264ed9404438f1ce6969d54c4c9079d6e22da7075c7c3fe220ee2d1905b4d76d88ec4032933b3c710b931c61416276f1f4ec61bbcaf7292beefe05ad42ace8b8c85b53af94f45792099ca4a29916d9bad6b9de2c8aa686ed0e3e3819cb5d7d50a6c7998621958b1614dab5ad9efe48789a6739eed08a50dd46423f83d728affd935bc0c49cef2a4e9d6515f87de0f6c6e0ee35100c1489ae88e7b4c0f5774722a93179b21aa7ce3f7a8584e119d2022758f86a782dd81910280297b350112825f9ac5149fc2eb4b1e904e7536c97bcbb47a13f99ce423e1f41558ebee3b04d8eaf6a97af1db7147bb137d450e5a492c2b566efa21444ae0f1d13e173e142bfb867352ef633e43fc53d46ef12faeeff099f0a68a0698eca49fa717bc326d6b7b87608e57b4efc26836e20c8f23c18115d1c42f2da3d18fe4ff937610aad2064ce39cbd3fa578d789b12db6aeea464b33f32a6ee73919307ab5955fcc289da183431e4baee5fab1af6df79ba64060138ec1201096760a10ec2011c5b3ec311bebee875e4cede8c7d7309463af071235ea322cce2719ee22c9efd19f7b6d28ca5d6cdff733af403b469499ae853e1196399e11eb86ec9349fd91422647038174abc11ef04aeb7babd6d9717b2619831d5d0cf73808b14d6eb1e10725f24fae2af2f1911b2abc318ae83c10c31a0de89b8c773da4861d58ae8b25987ed1262ba195cc1f2e9aad27973b7f2f21e434fc28d747094e67eddab9e8ea67b66bcd59ea3350d3bfce5487cb532b5c0c4bafc18cd7151a7707fc24ac75292ae1e633b0a2366c868d4b31b1dd03ddaaabf5be38bd432869e4c4c77aeaf9446add4f2a54fcb6e7b286c5b53318c67864aa86d9d5af05032fde1d6024f717a88347e3166405193266765b824341a6c25078c378cf8e44791673ef3152765587a720c234ec1f20a47852a4cd4d0f87fa2741f8b373ea1577774cb06dc4049288ea82f05bca59397ef05f31de0ecccb60a6d0ac380b1b6c4231129bae72a9100f516ab93a1fc7d3f8e33f77b92b7a29ea4bb14fdc916210b4127301a535ae3f2a1d032bc895b1dab89d57d6c7bca719984304779b4e43e55fd6876101f350a604afd718a0fcf728effc53d6354981f53def3b4833c13bba8e44efefc25dafbe8796726e2cbd695325ac16c67c1bae9e54a185eba3a0614f1f3aa3db044d5035e7cc1c21f16d0d6c0742cbf87c17dbab85808ec970c4715388f1e6c6dae3c96a6f5a68bb72a84253c471d9037dc808562838a1837e064358eb7993c8bf16205c0192b2fb887ccfbafc394b002e81322d54796602e0880cb9ce516a176f6d9a04d0bcaad1065a736b32b625ace43f658739af5f66162e839b4a38b32b935203a19524a9865a3aeb4131084cd4faa0d08709bda35c489357d3f0e312fd6976c3942256c6ce2ec602afee1750b617737d69615e847aaef46cebbb3d8ab6f48475e66f98103f2340afa3786233a1da58dd5bd52141e55d0fd0508590b59130ca1be80f7d71a23e95de03fe1ecc6b6e34b3514b658532dbd6d28104525d18c9e579b2a3928dcf4b534846ee3a78e097cff36f217ec24b67a4624045d94b3268e1f9817fa7aa453a7ae65bada6d202192cfec8c8c4bf00f33d5ed9526b9ee9f97117e2ffcaae2313cbc895804c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
