<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"01c29fb04eded0bf2adcc068e0177448937ac17619cc394291379be02f93bb2769c0e7747787742ab87f0bfb16753bc3fc660e8246b37e9a3331948ddd830cf04aad6516b733e9c54cd3945f67d4897062b16255283c8e12c38c300a628bbda36db279462ad23b7d8483fcc4671ee535979c055a6a3fc4259de5b3501740c4a51b120075b27026b5faa8cc650ab832a585de188f11c9adbdfe41034b6ecc9cbdaba9543fa9a1088be292b41fe2d1c237fb41951bfddfed5e1a8f8252170c0a3ff16d5b9f6133e42471944c80205f31d47baaa911f2305d663569c08dbeeff7f1995d6e253bb9b7c9834c20e888c11b08ab080be65d0f34fa0e3fc14f74f8d05fafae115075b8267bfc4a600b5f94770b627c4cc8eaffcf65713f592ec0b95228273446da62d5ad477c333d4b5d1b596d90c0d3cd3c58b3562b36d8d9dbb1be77f25e6c12fd27b80ce37d5292327de85779ce33e62f2af9355383fa1152299e860750eeccf3f4c94d74b8eaf28a2a6d541e6f76bca8d7279e60a74332ac0ff62ec822cf952a6dc8826e0dff7cbe79d5db3300b3b3cc8be15488eb57fa5a8dad8c2a833c8f77952748a521d41f8ec269215516c33225936ad61e6e0f234dddb153d94e28fb496e4295b576f139716ddd6768739a991afe092bdf0241fe4056fb10ae7bd3674103a0bffeeed3b8569c9aea6503167bac3b75e0179ad2cb230697b4fbc32544b8081d260824785f2ce4c86ac21620e7b63afcf709becdd769eeb2b7270139df4302c4d409c91ed837a011ed4a2f68b25163eba4ead3fae1c88465b9075fd73221b332e2907ea2a7c3ca5a2e1e0f0b471a31c9bde31ef3ab8475335fecbfe7aa30ba1e5fa85a578fe3154248ea936f4b20f0c065b1a8f4b2f5ae743390e8c23eeefc76335a063091a9f62b8045f7e5ce2cea4ae15e6742841b56fc518823b71b2a0008691e20e09b83301fae1e72f4d3a0f01fed395be51eab7aa4a2812f7d2ac002bcc34d40399536019c68c4c244603acbb552387fb9e9cd96cb754fa003adc3dea7360a74199c2dbf2f55857d4e218582b3e7b2d439b114957061bd50e94fda6450a656c112fe69049c09ad434b2a6f3eebd6f58509dc4e822805ff3daaa16ce2b6a421c24f89437ab1baf88405edc5e4d5d19f1535453e77d856c9b723765e2cbad2ccf9e376f70dc7f233197169edeb0667a3e5ab6ded716aa3727097a19cc78d5a60640777872fb0719d604a9abda1e03dd4fef539eb270f6b0cb2d9ae78e7f3723139d632e3fc779c1f8840ad67bf8216a1d4867069bead668e48c9e8194f6895929835c4a55f06cc7bc9dfaf416fe883b7bc9678c16db96c1ed315901757bd96e87a01742de188785f93c9091498bd6b1c3db04bf1db7c58a410282506d45cbdb8fe72878bb30ae894710c0eed72528c44d2387d54ccdeb7c8cb9fb3c50dd47271d043f19112a61b69fe4612715d60e5fbcccb30c67ba94296795fdfb347b1683b42873dfc8f63f1b0797229c6d8d4d0e31e8bfa4945e42a3b0127ea430a20f6d8d2f79be31ee5dd5e0c83ec0ec3290153d2291c3885f7ef90f2783fa5f0ce676e844c6556af6fd30a0f9c889480485eefe838ccf1b85bb05eae05d05463e9e2b128153ea94dcdda65c5c022eb27b9fd2c8795da9b9b4d7f6b4f2926259599091d64cfa5369661e7bba068e1444790eac72c7acbfa6a4bb38f171cc27653a70deaa1e5cec5f3c0bb61b268a0573775a63892e0d078746c7fff70d507e034f56cd9577b641f425cab1a11d019219f3f80ffd4844b3ca2b07cafbfbcd2c3a8ac05b7d80cc0de0db636165a3cbaaab858f2df19a863aac12abdd412f0f14a0e6906b7bb0b55ee6ab32dd6bf033985b5a98bfdcf9ac36868e949b296482e7a237b47e5f47a012ebcdc56c20be686957232808e47318584279ee554401ec51b8fab76d88c44aa8339fda5f856470502618f8834add7e67189c50ab9a876f121838eb4763bd282572213fb46076c75396c6a8dd57c0e26c2f57cac5f0ed2c1b2afccbd672e6fbc21461e141b4c11fceb0ad6e2d3b77acec790cabf81428df9635838572f67094874dc457ca08b7ff4fb28cd7cc94bc93008747cd4527f40112de09f7caeb02ae25aacc463b2f9fdab69396284fdff44e7ac864cae73014146fcae8be5255e16b094dcc2332233cd69ef47e63f599ede236d31580a5e90af451a9ea7735916c34c1fbcaf80d5acbbc12e9110c96d1eda07f90164c88ec47dc6ecc7f30e5fce8c1c5f1a3de5459cc7a3b0d5d9f8c3e2db3c438dfff272558e8266459d6a78e58d3b87f711b18546fdd54c72469b1f022a0cb32ac57f3335eea8b19d20475d2b82eadce10e7f75eafda6d5bdcf58e0d773df771d002c5c762eacdd347f7f2faf45822842cdf7a8d3d12a83cbb02b0a47278172605e4a604b8b8c6ec31d1ea45960c590d25df13b1da3f84d3bbeda5f307f28da69069e690b00bcb0ea163c0105e02fb7b79323ba26271b4b5a3c5aa2bfd7770d96988f217602a4ce42f41edb34c465a67c6a43bfcf6a2fc6376443c75d3763e21f73ae483dccc9f27d2dac2639c60e5fd363884a4d9c0015f487a25ccc2642e30421b40b41879628c3d042b0f880e2fd63a82d08067c6e05ba85281744366e2dcc65e4ed55336d3ce2fbc26e48facd6d94f539be9f683c6aedf8317b080c2ae46d0cbc00e198a23824730fa6bae6aeae68b8fc05d547e3526decc76b6015917fcd8a775e2c89a1a9449a42bff71bb594c01386797d3a4a101e85d2c14a4693e970cdac622c136acb3da4f3aa5b9b7f7ce490e1d798fee8d681be71ecfff7edb406c2ba97845f912baf1928675f0f59fb11f1dddaf395d3147ef7e37300ac08fc66f49f18e36a65e6c64d9e2b8b19bd8f5e01abceb830efcaf059b19b0cbdea733f3f9c72609e60f799438918ab4e6165b5968743f38cce3a7ea2a7e672c4a1cf06fdfdecca52aa2324d77417ad24dae8936d3e3f6f5030a9d077f4ec1849b73e71872259fc15854aa990bc16bad254eedc805ca3308b049f8ee5d57f7f677860b2e5b84bf9861e2966cf9f02c69b9d31b1ddf67d9170758af01c1b1909fabe640e2c5182fc2c30b1c919095f4e77b965ea5cb2a50ff975868f0b7f068b1b447c175b758958e5f2b0e92b84e6a60886ae77c3fc582fe5cd5831c0a8151c66b2e7c2ebb8b1854a5c5911170f1b3f0e2c5d077c9db6b3944227263e040c8f836f02d5fda73521facde5c32f7abc2f103055c3886068558df3e3fbfbaac3639669bf10da0043acbe46e2bd7833d829d97d43257fea76a1214fa126197b4d67d80e3ba9a1b189194c8dc2ca1dddb2d72a12131523567e30643cf595b19998972ef56447e9246a2dd521f81e266e99de76cab40f0bb8e97fdbc05607d5d671d8b8e9bc9020fee99f606bd8f75a2088f921493bbae295602f3452dc6f7d7191490da0e0354e9e857ea58cc94245fd36c99ba55859da1d1c5e37128c4d3fe09a771e9e7d660f16ce16c92c97151b31fa6627c000c40d7769234a9be8a0839b715d88713015436d3ce02eeb6e4cf9106a17f88e8a148b0d9e581cb37af7225dd1882960a2811b752f30dd5adc563fbb4e447ea24b5f77c95a2a82cfa9cc06d8e13d9d05f8653421e79484288b00280a89c6571dbf9555bd8bd995a5abdcad1cd64edcf25c1b23329a4619d88c191d3caad7167efbdf04642789c6eab4adf352f4b8e3215c919607a76bc883b155b72ebca603f2fd5673950b1961a1a42ed24877bb4443c05568fd741821ca9639a6b11f98e2782cb426d4f3a7dd8ffabff006104d984cb7868cba5617e242d3119df8417dffbb8a149713ed665c4b2dd531a56a1732746754189aa3a5dd5ece5a0c45099c638fe03eb2ab375cdeb875b341af6097ad358653842391a49c3bf0fe6629bf58690bc9a679bd2ac47b7964dfdd0a2bd751316d3c6b1f40d3a55e4b208759ee3e28bc3bba9db3f1e7943ebda1116aac9f8c5d74e8c17b6e7b062445865391d96d3a59002aee2a1ac99bc4c362cf8d365a124227f2c47c15650bd589b4315b264be7d89b86c476e06d20e336332707921dcfa1af7acd14c96cd4efb47b09d3ab58cccd15b5cd1dbf68e5f538f0d53e526dcd393161ebabc687aad3e86ec4508d2d9035015a18d0e8b2207a7c7c4d1a6f2dc62353dd91ff534d4f554932760ea97d66cd0a61c8b02b554b84b1c26bbd92ae63cd0ced7094c23750b2648759c5f028a771f72e4b9d7d6a956a73b39ccc586b78bad7d8b2c9e77b7d51ee4bf0f1f15bda9fd5bc14f85f9f3c9147be7655194f471b6e48318445aca0b0541e1900a7649ccfb8d5f5cd26811eb616920c6f22412918cbd0d9a2b266261473411a5ff6fed1bf38849581d8f9996bd81fb6b26d6a8b71946104bac12f778acc7da9b8b216531d9345846c4b18acc8044fffa81faaa0e84c728ef91f601255b0981cd62f999b7ab87962e9408688125db5d2fbe0fbdbeb5f923abed6cf5b130a6e18d74ace4bdd1dd1f590da01702625f9ca433f1bfac4dcf2627b84ffca9d7b0bda97d84866b8eb3506eb585bb776041ea890143755a77fd5f7de9c9dac0f6924fffa784af813d8f0244e196885614c15136f0d8bce6cf08c374a2d3b379565d9089d9256e405e9f5265dc96a7402f6f0eb6da3acf57b1f55d5fe08b8ff33d39081ab9ea9ca4ada4b37c5a81540a51aa510487e4a448e1e73f50ad9aa96d21556ca2415c05f68999507449fea6e9baf48b3cded608a4f68e9c0a2ffeb0c619423f1958427c0d97dac8bfadebafe709fbf3d8372dbd70ec3d7bbc563d79102b80a6cbb3a7da44a308c1ff80965af958847b2b019fc3675dac10c2d598c9d1986199810835206daccb60f8d03b7953c417e5675aa8f57d2419c00c60c39874f02e7d09b12b80e98ed2ec5da4b08aacbbb6cb6a77ba889c8a8c2f77e84f7dce17c1f10c1783e03cd27a5e8ce9945e5ae2d87cbc9856cda5b571213e1ab6747ff24cec363c894828d2aafcffb15570bca59fd3737d47d5fa4d5c125560452fa2ac60af0171967ae845d1cf2cea72ac9f6aa2d04aa6c979c2967ff3fa1519a4593af9c74f8b3f04250d1bd171725cabcae176a50fb4ccb5a0321b26139a4aa35852b6da9d921c06b61a7b90ec021a951662a3eb616631f52ef710ce10c713e6be3257bd221c3b7323a35f1063776f37283d9cffd06430899d88c51e99f8b8464d5e7dc6fe512a0fd41eafbe0eda182eb0beb49d1f50cba128a44cd48c0bec6761968d89bd511ef174148d1ade3e6600764966c0f7d576c4550c3ccc1a9c8ff883dbbc94d4df7deb11ff49551c9f6dadbd38ebf29eb28388e403b9bc06414e400db80daa8eb0ed41d3a8b2678fd7b2fbd6881c2b8f65012dec8946c4f49a60e57b1f6123d30808546d647311a74c4c711474434d8fc5fae581757d23ee877ec163b9cd60f75dd767359c86ab14827a82b9f0463faa2002f0182ed75276d9c4e8a3a8bbe161df5b8e89a4a718332c952cb3999070075eac4b9846e465860666643d65d73087866affa51972441e53d7e85fd8840e7f9775a482decc34d81d42bcc3c621aad1280465769e56e5553c4b19ce463919918847607039e4acde72d5934c074bea47c30afed14ee65a9a202b3bcd29e07ddfa847d4be2417d7c490e3d116868eaa214d0738017f20ec99b301e5ce950f8fb2826f5903f2ed14963c0f65e6f8ee2dfe19f1335e2fac19eac3abe012ebb654e92ba865fab71ca0a8ec6593989fbcd9ba51a19cb9e31e3fe742d40a9188ac2025dfacdf9e8cfc852b59dcfd530d3a51d02382e9898cca80db7003705072da6b062b80901fb3515dad7894d406d01be28342f3abbbc91ebbd35d184f344455c992892b3c8405f5b88c128bf1162230b86b60bf4c86bd64bfe8b16f28892a1624a369c3833bbea9cfd3d3e2fa0086a13552e58e3cc836376d1ed3e34dd250947fc2ea0bd4e1dd67de0d42c873f117e38021e432bd30b3c9fec5f278a735fd99d0b5931cbb43bd0aae737e4242a3a14ae39df4aa8c3ac91bb38c2324a81284de132f1a45ec2fbd24793298ce218e0d52907a60bd4bd41dd8a5984fc52e049f43397a6b5f12dc095880ac19b53877ae0e42068ac77c5e829afc59d43cd185ba5e2eac8225ac150ec0ca9f25c80f7ff98c69ee0375fb0ec96b7cb30c65d1aad21b7f519271c831949107f802a97acafc8859c6f79c31a9deb45afd92c669b45067b5f0bb021e9c8d5553ea927ec1b91166fd116854109c930db1e1ecc838f221201f1ca79317be73b88e1cdaa545adc96373e82c2eeda7109d407a045451220dc4776ec8904a2c4e9fc2179a4708fca997e007fea229d82a5afcfb788aebfc2712bc0d11f91e10ecdabc62c8194192b09ee49af185879cef49a1c90177043b9306c31597b30c31cf88af7b5ab77f2b24201994eed090db9bcddb58bee0e59f3034bb4045e3990d31e0de032bbf606308c1ff9cb835686aff1fc4af6d78d19a208c2ea5e71684783690641e9018dca49d4ba530b2157e945a60a84ba130c6daf6375d6907a571a9830aa3507efad57b2ebf2358e3107e6ba68e3bc26441337b141b794b29c29b4f8b30955ca049810e2422a05c305d7ff925afd5ff23eb1627f2ee7c6ce1a31cdb0e3557de07aaca36b3421d49cf22e7cba84fba2470a8c2cc036726ee8a393040fdb53b843ca155d936cade5d702c16cfbd0864b395c98915a7cab3eaebfed47ccae9cab18d16e87c9e91bd09fceec8212f64310cba388792ede52e6ecfd2f964593661796424b49ab0fe82555a1599e258485c4d535480cb7a6a7047d636d209155d9d2457493cdc1f3e46b6352354df52142e9ada4ba80e441e2bbaf096f130166d6484573b81b1e30e354eba0b2354cbb01629cedff932067c239c6378fed58a742086bc35a6a38f338c9f6b78b36f17e15b49b2fb32e04c8945cef698927a71b42b23cda98fb86f7c904785dfc93c3d63c833caf823f60046a773649ddcefa4e270744ba596d9fe38d27fa2a6fd39eee76a948af3a5ca98484975260d69856d05b105ffe0c493eb489c95b4c340dbd7399a2f92a9a300feb2d11e88cff28fc3833e453f587b31da586fb481eb6d2b9e819c712f4e49e24692e9779e71bcd86510637f563e9109c30700a5f182359348bfb207481d6aa6ef18f3dfd96b258e0478315ecee0d3cb4ed60b8525ee57ba70f80edbdfe17f6ab7eb1d285facd275b7999678d3c45f1623f5b49360cc37096fe54f12412af381c51dc3a1d2536f948f80d588973c2805c8eeec299e206dd1e29c89b34e8f4095bc9e91df533fb0cc26af39ec557cb23d9c1813be9b70e9d38085e7e80ba5bf55a44c087c671634b95453a901dd7a0d8289c784a44b3cc829082b7519235f5f7e960d4b59f1e159633a5987f296afa14da53ddee57c9a8332e424057f02cdf16040a1ce48d8c3b908fd2dd12a939d3c5dc7682282cef0720a521bb84b68ffd50eebc08e3b3decb626f90ce34d569c593407c494bfd851516673d896caf3e042270267897669b4195c7f12f127b8da7cc0f1d036e1e4138b800a33bf194fa1673ebfe2f4401d7fb83f7306e598ea344db708d06e73c11e062e87e354ede46bb1e85dd2c3b830488bac5f07255a47b648fc5c1534b2197d669198740986dda53169a0598a067c1bc651e08ee2766dbf247c1844837435542e37d76ce92dd8f3e2c8800997fcbd11fdbc3f74c9864353f26a65534d9a638c11db4dc3fe4c45d0130eb681c4815cf0ab16e222c1b42e312092676d5827515ffa283d3fc136e017e60c8f43f02b84620eb31b52e8491b1660eafcf43391e67a8a2859e9249120d11cec62d8fa427b2b4d3889fc1e0dc07f6647cdacfa3a41d52d824fafcd268e6a6b4d5f8e2e18183eb93e60aa9115055b43733dce839e25827c5504c15cc0ee2f2fcabdf66eb3e08b961d330142ba470a655c843632b407591bd54ef2f9d45bf26541f6ac6173f180508719818bbbbaac12883ba55ef4d08062d8b8313e1b162e68fea2902ba87b0de870b5850badd8f42a1964e0f46fbac397a3a4db085695609f333a3179b7ff46b736f8543060fe1809a568cbe20e349ac9052f6843c748803ba5242de72e34c389a9851840ab11e73fe84b89bed409c757faebc934b54a0df7a8dab7cf25c18516b4427a96efd2c5e7101749cd5f4f139fca513aeea6aee2c2af49b1f68c77feb39d811f6df5509c6072344ab8a2a429a58a2565808edb4d0bd72d314ee2f90e2f4cf106dd847046fa4419ad0c9d899b3e5d86a7c7fb90b31dbea9876696f0c0c99ce25a187651121edb2a7d71f7376f378295f0f612fb133fe0d5eccb69e95d950c01bc22bc0fb1491ad32c16bc872a7496e19e50bc910dd6139a6688cb712ad167bf415e8cef323ed07afc9dc92988f2c885ece79cf5f8c8eff990bba399b36adb0731a153727193e8dbb0d9ece9078202f07b2d6b116d7cd893fa850283abff59ad29c5fec5572e208d303248a49964cd7a0773b8684b232a3b375f4c839942b0ba2abb270bedb22652890766e5a869f74ddaec107ff2418ef58b87533efbc8b22f1892ad81e02c7e2931530818a1099e15b58ac76bb5535b26a9bc1c4847c35fe109a2b0ea75519550fdb2d2691beda795ce85b936b88be05cd0ec744e1c019f5c1e846fa80bc1acfbb8dba50649fc6521311b17c42c2dd1f28c3177d12c40097f1b0203786cd3917c74fcca4a800c7ce9b8ac7013d5f6ae3bdebd308a7edf8bebeb2438dbfbf87211976e3edbbc50a3bd227c74d2b485e9bd1536a81c3d45b53a95cfe2605e5d70bd9e2c3cb2ddbe5d140b1e48549078f3363b243d12b8c9b9c77eb4a8c0db92288c9ae2262c4928e129a54a08cbb07c41e97dea665b1f01d219a1f8c67497455ff3cf40d39ccab10e3459ee661df9bf273621fbc290fb1e10a52c18ac24710c29fb0996cfb0d513f7dce8b5e14431c2b155755e42d4a3813240fcb0df0780e1ca6f1880e0bc6c904c0df369f21b09fe503d76e2b6b7b23ec82109b042813a96a33939b7997cec217a400dab27af280be74d6a5fd461f74d80a28273db2a751b3806e445518c718006ec5e9a23c4c93e59ed7e99b346c6dc4711ffc9658a5dffe111c2484e940a3b7d9fd2f29deeed38862dd12558322f3dc0a40c40876c90b4098a6b129e18e5a6c9c8b37633996c2e2762efbacc1ccf0799e8915ae1794fa25e57eb70140ce3dbeb981cece4116eda7ebb41a6fba61f3b09e52d4bdb27d704fce32277e6fd69c4edcd40591940c7b923907049c73cbce457387e84339622fe985fd4c81e3802150db3c641d0e745ed87d50005ac2485e733086fda281911a86371478dafb527823346253fb8522918c4cb299b2e617ec8f21fb054f4c022df6d38efe3492322428c40bef0823f37b0469a7cb790c5949fec74bbf369e7416988798c591524cdd57c061ed0888c1baa6bab9241becd29f6751bae5cd634e787cc4dfac1b09bbd68fbd08de758f86b639657ab6bc924adfa8e7bf0832cdacac0451406b0bbb763990f0a88b95bb26c12998eb1cfbfe2192587a14b6e47e8e7eb6a09c7628088100e8c8cca2f0044a85e66c5a1562f117789582587ca68465315403041fda1e63524c9da25e7cdb6d0d42ff13219bbd690a2bbdcde23e30e78c4a6727bf5439ec52fbd1a20ec69636ff96484f3717c95e1f3fd6b8f100107e0e539fb70df118896893ec9d6a7ed63cad74409f5964cc1847010f5621e8fa6ce6073bd305de42a2960db59a5c88e1afbc4ad9fa67176fca5a6e80edb0762472be65cf7be22270ad34cfe051aacc98103d73dcb3a52475a58d451702b7e7bc1f2b6cfd7b8afdc44340b9a3f46cc67f213a501b7548967ab0e70310a2365f0da0ac101941317a40105b7668ed770d32076110eb8c76d7b6dab5f9b5330a3d59156b4c91d258932c07fd832c81d59fec1e55348afd68f8e0dd5c43158016c860261fc640a8e080a7157db36014ab898e9bf40fef62166f6dfe4d201ac79086664673edafdbbb949efa217ed397fb7301391ac9ff08bf2cc59af458445d02fb08014985c6168e3196a1caef43a3142a4a6e92b3999f7199ef745fa4884b22414741c6046374842010094dfe7f94ee00ec4df9646607764afc3d72846ef5e44562655b4f1bf57b6511c408f37ea5f8f44ba81583f83cd7e9347111ca5a13d71a5a025604d686f80ba43e112103142425e6b05713f8b1ed351704519d16eb0f0bc55bae3a0e428e107a856388d4eb831d58e5a088eec0bf6c8e12c5e858c0512d7e40ecab898a8c042cff4e4a413aa3d36f77cc92b0157289f875864ba1e693a81ccca5edb23347e0372cb8aa95a0f22a0da4835e1d65cf332152c208a3aa946dfb043932fe05e37805d712b558b0142452ca36f345b4b0fe5bee4410a2f2e003b153f49e29edc48d5eab45d959222f9b50b63322c1a647935ef487424e713feac48bf563eab85492e528babc82e7ae01e854369a65530f273a1828e2ca933b0d147eca5ddfe88697f5b5cf7b3506b9e918c09856a9aa0eefa5e98ec9a1e2336d2c38b5819859c9da0830b221a4f176de7c0f7d984b745845993ae94361024fb89dec77a45d29c5574c38052d5be99ecdd3ea5222a188e6815895942d437775e36da0385cc33dffbbf7c9c32b5c4fc3cf45554c4a643664b7ecb5eb321f8fd70340322e0929b4d224452fed1b93a19142cc5eaee5df90cb8458678d21b874b50e92b719d87f5e6a73288fb85741149995e27a550dea88a00469f810c8f725958b9c99ed6c6c4e41a36a02d26f61aab77b6e1d0f38e74787a81708b868c25edcaa97fad5d5182c68733b687a628586f38f0030ce621bf1e8e8545077e7959ec25bbadd24a4e3329b6267a57edb9caf11132316ef4d5d7c3cae5b0ff2b587b2604cdae718d18ae93b4405adf4fa1334785b1448fe910eb987398fa05e8f12194cac68a7e04b77a35085a19fb82ae6d9babbe4c13793d74b95cf5d2616b3c88697bd4107adb0f7e1d6ce2e7387b2834fd2fe6cb0bd685053e9765bbde67cbc40fb705586253407e0294a4600d11fb3508d73ad5dd7396a01d61ac8319181c5f5982519fdaf6f992ba87d609720387ee8c7ba1369c706b9cbd20a2f2ca150ffbd265e567d761c03550a6f6653e9f64f2b5210000859ee778caaa62549c027bf552336fbdac87a87cbdf78d771d41f40e5c5025c6e6cd4c0536a5ea2e814897e75b576dea4db09bde44567ae9a505c7cdce22a6e7e50f2e0004c59276fbc6c5fc2fbfbd05bd30c82c9ace7d98d5e8b0defa1c48f4a13dd731cbf87b225afc21c29b9153eafdd0f218b5971209c95e34d025c5412e245f0ea4377bd2707da601f330ac0e907a657f21d99d1857b4f09122db9808c3d85cc04f36daea69d5dd80348996388da05ace5eb0539f409e93b9c9f7f9a9a8956ecbdf3480d9f5482e59980404993b762a1d6afe9a9cdfd348754153e42989b6c22c1159c73c8daeadf572bcfeee09400d1e8497f6e58d71fee5df59c3549104dcb4724f9d8deb38bcb395778d076578c5fa027a3213152bec65d481514bb7c93179dc4a77c572fae3b9c828c781d71cf97954acb0c7efaf72e1c38e3b62277e8d4e7c098c16f779e1e454332b9f9bdcf671e0f731982c6f721e7ea79cbf323da4c98ed70b4e03f32de9126434aaab5dcd97adef520dbf3721f484c4374270a51e1f846f99d7b6ce29d8e7674d55db84a22cfb2c9032d7575ddc626f78d640ae5959dbc6372ef351c4a46dc66e0600e44318fe3abe2d66b8f3580eca2af172e3de111f1ccbe3c440f505890064ad7e81c320893c85833c6323c41fce13e6b9ffb7514db88f5e1df9bd40f54c4bafb80d45761c0430cfc0d2e24f8dcfc390b909e7483b1b707fb93e0fd9b5416f89346a88a8dd2beb43a22790ddd0279b4a91fee33624773e25d16569ab26382861afb82563fec151f98894e659c0d3dd20e00a21e6f416dafbc91137e70b63dab1d1cbd648f14c8be7760770463abe78f7819a23419f22a8fb13015c5d8c99a44be1d81f5b47b35cfd95c7ddade301ddd1220991edb892c78305f6c745d6bedfa71673afb78545996eb001b889b4391e80b8db72e6477400daee2830feac3348e17abafa191d5c5e9e4597c2ff40a814d22","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
