<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This blog is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                 <div id="more"><div id="space"></div><a href="..">go back</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f90b86f8d346d1c536b467671fda23cbbfb2c217edbb17e938c46b0601cd9603dabaeea106439cc0184ae122d69e95718b1269b6ef0e8d03bdf36a70c47aa0168a8d454ce7a590c09eeca22180214888f6b13510a92b1f16f0cbe4dcd5734dfd497b671c5ca9f523bc6ffd451a720f7ca1cf50a1eb01304dd0826064250fbb77a1db78d9369aebdfeae21f9e5b5f9fea04e1d77e19c8e73dd1f12d6fdb601bf2f38b74663f0f0a38c8adb3f26c93a54dbbf1cad6dc5bb7363eeac8796a99bfec81c007ab9c44d231c6c0d7757421d90b03aac506b7ec1f7ec53d6faed2fc784540a405277e567aa607ffc0eeabf37ac3394211dcd9f879b994b33d3f12d5b96e9216cc68458528f28a08be1fc131bed89c9f3e8ea8704f451a139251f66e52a9d5167de08cbfec8876d1d1a966617f634262564ba80a113ea5734875891e24ae2e1698af42d410154cce93e4bd289c52ae177d6ba127c2f5e28d0ebc2b367c2e2613e56678cf79288e2ce96716da2c20e4783e13c102b60b2f93d63c6384eba0a350d79d21a1fc976747495d91e0051f053ce761eabfa963060ebb35507be7b500eab78c2ae2dfc3a8a69d335c6f84ae97356bf3d54d990901f7d38ff89e65a2d65fea78f9b3323ecb82f620a1b4ba8fcd50a073515ad1c8a642ae8250f6e4bea0b8194ebaa95c22ffbd255428536eb29c251778e9f6ea57aebf0f9d5aa2f48e9634699b6e06fe86f82c575419c4a557138a9731349d62f4bcce7c4ddffef64fe67a4c4db655dc5f2abce60dedeb7f4809ad60eef492903b9cb651056a3187c018e76195fd3a0c22e68c3886b3e2d46cdd81a13611440b72b335c1c2b5f5feae8c3543e0118294a36ab7072da8c0351ff059e997e059c0b422fd2f9cc8d5ba784f633d3a4a7241d9633bc282d98193ccc1ccfbde29dbb00408e40fc844fc0f87ea8a64bdd6862669ad88c448884b6eb706ea8521e1cbe0dfbf20b2c91bb46c7828be23cd03590775b2f2264a93158511308bc713cfa255095e658a60880a4be7869cd27e8757a7afdeab9cf2446089180d5329ea43f616730a4e403cf3f4188a906210d52671b48bb5a5afe567cc96d23551cc6ed474fe84bf8c8ae4ec072f0cfb9f7d459ad8597b7d07e98be07eb90713833cf32d9f6754117bfcb3f61c2dd67f90ccea6803829579ea741d365afb1ddd6b958980bee2648c8ce1206bca2e5eb5ce4fec215606f84de0ad3edadcd6a807983151f5f23caf392c4ea608b225e8f607a62d640d2cfd66eafd0a64ffa930d3e20d1738826661786d201450b08884ae94a799ae0c5cf1e480e586e231cb07ae2f9c0ab4a996a777fec3925f8e9b75c43b27b3be88fb74f777d8cc783d6612697b765182108dec4951d526410c74a15a360b7058722c9bdaaf56c937319de816e5b26f60e38df70e8fa4d3b773c4d604d333afdef67cd58facff8ff812f811a7efb7197ae121ca865ce3fa61a74b0b7eabef388c2e4f986869a061746ed81409228c6b11f88e8005e4a926cb5a41f1fcf70316d796c37079e0c45bc9fb12de5992a1cc0961b8c735e96307e6e2d6ab70c78b139c5b68b80677ed26613af714a0d4003d851cc7eb2c3e44187780a93dce923fef659d5ca0fa833d1c0c9052c76fe3dfbd1087ee1f8a5774d2aa465925a0c46143ef23514887cb35a9a108837a3afb57745682749125831ab987d5cc2d1daf30d25c5172db7929b13dac0461917d248cdd584f4b54c39fa2f495e71f39d0966fa05c37ff18d6fd3c97c3b8fab7e20bfa4076d41f2dd365492616e7a9e0f0602395823a3f370ac680b3e157a3c4a5962197ca60284bf2c75444fc5f1a694d4fb1c8ddd5517d5d7fc504f59aff745c4c2ce2431d3331da206c5a854d380de9afff11c595b839bffac528e22c44636087ab6ab0c307dac4c468b0f5f33a7f3cc0d9c7fc21bc5567d1b4fe62ff750294fd6c2a993535414cae49af8d8abeb27555efa925f500948616d4a642d3bb4f97b2286073e13010745ab335b7dd0e023872ea2261feb15c045bbc13a5f1a8432be864e03687167f358d98c83c8783612aec64d72067df32df740edac93951555e86dd754f7b8d95eeb8505cce52adbaa5f45d5fe69f07402490c016ec39455146d5d94132803efae323e25c3cab5fc4a991693b6398f7d585e1263c8e54fa80fb97aa6a8fca2a46d536479cdf4571e3c5c73c0588b5c6225b0486a90b7fd388fd7923089f03d406775bf880b23fcd2ca8f49aa2bc37215e71bea48aa387a07bea64f3dbd36e1f6f29057b165d07a51a38c5ce338e5f5a807ddb7312023f6bbec3e0da13a0423f5344081adb6bddffcf982a9c6ed6e7f073f88023951f5411b26cd864483b0e6dd223e2c0ab183939abb93ce4ce1c4ad0db1557c4697ecc17905d8f1310a48f80a35e4b097a2db81885548132772f49677ea1eb016cac050653fddc26dbcfcd9fad9bcfc351bb0e8332bfba85737567651802b191c79d209fe1d025340a618020ce8912e15db7fc7fe409a65ff25e04ff5fab33ad0a8f120721c9919b7b4bd779d7fbd3b7ecf3b4c9761a7f11ce59e72ac65464af24d37af92a15915166f35856269576f3280a70ea28e45e492215af3a0b74998eab0a7f027788545acae9d22e04afdd885bdea5486e99789b3201fcd8ed654137b4b6ddc6517c42332355597bfd224e22dfea5982bcfe347b6132a8afbb5d7a089932553f04f210f76cc2ba1ff119041286e8a2f8af97018181c25ff36d905138068849670c27b86c81f41d9a4ce2f70a169b53bb21d57b53470aa730f5ae848593579656b4bf898823a19d6873c08ba1187e04938de45c3c4a53a0bf9ab319504642ba923ed24c8f494f88e859eb98792595c4083b8729326f59437b6b412905926e908bbfd02225d7f33ec2d78bab84ac41289c3514fe2be4c3fdf5e4f65bf182483f9477077dcec2a5d14da6a36b4b468dd3f45cc75436d7c0131dc8b5d89c1a1b0723a6ac4ca5e9f61d12991efd25356c66ca85822ae82f0d9ed6868d205c70230f32474660b8503fecc4cc20f200c2d2b895c5144ae00780a84e524d1cf9436a23a30e4afe319c5559ca2a6c5d272cfb4cb100069042b9a25c76a6f30077649966d0bd7b7db06a2c9a02896039f04a55bec35ee12b702c90616bf868467b785b3f9a32e5529a9a7787d86ff6cd39d0a8bb74eec7849b2b53a355d25475fcbc63891c8125f6da406a8c9356e186f6697361a5cbfcd0e7119148da88dfaba03a9d50cf0f4a7fe0beb6dd4795662072e30e9f00a000f1d94dd8101bc0fcb5f645b0831b5b36d9bf5c5b2bd33ceccbb947ea783e421fc2005129fd6ae6dabb6e466655d281b09a7190a46f4d0081d45c94514691b1664971117b52d309bddabcbdb63ba0a034ca64aace9099e26ce4012f85004745eeff84a4057aa288ec36aac1b1b258ecb9ed4819c358deb58766d51f6c6c88751a0e60423cf7b596ac33a9275c6b58aa72f5ee04fe8e3eb9da2b754dfcfff7caba36834499bda168924b814623e94f220283e8cc09a5410e012e727778b279866101afcd15168559adffc8e4b82f906242da6bcaf70ebb9c022f867b348434c54b81bcdf815dab063e916dde1a42fc3475c542bf20d3e118bbc0b0f9b8ac12950551a936e65527fbabc1385307886df6d1d8480a6248ec09c43a4930465ef9ddf9bf12e51b37ee77367e75ed6dce135b05eed7e8a5ed2ece04d7975f0e5f49022034c1ff29c1027e5878c2546bbd6b30a4a9d07f26d06aa7046926f4a4760792bbdb5611f0948fcadd53c8b6bb5b4960b2c8c16c3a786aab8678ce6d21c6cd247a878474a86da3d6ef2f94758e612a8039a0f621595a8e8e17fa0753d454ca6d6484718319f17c1e8e98537f65f5b4703a02dcd219be6727f0ec0d12e34bfa97e11a26d8c8c508347f074d84249da570277982204cdc17c8c092f79cf6f88431fb8ff124752db3184aef90940d62ad598a5c212b3983a084d2d91ec4833a92c8f1c68a65829b2b8c988828b010272cd751acd3693f753d416c316ad51a23d4cfb772b40c93331d01a7918dc5659a63a0b6ed61ed5b4b3f61855a318203841211edb45fbd2a5dfca55630865a16124db7d34ff1ffa26d69edd43da9ae00fc95dd815514e0b5385eee59c80be772a0c83b1dac21b572d6d0c784d5d7ec99412d13233eca051a1d412b61ffb0e2aa29e99b622439ea13a31d9647f7ce0b4fdd2168d26d54346834d0593da40f9a23c2334ac2c3a6ffeb91dd322d42118465fbf6a744e21f7472c0560fc9021762305f964925ada108a7f9b4d837ad45060197d5f03de7e35bc660d30699a5b750b9e92f5918ff959ceafcc45f0be2a33d5d86844c0ab0c65a48604392332a6252bcb1ff05e28a71983b80f68e751b972083545ccc1669c1dd2015310974d4c973ac95ebed77dc2049789ec0eb5eac6b504886dce80a266df336bbdf7f9aed2897b2d02e767ef769f14b8db9bc82dc37bdb3de4851d2997b8b2bccf1673c88f9678b615e95cb3653c58ec15943c6c52085f024a6b9ccd0b0fcea34d7a51af3cd499e36c8fd63742d77cc68dd892c3d78d66af1b93885119730d677afad0c69612c8b4a99e2bce305eb903cb7530fec72ab18f0e94f5d7378480c209c7382f6de4c148780ffa8358bdbf5c6c8346c97a9f6b746bf24b29d366f263e90508309103f5871cc048fde9e09c56a3893bb6f2828945b84b44e210dbebe659699589176486a841a7e9edeca41268cdfa3eb77a254d9fea55f9387c9b2a36944c4c66db01ac2fa62bd756bc0396b284d9b6af832de5bf10dfcdcd83671c06844c6c37a12d89b7628576d8571659fc4cdc1935ee5b0015a4578b6d03ad9f5af87565ef8239eae1521c9a3a5a132ddf1ded070a0b23e3deaba137cfc79802365be749175af725e4f760e82d0b266b3da8f54534fa1cc74e4e9c40a7805326de761d8805832d16ed67389d2d9536ae4502d16413e9fc11f62d59e71de9336e613e5b397cb79c0c4018b7e2fc7d0f404e6119555004d57ab95a22f22c1aa72a30d46ab549d82300f6534a462a872d91b94b922aa258c321c56bb29eafb24c0ad6edd59a308089af09ecf795047e5edc08ef7e3c1f15a64b66bdd0e17fb2a0fe81ce024e669a3d853ea26f2532f2f7e77f420c05a36a5dd6094d6b0dcfa920389bf6fbd64d3f53411f33eea657b03a113df2c9bff6f3e488ef7e5865a739666eaf634da6e0d8dbd3f75239722b05a3590946f911fab57aa82faf72a06cf460e3d8c09f3826a609263dc7ab07405b99984ba0a550f4bb9b494e42eb2f24e3e130e995c65c1ba8dd028fe3b3ec0a880e49531bcb0f40ed5957affa88694566a178843ec1eefd7cb2adcd1c902698a96628f82cbec9a75794fb422a85119a7ff54087969beb9bdb245970742fadf3231225fb2b4069948f091a04191cd09026166414abe9e9fe46c7e3f67495ab4639a449de1b51251cc65c133a233c555ac7f88145476d9d1c68b96095c0a17f88b0ab92553a2ad0f6c667fd7ebb8a363407efbeb2fab27a9cadfe4b1daecf2ed717886e65962a5a70b20e8daa3376d48231aa742b8bd0e1688ed8eb9052061df5ac28595ec0c06da7c76dc50f4a0b03117c036a1f3b1594839339ab6c2e596d5701e748702e9669a3b3a4aedce4a2c990e7f4a582ee5e0440b00179e16cffb7e969ea04cb069a48ff18c34156d94d7dedb4569ef3ccb67a37c63adb380bd87c25463068519c5b9c469337adf23405084b15a57691d3c1874628d60ca2bdfeeba0fe973e6b1b652a6398e8ec0d019faaf09dc52bc4173703274e47d216503fb8230d4b42d22aece0ccf980ba6bff39213c69a5fc36f419e576e16925d5b821c2e67d73ea70c8638db4b69eeef1b88f3523c6256ffdd40af241c1262204d25ab3f1699d3372abbbc7fd5246cf24dfe54304cc95d7d69980c0a01e16dfcd0ea4a9af6df736c55cfe5a5707b78f0c35f605b5dd6b57dd457fb3f48e9daca7490e677af70b148955d054525f05702a2d6d7688b091ba0d16dea385432cb6cb4a99fafcf46a0a3566235434aebf540f72bdd3caa73969d5b27df8da2bf8870a867f912c09cfee65fa55160609399587806b3466c4c05bb5e5782ebab9382c63091e6e8f03c9fcc43a4dc56071aa100d0fc041d74627ed6f8eaa682f50fac2ab21288b6e1f00ec90ea3c2aa6f154db218ee967b4430e7f7c3493f658618969c83e11c37bc3a1856ba4049a5c184ebb383fcf05f93d77ea7367a22f6a7347e934e270ecaf3531c78ec064176a9fcd0d69c75ba505f7bda676f213f7c16e7006aeabe3864e71c7546d7f254074225de80b782a019bcccf117eaa0ce8554e692ea794468411a5bc2595ec2a3f80b1b5d794a6598b3193f0676c6e106ceca708fd392d568bd70a3e8848d035db1b5598a3c3fb842d288669a62924225b6edf9ce01b40ea947ddb6afb28ad83ae5031ef59b66ad7c83f0fdf581935eaff16af3ace79730566b2fe5d56f5c49e14fe00cb6738477738e8afb8b777baa7413464191e275dd706b5c7f4bf03cd7c96e0ee0357b26b613e36c9cfb6f69388a078908adfb547566885b50606a19faf3f0be89e05f775c137c49c833bab2fc8dc18d422b3d01d3307b70a16fcb8a435ec871a7aef63dea15e969f6edd143b649aa88b0e67b2a9b7631130555c833a28d5c2e86db825d78bc9eca1acdb91a32ec50a99304441a0ee1b279b7197005acf5d5f762db6489d576ee339324c88ccaa9df3f3489c9dd3175eec0d6a24c0e44071c8971726ba63493aca04a3d67acdfc89346813181a5e8e655ec4169bbbb17ae3ff09b0f6c66450702aa30dcfd1e1bdf7eaf6568a80b5bbd35bb6cfe9bcd6e24569e7a82bc422438862104b2a9a3e0893db77831e44f000eb75296db1ad21b346ec6c779a7da8724aefc612607ac42d4bd819539910a1274c5afac3487035a89e90fc0501209ffe137fd94e52dd69e4ec95df8acec5d4c7bb8a9cec8bf5cd1ee481b8deee8ebc81a71b7a7661f5a901240fb70ffabba4755ad2a62ccac50b9701515680387802830d8b1cb7a9c90557ba6f0c88e94f87e38915068fa59e52c4777b564d8549b0751fa5fdf988fe47804136b12d512b4e750816249770f360b8e844987dfda15f67297cbcbb46202700b7a0fb26bb8c23ab2aff52d9d3d5c0301d3beb4c7e4dd12f9aee503fc2273bb0a2e00a7012aa820a3c800649eb82900281a6145da4e3952c7f82b0b633edbe2a5b1d37b75abb751b23ca8516f79806fbfee7786c3de05d513b4138ce642cf820b01441d61a4447486a761a39dd7515c16dd0a8f70fd51096b2bf0f968efc94ad80c2ac5b8984b0c68b642db5c00cb6c1eaa98d4f2267acf319af1fb6a674b6be4712ff94fedcde327840a50ca515488bc03fdb9e8703dcd63c71f68ec08e5e1035961bbba6b01db1c1fdbb039c3c14c84ea568e8c2ec0cbfc1a797b17f77a375f0a17fb8ead707de0ab2c4ddf9cddb679d2794436b0605385379a07ea3cd4dd8b407a9907492cc98cb2062c451baee8b1642dd7198caf0cd12cbf28c2441c59eb0bc392fa9c3cbe1b9167365fa4eb38adf21f6a57ef24c7f781feddc81732ddfc09f071fd4af796170390e25925430699284531732b7ff8096ba400d06050b2b32c3fbca917732a88838feb71e52b3c2baeadf13a16110d71d30d6618b531391ea39f1d067a7c0cf6fbdb1999dc763e794cc690c629d37f00ba966d514ae131c164bca622ac22a27f68497840db6438975aade117dc6ae3c10eedd187646eff44030d991334a2ab89f8889621c330e7df4ba87f664713be593f7aa23f543320eb802b22e236b271f975ccaff3c34c7121c6d4523ab1f7b49067efa7af3fc75ea62ab315bdc56b2c8b058efa10f28bd2aa9118a48128524c861c19e89bd674384a9af7d6490d43257cbe9e79b2f8f3c2be035d9aab0f64d62802a095bf6bd5aeb8650e0219d732653f7feeac2815083e2ddbfb39a7fbb42b63bfefd95c2d9bd82ecf3a22b6c8304b7989e5d1f0e0ceffe734d7781a39e8e488d179b7207840190e0a266b0f6044269ceac7b12a11c8f37e21619b05c9da9b7cbdaa2670fac9dce6b12cd434565684e2d1626d881a22e4119dfa3c341eb964203a56cb951fc857407931ff0d681cc2f3fb6bb1e9c303a93c2815aadea8ca491f1ba3ca6159dfdf58767a2af093a3a0108d2c30c1e43f0127d5cf265699e8f5ae9e0b03c401af37fe921306d2715b508b55404651add4bdcef801edfc13572b0673d5e06304ac64ec6d2ee9a2a6e3d582fd5a1126b226d464e6859ff2c99ce973e84605162c2edc5c0daf8d12852b8770688c7f12cad54c3d294270b9cbb0286a2081d5dda94904dc5e83713c21accca66d0f05d2044fb8e6795bc51ebd47b6e21dcf9ebab411340f2ae57571c9e61f00d8a3983df14fee05130fd0df64df5b2b8ffca9433590846853add8bd2860390e4714eadee4ea17c51d465df08f840549f56e4c30f40fd8af43e04beab18999a8e108dbcfeed275b12e1f45222f793bafe59acd36a1dcc72bd2aecec78bbb3da1953b469746d5a9ef0584633ad6b5d774ad4592047a08efb806b3c46247b366a3370ed0ee4ad22718874c1452ba9cf22fbb61157da59a86d51c412bd2b76cfde18813b7241f4897a488840bbfb5a3b86dd5757d50e7a52d2c175ba1a9a1bddf54963f1a86eac63f8c4977f83a2449e7950172f27a2924238a303dc45b1ea42dcf961c5b9be433a90863e383d3baa528271703ed8d5e9b88f4cdb93f37496c175c4397a2cb1c57fe3cf89aa7a0e8e3adc4de0e1fbbe26474acd209c31bd76c39989300dc049bbd0810e41682f025a3494332bd9412b7f97db3aae248af538467574ee92371ce9c8d7fc860182ee6eabe1a85cde9efb0e4a1a15ce2baca4df662d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
