<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This blog is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                 <div id="more"><div id="space"></div><a href="..">go back</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3aa585786ca8368b58be9e0c15221abfa31d7374f9e4555e8fe26c83328469b831a71e86ed2d52698406b2933d4e25196895cca23ec0725b2e5963e5e0a200c9b38b145de2c5f48ea996354aec6a2511fc9fc6136d173da80dd660da50d98827438d0c1c8ba0df311974d0e2155b4579d20cec60397686de8db50ced59374290a616a070840b19a55534e92d750540d881ed6702ff70cb8707098d2b396305e3422f2a8331eaf5fccfd183f11f81b70377334ba5b0764a6ed60eaf65d61494bc0101d49c97d8678ba2e1b9977e637bdac23758debe82ef8e504b5940f9b31bb07aceffe6d8c367db63ece5e31c3a426f83dfa2ad5254a84b67d40142ac1222f9a94a1e731b4513b8be27fbe387bde087565415092e8ec8fa6060a4b50775d21f41eeb67339cd35cc641ffb7f9045dbcdf80bdc8494405f0c0978ca7260ce98f134200741bc9e088f909b3c0a8dddacc2c69c063aee63ca94538ac5c9fc8066f50a562fe78f3b8e4f3ec94d93a953d64159396118d4b6b3cafa5d161303e040f65a3bc617a75a793210de2fe10d6aa982c4f24bdfbe61624f9e45c897965b784e5325cb838192b4de87858aa757a9b0c2f5525d82b76edaba18b42e82b53a1fb79089bc47d9205ca164596f7d12e4b01e2816bf4e115a9301dcae4c5904a296bd18ab1e6fc58f89ee5b6d939df12686ffb356670ceaed51288cafcc0396327cfa0ae09e5cf0a5e75d4b249016efccaa89574224a65dff0d349cb34f407606ac0852a97906c24808815a459a83a1319cea0fb3e4712c0670f23467fc5a4f02eacc742806150946f36d7e22d4e3b71afcdf388b68d91185ba98f2b8523163b2ec2aa0fa381260fc9c107e00d554a79cdf9f8b97b409f5e716acf9121625a5fb594721aeee4bcd713ff1357c68d2797a3b625b70344a73a38c69dc6069b9b7cfc3de2b97246521978d2126af471aa71eccde584107ceeaccd4ce5b8387298fd02be0639706e7ae8e908a71a25733527faec8d99945e8632bc102cf2fb9f73e8ac4ec4c71d8f38eb118b2b2a372133be4dc3c3ca7ccbebbea08b6266a0bd54986d1076cd1cb8723e8fea53cd6e9a51cfc9d89e41bf83f73312c09951f32cd5bb484579974e6728b3f2099ce317ef88d283d1a59d72d9afba6c75a40d3149871671ba63e961572c052c3803ea33c0aaeeb7662c9fbdf4630a23e4c9097906c06c148481ec4fbce68a670062e0f214adfd14bc679ec5dec20235d38534b58a15f221a095617df789028eeb415577e96dff345ccedcf90e960b97844cf82c325078126fc96e6dd5b8b24eaef997cc7007159fbdb15a7641e208b5d63e4eb30de7115b89e02462edc5f492843295bb2b710b44ab80f1e431cc6df71624edd3578fa2118e4f755f1cacce892a4cd4f5bd284e6695d9087de5ea8b70f1c58ec26e211ac67c03c3eb299e519fd852a857b50f63a09016098504a50f7bbfdfd96000391892fb5dcc215816d9784ed100ec5885b7abdc4735e052e1c30f38e531b5831a5eb5554750ef9d3a1365e400cee45738364d31e388493be5ffdf9b0180e29744e3fed9174cb6046a6c191fad2291e493bedfa2788dcabca1f2246935eda1647b42ef1d16c89c4eaafe2282e1d63a68840d9e65986601d99b083a778de13dda4eb89c61027b03104e0c16d2474e3bb4e07fc9bcabde87be7815beea37bb2540773fc9893cfa1fe2bce92f6fcedaccdd00865766f21c4a176d65b1d2afbdaadaf3bed0497a09d58e405aa2d030dd28970f94f36d3fd45a9fba0f6f3f53a825109669b5a0c8e441c1159a1c662360d5b560a3faa5dd87b083b0e9fd9d5e54bd2bc65df565c5027fe5d1bf07912dcd417d4bf0fe69d1c15e56c4d587d4fb23bf01550d7bfa170917fcb0b0e88d1806ec40249b690a4dbea33d0b6ea310768a38990deefc1ba9077fdcca1d4e0906d03f237f00804acfcd11d9bbe3075b099162d851c6a8fc3c6893fbc89754aa345b45f226c6e90660a60f43d9bb83f0b5bb21656cc2cd22e5d2f2975ef5a6fdd2c9f897dc1f691441650413fbc2a9315f34ce00720aa5242bd26dc39c78450c3632c971971e939a9cad9b4378857ab0f9dafb6f9e0dfd7d31be219ba64b9f9a516e3b54ed05f15ad592babc2558b799ea381c3e40cc03ed0b0e1d87608e8a348508356246b5a0e83a43dcd118895a5f4bd85b5e65a2771380b5080242574c0510711263d0b6a5b714599ac6b05d547efd2011f459d8f2095f915ef12e0130df1d2d36dcc61edd4feebb4febe9bc783c1f3d3519283a04213d9c5f7918bf451c30c850053dfb1bb4c77be7075986852df1085e259d6a1c04e9e810a7b95dcc832c753919e74aa6113802287b7e3c416f9de6e8b69a9376a0b9ff05959f736fa536cffa58c9ab4b4ad02d12e59ade95b140ffef3cb8704f28b49619bcce4f23d6582439bb556e11b28e76e847bae9568884ab75319d31233c66730ec79df6da14454c2ddf7b3f88c65fd0ebd2fc47d9a3a398a7ebf6de47a6ebb2d5c029bd4f18c1d1340e7bc3216f54d5ef4bdf916e739c1516701e2bb0ea90421ee4925849efed69aed510af394370b8086a8e2e459d3a843bcccd1e0ddbcfdaec16020d83a9478e3d765b32f5efdf760cf8cb078d45a3818a2d6c901f5a68d176d7aa45722d23456b0a7fbf29e7b688d7c575652b22b699b6e00979cef680dbf896f84a150090587bdc7c6adf88db3b9db6a135486b51e051cfd5020a0103a0268aca12883a603cc4324e3c9eef4a3da4e5451afd0020ccb4a6360c9cc171a705597a7749f588fa1c208802164c45fce34c0dba388e8468c43d73fa4fec6319a7b8916efb9d652a079947a7e9553cdea97e3948de59cdef6b66ae7f1d028d40f26e15ff6b02ade6281524bef5768148ab2fbebdaa519ec585853c587bfc73e2cd228f6586fcab22635550c42c4b3eed3d11e493c001d3eadbf275f126e18572f98563def28e393b8b86e117fee101703a4ed2da67852671bdd52e8ca16053b635697192f37a59cc3a022a3dd7e78b6a684b5a6e28251c2306616b5c62f9c504c33b28b1a5d5af09ac8a9537fef7050a362567334bb7d178598994e281927702aa6d748ac8d21877179fad0626da81cd1f873cbdecc24a06ba84b5c0394f8ae33d105c95b134c1993ef528045d1a0e959cf13588d60649dbf2b95d34d367582c052a08f14d0f75fab2e966a0c42839fa607cfebfa129438a64edbc8dfd390f1679a0bfa93334107082bc8a26617eb73bef3aebb6d2bb1c789bdaf35aacfb7116daf3b49a88cd98d21a1a0d659cde2e3335419419ce4ebb7c0d15c2ce75780e1877755547c8734e7db8be2250710e8d38dbe8a7ab7a13913f58700110d297a38f3ce6f27438bba3ed8c263ae4ee6004f2a6ae8a6ee8c6ace9317806829fcfc864a9df38ee0dbc775481851104d02e915fd77d6e92fd196135880237e7bb60914db69945a5b2cf3fb7192c399e78afe6bbef4c0de6591766c2de8ecf2c23c9fa0e7c5da11a98787aaad53c9e7dc95f706e53c73a90081d01a78a8772b23c8103cb6b0f4728130bc24b59487e869cc94af2b74779e586f7361520d668af0c0653b999d3d653778304986d95b667b21038ddbca27074fab1dbd1f5a745d3751f71a1d3af80f55bfd99c3008c919d14dbc9c13d43432ed215e184b886afd96e6db9110507b34741501e239c8b3832083d7f9f009a9df2c6642db4bd42b733b8444227ff9ae3ec3ab0f8dcdd2f0e0b60dc7827aa8eaf19e74e1e29dc2dc117c1c1a57db73e5b9ee35613172fa08bef9e0253f8e19d124867269ce35bc12de7f2d56fe9eee4b68bc351f833502f5151cd9832b3255962b2988c6579fc02b6d23422574e06a46b97e3a596a9c79fbbb04972d945ea3a7fb2346349c2191f33ecf2bacf6671d8be226245cdfd1ff35a5d3d6749d110619d6fdf63287c8fc1b67a91ebe593d42a4efa9dd53b7343de00ab6c59c6f119fad4e6f0bdb2b8ac7010b9bc6d662d1b1926f55bd7d9bb34d386b9987b4fed582d59bad51a17f6ce92b6f67b2fffdc96dd3c6a1cef508189949a0264bdbc929e5d7db858de5d17c8d6f50b64505f7dd0f445c6aa0c8699166fd6c82b323203433bde7987c7fe225c83d61355e602e2595a33387ed81fe02cad27f32bf7f849f0e7346978a8c20e7dc52b2a37dbe7378d85c71a9079765bd9d04e5287ce4eeb20cd38135f0a992efc2d17f092a77de7a81f9fe0ec0d35ab0554f13567afa2fbad9bea2b44da61240a4ebb502a5e79e698753758882ab466a798ca0f10e51e5a818e956ee28eb4951e29d9408886879e499ad391afabba7ff6e2c1b0e5ef71e896e1fa56a5ef1455e55ce20b8c092da83a3908a05071837fa40c41574408f2e096f86d2b83f38e6f24162df2b33c15b6f291c751b3facfb45a9d7e8f66fc2cea3284ab34de9d59386d9f4f8d1cd5a79acea230ecab932616b80b45bc99d4dca090cdbab5da1621ceb87c626346833e0013f9617b0f37ac2e39e709c1531dc402e27fd6bf188b2ce09acd40496ebc4c076d99223ada1a7b1ac69d297ea8faee763b437cdd593500a636c403cca7bee214b5e248eb3f735624f7166a364db2b200f12e6ab5cf9d51c9a71bd5c4a38dfd8a9d1f166a8d224756decc99b14a1a3cdcadeb6f359c4c8bd64924cf2373a4f617d29b476155a7d9a899e37180c5678830e699f262fee710f424448fb0c0a338407715033572f46be50d06504153ce9f2c82d294ceb051dc53d7895cea5fdb82b8b69fd0aa54af2b96c9b8f30a12c881984c9b4839adfe0d43280df5e84c9eac4eb591175b928238842deb636ba1407709fb4135db0fceb82feaf194a5340714cb21354c18c13d393cc80a307e55ad74ad114b0174222855535a7c1f63c2759877a628e6e87479f5087957ba35e5f010945cca5390c135814106851b4c253836a0a3390f190be133fed260d42117d7f679db7d305b8abc646f924244c0ef6c82df7a57c295c7cbe57abaf70908c7b01fe181361a26833bc44f79cc533f5a026284b6bfd778bf9a33004746f51761eae3712cb766f5751ce3fd21f893f48d05ba22d5a2b552c801e4b0f50bff0e4d0f1e74c900c7a9953354312547c946a00429d65dd7748941fe7b6a1e7716e08ecbf7eb30673478c4010213abf5e70c030743398d746c6cb25d4d47646f62749a2338bb49e21302ca80d6ada9bec1c9ebec3616e453080e664c077b232ecdf257844824ce9c790df23c25cade74cf72ca5c9f174ee9381822c17de270802496e954e36a21a5e1b73a1bd29db16e762d965268c8874debb811e3765de0460247409fff0b1f6f61d9f8e21dfaadfdd5469d72d2391e7bb083b68ff32d507c62477b1b73805cb76736aca1b87e47c346b5c0ac8953e25a28938ddbd2090c6e352071f7bbbd4764c4367205660ae1f0f254058949e0c45eb51e448f7be356af8942cd117143dad8bb044705870f059253fcf2b01dff90ad1ad67d9744cbb3c3616fccb11d69c10f3723c7cef9e0eb3da9a8e1bbf313b1941edc1a80baccb2d1953138c84cba25214949f10e7f1a1e9169ff42742b0fd36026333c76610584cfda980b630cdb46cedad8d2de202fd2173bdceb615a12528f73bc46ee9eda408131aaca1a4c586ff49ba695168b25bb3e32a32df890c3a50ff384bc2323564823bb3d89252dd19029c1598461fbc62d66d6ff629c408b19cc6d7dc03078d41255a2cb0029f7c070172e53a916a031d9cf03f4b26cc9b020a73a0750695d24696277f85e18643de34343b6d94619530987533d61c81e0c385546b97d81d288f496d8c275a550d8e59d5ad4b121b36f53add37ea2e3bf042f3b9a5854ebe6ae058d6a60d373fbb1b8131846fa48afdaa582bdc16499472dec032e43f31c3015d13b9f08f84c15fd8043ced2d51c81bcf8a4ee924e9cb33c55f32fcaefcb98eee1f3fa7e19c0dc268cecc3e08028fcd19a2c0a09734e5ed3180ae0bd777db8c0c8c3745e51d69710cea08fb6fdd92b07691eb856d1c01e4fdcf336cd3a887468d8152a754c7abd4b4e2a4aa6695ab0d7447b5eac367cd4986c87950ccca130e57d74695e6452c9c664a4d4a93882e13e1e760283734ce564986a38a6974644d1ef9032aeee2fc376be7b77d3c16a9cd58973b2a1faac9d77fd843a6eb02820f63f7f9d063508dc07608d1933c88936d93ab209813c965cd9d0dc38ed956b5d4bb111e230212ab1be13b4ba4f73c73529f1eda9d8d9666c206bda440bfa0366226f3bd5b432ab078bd15b80e630ca77e38e405a24a0eed69ebdb8a801b682ba83e72ca369a4cedc11b80cb3ee7a81287f808d9967e632f4aa9892031a59cf3559f2bdb5ee5337e693c8c0b5782be594196303af17115031c59b82ed0b51d47c9f60ec5cf66b6049daf4851eedcda42f38eb355b53e606dbf4c69a433c9213f862ac4e11b25147b833a3b5ef3bb1400567626679a2aca4ccb97f9c2cca802af4c5e2b0654374d32265136383f3e9477767b14a99ac02e82d571f95e2f57213e6d1fca854a3bf5d221c31d16885d351f9061683ba9d74207a91fdda35c01e5701fd543e8ccfd2942f27eb0fb26b80d3969915af87d08ca36ceb4b60219f94b398147a49acc1972026e1063ec985f75215145533440aa631fbde28ed0d28e3cff7f66c9446ab713fb5584be8c3b0915799d91a4dbe223270d09cf105549ca1bd34bc0949fe86c7698bfe66d100ec66c8e571453d766da2899965a5641aab99941710d94f70387c049493d7d9eb82abacd1c7cf09deca7ee1e4e0f1b374493f94013486609f60f57f53059c8e8630b64d628deabef9ba7b588d5d53c7e428bf5c58974ba54c4d1303c24cb11741117320807dfaa631b2254a95bcfa982ce1ae4726eaaed870eb887ffb37e1047e0fb859d062d6e17219e06a7799ac08b8ce7bf8ac034cd36dff397ddbd55049f265c696d11d14d541b69290e98eccc123735f2127654df1ab7d25d5b0139ee41e56394268a5678e59b4b50c8b896ea9a0902b0a916fabfb3fbaac520fb5e0d435faf116c675fa65a46e32d15e487be6f013037e6453b0ef0dd6abeab5c0d21ddfae05c57c79fe725abd8ec6e35b56e3d84cdf37d04e77a4bf3bd927052666b69946fb44ed3cf6fd7d917fef169de99a76f6e915643a0215b1ac4a27b9ad133e92b3f7120b1bd57b9df74aeb01ad6ea59c978d2c5483906c226af98414fb862d0d694985f834ef17b80ced32612979411220fffb397e8c660b646375093dcecb8c36785b764a2dbac5f604c0649599afbb2a677f9f84e0c9503ee6f2faf2b996d1debc97507c863420e52aa57913c1185d8aa7ea4cb9c4beee92473896be9ac7b7cd664d87b934fb2c5d63d3ba4d7944cd9b45ee30282148c1b670521e5700afaa82491a64577f3a25668cce448d1335d34a0df4b639a23b64cda9dbca5738a3814e13cb471dc4f5b32d36fcb97e555cbe57cadba1b51fdd87bffe0c78c151af87053b89506900f1f99a5d41620861ed45fb0c9dc646545971df4a2636ae88ee95280e62f676fe1043ef84fd06bc3a71a81ec42e53c368b256ba503e94deefc203317a32e7fb319f81fbe706f3c1d0460a1a821794c2bf9d903a76cadaea7696b7d1eaa767741bcc7d238177b63080c95d2906d5572d5217537c587a324c2a8f09872c15f14584c8cc49687adcfc0ff4c9244ef1b864e91fa6bff2cbe65cfb1dbb9a634a0c7778d99f71e42480489cca17c671c7febeb15b94ce8c5f61d95cf868befdeeebc5dcd1565558d0af0ab872a3c90086370c94289dae98b5738019c2cd95233a7f4446644bdf4766c8d2ffba7eda1141a65eb2626a655a58ca95c1934c4c87fafa2dfae75aaa55d67007fdd096d649c87f7c5f65825e68cf8a29aa0c191cc5380cb57e71fc9b9e3bb1009c3f223c42c96cedd222ecd250664ec811b9ccf9ec895df959d84178288fc0bb4c6b08e20ea43797862ff013ebecd31fb6868a5058981e8ed022e627f1294b48add20f267dbbb0ebec790e808caf042f43698ef1dc39d6b85280a5e2067da24348e52882b15222812956fbe3c60b78212c68fae88ecda95e1cfc9749347d931581596c92057c86762b2754eb7694f6a8e3dcb288677582d6911ae83147d2bb3019abd7b6f4471e4e40dafe762ab0738bfd78602f508e55fd00a3b33155666e05cd243035c884c34fa30870628459e1db343fb4e9fbc663a479d700810653ab83ba4752b1af9e7856a3cc28ffd92891e5d2d5334f4fb2f68a3243d9858599b0ce01be02503ace5b6c83fc6daf9c6cf76c92d97c12e450a05a81150a8ed291105c9f989f7920edca64cc940ba89b0e8adb85117b1649a560076c79d238f9e4d5dbe1e2dcfb30634a95c4440b0344c3363fb08520f64774e9de7301daae367fb0ede539ba9088f4c109040826aa93de13d261553f9b13280ff255242707cddc24d226c38f8892aa30286cb896a979f7da8a71bd87a6832ca0ad33734ac83a880","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
