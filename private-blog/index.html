<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This blog is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                 <div id="more"><div id="space"></div><a href="..">go back</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee67c8e296ba03a244dee001f196c7be2fd030c0351704f95988754f3819a6c19bff1751a90d0f522e931f83057a016d349df60ce1754ebeaa0b6d300d3dd3e7001d7fed5c859b42d0e237e9bda8afb35cb3695f033eecbe0d9fa6722e63178ca201cf595f4e124e7a8fefb09d3103df171e0deda11fdde03876b8179291df2ccd0ce1199f6d572da72732cdf12581b6837639524c972a611faba857e0080d1ea8e4d36e17610d427330240dd8e89bb6b59c789e7efa48e100c17066a97568f071f7c6db2b531e18ed0a2d196525630c46010da87ac28b8c03f65f6f3cdc0151ddf798e5596b0f452ab90e47a3cdcb7ee41d105490e3c7f64105e543352b766c1b3c7125fa36d351cfa50d22c68a7fed0429f8f53e4ab85f5320f7e3533b2d09967d0cd2fd6d9e0764f7ad0d89ba923d0a3e7c266db2ebf3641ee4d889e9aea85bed59107a7ee12b956dbfe21d37756f8b0e31916acebef15e2b7fd7dbffb6ae5f9f0629713f03b8e4bbacc51c3e9f1361b0f7ede63eb6ae47c2d4d2f6fde7e33fca23fb41cf25df942ccc26237bd3af38301868180a930613188b28e434f2af5e5be2a1995c7cca88241fd38e46757d904ae2e2f6ce2f058e49d560a4b277689ab816025aeb5c1bd22befd3a762925f6ccf38f06db1c933abe9d83a7fb88022e29711400a6042ab573c385e02fd4ccdab5987d21b911b1e6e74e6acdc6b47696b9b554af43c0e392e174c219930f9d961c4f5780d83ceeb986c9ce12b11372e041be3424dc3e66e5b643ff78344a2812325ddb256db11864c005370eeb758ded0f35717c5c6987e9da403c62699c0b990842aa8e66ce03e855869808fd69338286be053bfda32287e61b43d6894a4b172a19271687e6651f0e7f689efbdb6a9377b7b5f8f94ad153e4216fc82cc3fa592aa94cf2cdb05a046ebb8e3c74c9cd26142354b35505beb8b7e16ef9fa5b4d16a8c765e444aacf854374ba138363ca5c5966c5080e46c72bab89ead4f67a970b42c2d21e936fec37326fbe58c8977c3355d2bd7a4eb75ede718a92c03f25f867f2a01900bec623e20e66cbe76589a0109a6df5b76d32dc30581deeb4086e3b24b49162695b8b2629e3c8066bf19c54f3f775c3fc6fc7afa80d82cfd0a7ff5217fe0c3b1cf700ae6c65259f9eb1414940522bd8ea480f4f776809f8388077c5bf618ef33289919592462c3b2e9cab0211b1623394e4ae2e387d3cefd88f1b972849409047883a603e7c6647dc38abb709a8b1386d55ffeb00be17b00c79e512fcb343569eca81bf909c2e93992636c8297a61f8671e9ff0a2824b7c0abc9707ce0d1189a251d13d70e97accd1bfecb444fc71d900e4b13d38cef4713287031dd4b2e716b82a098ded2a22d20e6cbf2325fc05325f0cb6c1bf71631b85c554a7f462c6f7d6d4d67490af23380516410d6350eb7e846346e4b95f7d94c58787445b28189439b3079d1ffa584bad806546c76c87574157e5262a9e3197b4736c635e6dbcc482cf51d4f047e5750e2ff3be439b69062b07b7e589d24af6ed555e1c7cc92f1af0c07f38d44ed0ab7601968aafa52d821dd27137386e49db2b16d5bbe246c1e351a1a4d62ec7d0d75e760ddfb1366a80a0e747afb4c2ca91c72989d01deb2cf6c3d3705a86d55fede979107128ea8b4db9b0333f63bf75064d2e298179f29b6af14538bd14b24cb8de8eb476e3da4ac00e57484bafe330684ba111dca40ab6ab1c093e17d02f35f4588019802192b4a2c8f58a3c6668c74872a34683b127aaa966bee40946176dcc23f29c8166876679a9337bd9bc047c57ee3620f855a967d5ea0f3ab74536b65bc2d05e70e1688e5679f6ce0c1db99a5e41bf52c0488b8c2feffa0aed06248ca74029ff4c8cb79a61042b42fd2958ae406ebd7a34f3e5cf8bbbbdb8623b2fb3947049ba7e59fe1664de171bf9c9076fe3576505e11efed80bb32b0a3e92af7cee3a52ed7b460fd3c0ba8399837f2b51bfd441401a66cc649d9b96b7bb47a6c2a241d272537b3542b40038b9fa16091000a3c8677b506c4452dbdf55971fc06c33d1e8cfe0b9172ed43b55adf6350eefcc62c7f01d95da1b2675f74bb0d5cee35fd2fc21f62dab6423ef6b111209702b25e8f344c95af26baa0c36c4274c8dd068d7cd960d5e19ab01258e2173f7652d0de1204032059f460cda4d9ffa3355af55f937d6388ee790490b1ee21ea777594309a8be185f048c58a9237308398a51a2e68b0de2a6c2a9c2dc8cf2b72b1f77b3e0210b77c2e82bd26ab242f9eca8988c4d56a15902361ba5db974f92c056c051c90ab5fd2810b540ff4b72d7f33b0f94bd7c76d1b96763b8e987a22dabfaaab889c72597eb404e1e154b006e9997b3f51d25882bfd2b0098df7b90e0de90113da5ef3865d667da3347c59555bb73bba214a634449b6adb35b6ec1bff696eb89f175d4497b81629bfae4baba20de4f9bdcd5ce2ae2046c3b93af5d8f361b86d1960f6f97bb57213d173a96880ad190f17b2bd5ded9fa06acbe90f58ef809927cc073559be13cf5d1795d6a0786691abc7afba9419e2704e4775b088fd072976ae2812f982f3391d6d1bc394ee84802adb2331d9085bff512407588d1292126410bb4ba61ba1687a94c111d0460dd6ecc763adf09cc3dcd4fe0f8783600af3b986441064fc387f7eaf01fe43643a8dd72a016c9ea09b954a1a058cba063314445532a2914de0f8b6bec9d16d0833f4751cfba885c69be06137d2749486ab9306fe6ca4fd9f15991ac0510f83a5b1352923f306c68c15088717e16d16b6a7c8dcfe390c5a64dcfea2bb08298eb31e48818fca0a933da4cea8fd9b8668818734b14d77fb24260a40ef8eff286b979d4d8461188b243de82d71353ebeaf2bd2348e5c93652afde57ce43cb0b18097adc49f345b5164c149d35f17c39f10c344cab3e92909a79349bda6ec20f64c1cc462d7e9bd01cbf24e7b5a520b054501bad5f152e35167ca19dd43c32d6dd826a7236547c0c2d74bfaa350826ecfeadcfb6aea93449bb46558de987d45f888200a1b0e2365c87255be658eeb8daffcef7da59184885eaa2d074ff6799f0753b02ca1ce279e979b60e0eb849910a49edde8fe68416e08d3bd8f737027e5121c534efa84e215606bc104479a9f5ec30bfb12b1dd5dd0fd386d4b52374bb45481f9639fe8df69f38a3a5bf3ec20b9ab0536950bd3aff65c1fc285fbb1e208a5b3f85b5e063e9aee3de66206a093cb971ebb5aea92ee83d0157e6072ae372dc20a680122d9b2768156be5bc62d20b4199bcca30fae6fde5af737cafd64b8b80699dffc9df57bb64931d8f984a3880caf82e0c810515129ba7680d8ffba6a49cdb04af1befe1f0469e37891e4dae5f8bb67ea54301c65f364e141db397294c71f45abd3b82963875cb0ee2e471413a023c0a879d055650d522fec29a292032d5295b802a01de210fa4df962d1256e2a3e1850f7b6faab9e371a51cbf53b17c6f49e07dc5f0a81a24090075db8018ba35e97c8735fb27cd5759ab37c762afe08667298323cba8b6c975539487102380cad95c989c5afcaacf20ec96f5e4396eccf4878c5641d8e1b6f105edb5431761cada39c7222d9752cffff7103f99803d1cc34f7fe03cc722e41d8aa963397a41ad2b1f1ed3e623ca7fc696b71ee0430647d9ebd179c73ba5cf56dff04cd1fb9240b764227e4b8592d09f89620a3398df207370eb727e0e822d69a5b5fb5d1d6f28c037dcda4785a740e36eeeaab052ea36acb1785b4c98aa90cc3abb6a81caccc231e84f40e57787e3f4002f8ce685e873c0848c8ca9618c3fde0333192f15686c6f6213b772aec926c09d83c979001a54d4d0e272d6b9853755515b4a11bad9ae134b1e7db729a5385c501cf8937edf58e457d5a765dc8fd93c09ef357937638f157805b11efb515db91b943c32e20a6cd88b05d94405b6db669abb6772e50bcd32fe1a1f4af7199eb245d36851a9a654297d62fb3ba87250f2f2c6f0762e84d36ef3926d26027f20861f78e59f8c1b6f4d86b7257185f43cebf3a36987b57067e77395092c2027b7d6c813bf52395ecc25563d74e765b697404e501c640791a0b92744e5ef4b66d8375c9d229ea2b7c562e90681aa683de46bbece31189b3c8c9ecdf982083d9587b7ef2d702be95f9da0e1b6c80cc54067c6b058a01b3db1f3fca7323f4b3a9b49e5dea154f5656ba27b0eb1c9b69f1154be5dc8d274b741ee668690c5e12d03e5d1d096967f06ab5fbfd869324950c97c08790e21093c5178af2a7813c303c2145115ceb21b0e959ddba69fc0c8b6ac9f796e45adeffcb5b87581e66b19647b5959f347b848e22b044034900bd773667225df4a8cc4db20c4b8dec7e05315adb7bcabe443d37ee0bab763ea3ce6c0143a4fffb87da8fb8f1d7e9ada07094ce4b637cc4a647b6a0896d79e576bbede7996bee8272e826827cf91c3cf09fa258bdc744efc71ffd8debea35dfaf0757e20bcce273d218b855f8887bc9df2e6bd569e28b03801d530b8983a7922c87b2ab73db71fde386bc17ed4b12aa087f86ef937b197d763a75e4f28bb2b853d770ae6421d3d4e4606e6c3edc97f0b90942666cc0ee4f001db831fa2a57141216dfdaf773cb23352d6b2f60c2aa9f87293866a0b4481c9d479d44ceaf1bb6b1705ec55cc376d50d65ba5f1ea0a1f81eadf9e834b5809ad7263639a41825ceafca0b5465fc6da27d23cb02d1c9c2210cb7a19a62ab00915f6f8d59ff61fab7263a7a2c15586beb6b05a2755cad4098fd3c1f2fec99a9fd63e8f5960cd5c35e7769a7d41ef5f97a50d9dcbbd1ee556f39219e64807b8579555d027fa1daf08c5c4d11fc54c7f2f1663f8181e7078b555c05a104a36b248aaa91010e319a06bd02f6a89e3fea104d7185ee8680135d0ba46ee9bc786b33e4dc65216b4da54c220c144b3e7b5975151b119b1967988fd27fa2081df236daba1b09d6762d18d23fbd68fa0f65ceef4c400345cca4e5b9226e3c9c68f40d462f6a56ab310706e561a944f7c323e066a5dee1b309f6a3b56233c22e09163d7d25e4cc927c70e6fcb2ec5a1acd0f75880398b18b9a88aa1f84cfbc27986c8b207422c39375119ec8d6787ada0dee8d6128fa4718400ae6ade4c887c36c62cc602a722e449e0765c5d3c97b7d732849f2759a4d9ed3c99415640816caab0753dfb89bc923dc29e5896a69787649274daeafd8ed8c03cb0e928907f9072875b82544babb263ec129a486717235675b8662cdcf355eb3f504bfc7d89ceab9140a9bba6cea9a7e9d3f49f8a903ca3201b7728bfe6c82898f892395890503956e1301bb27a2ad1060ed0f3df6320a00f534bc35c1bb234009ca414308af62bc48866a82ecb86392af9878154579bfff7cac4a266d9efbacc5e50c1f97bf8816b4f6d0e8324b15251c01d378a61826cd4e5b0c289c5ec114b81388ad7af7610f024c00cf3c8eda6d8e9270199ce27caec9ccfc4e9199b0a748c645d78ed973247755d0a0d096eec02a775a9dca92eb8fa95edf92c57dd57d067accf231bfe551a974fa0916c4ae796184f8c667a5f5b5022274f57d92d3bc4528bb8e3fb7d8fa32a883135d53fd0ceae8aa20d6b6a79a10905b08ba999468efdd46eb5f66d97996b6f7ad4f6dd696b76041be12868e0fa7cb17f258e40565afb6a31d078d1b74d51a366006e9381c31dc5fa95bc129f2e0494dad46179a1e29ea4fe23757547687979fa8bcbe11480fc4236e3cac91288949862a86137066bc9251bdd92cb954ef2250c78bd7f382c09a9017257a7107d7f6301541d25e18b9ddc8f19ce7d23bf077b41c72c801ff42801e10b412f4d0f8c9a0283b7ab46532a31607e2dc5edb20d8f8cf8af32607b5593992a040ed2f23d648aebc989807618941323797ad4e09d749f68819e4a76605d58c813cdc5d34cee0ef9b31712957755ad60dc294ba16d8b8a355a0fc6af13a4ae23d8407e09bf99a4e73e425e203a02aca42e97667655f6da1d3c8fe9fd199ffa1ad68e279a6ba4f2c39705632373ed032170037faad8c084c93b543e5fd9d7daf840e8859ea1cb0df2689f4e16296e39c595a32816cb4be02743cf09e6088c99eb2ab6dd357d39c865385604985266d2368ed2d1b45f3b60cb9aaf97e1216279c17d2e6ab732233aca665a6323745e7ef3e9b42f4b30ef6632ab454923395185d724a63f11cf30e81f651b1befaf298c1a5b868dd759c2c7f18e712ba02a2ec3583b3009930531573eabbb29174222da2896f18716f469d0fabe4ecdb4e902624883b7cb0b727d626aa6a5eee4ac64e1a3e4ccd71cb2149c43a0cad12d58cec766caec11fb50b011d569a1a6eebb9be7c080f39ee027a897362b0448ad7805f1d1cbd444d767cd20ef5a74f201c48a7b2face5498dd374ec52dcb985715ce7372bf878671ade9088b36653ed97abde2721f77194988104ceff7fa3727604802e71bf9e9e44bfc64966b125f5f949cdb426b7d633cf75b3d82c638d74ff4fd62b0ade930d17d478ac201cd16707e7d8a44c8d1490dca1e43047d89d48d8711d26241979206a8fd6ad5ff73c83fcf7f3b3a775bb2adf72bd06e1d51bcfec20dc726684cae438fd16f0d660260c52e3fcd2bbde287ad5cffabbd541cf988d1f1e76583f5acf1ff87113ce3678ae46caee56def0ebcc6ceeca24d90801da2652b0eecb9d2e8c8c06900ef55e17c5ab55080271f1615d18390f89ea23b51523651484737f01635f8e0f0ea837ab73aad80d2c930e72b7d0a041ff9346dc219988e19d6b4b1ff87a9d300fab60eaa49af1c08633897a483a3ea25080f2be979109a234a8d452c5d205ab6447cd042a2134da21b95d4ed25831798e43741c81f545bff757b1884448a8aa6afad780e48075fc17d4fa6e862e38bbd7d140460ee773fb60cc4dddd3b4557447cdabb8f55b1bbe94cac5c0f9e3d242c181279e3c3c4035e737ee7ad0529c04eeec9fae00dc660bf256ce7c5b666b9994da1b834e63937ce7c548045e5104250ca93df0cf47301322868844cdc1ad01246d2c8d4760b27f07ff6966199913dc9590f94383866bf71db43429e57640fdd275ee49cfe0c6e4215642ecd9ec2684a50992e9fc9dcb96429bc9f92c914cabfc89df3d0ed9ef9ef2d72d39ae3175fa5213f070d36a244d81dfd1d4db8069d7eda57a2f4fd862a1c8b3d7952f1b7ee7f099fd66982f6d94358b89814aeaa8f7cbbaf294c183d4cf0fea3fdfee4f74444057f7448beaea1b1ad85a2075f6d58842305ba250ec778e2bd9bc83e5a3f6c3de554d25b4a11e13e7e97654bf5534bf920c49ae9c7df4a6398b058d593e85bebca3a786d73c60c9279accfba3d8cc5bd669488059c5addede769d720af1f3aad6759bf3decc035078aa60ddc349a3335add2ad8d99ff8b3e79ea5740efd42e9215c23f85c7a4b501e0eedc1af2dd19ea0e6d6e110576fed2b272fd731b1ca77a737a39deaf675ff8d3429b2fce69b31b5adf0cd6b368cb725ea00c43f1b1a83678a71685dbdc14b808c1df9e49c2464e8cd6f61ca031da780293d233606bf1de76ae8c1d93612764fa58b1c38ceaba296de84f44307e790a9bf4b52312fc404de43bde3c2ac06ad5b2483544f92ce167060585e6368d007e9ae374bff498ae22f77c46c1e3a65fa37ff1e842e404c4b2bdb99be0d6ca2b6115f3c9c1754fe989cc52ff49da0953b718947b49ebecb028dbcd68c0f3219c10563e589f8a28d2949da05ab463d55a6aba0740144a80f5b30b475d689073ddc09cd79ea93b2d461d15cb47a89bf95997776175f98ec8c8e6be9c91ea6fd761dc7b190d934e669da1a9838e37c981d14cada7af71dcadc91a00e8d0116d324a18d6526b40956ff3d279de6d5765143e6b82d1901f0909e0b7192e7b5365d4a4ddaffc51d4640ad9bfaa1ee93db425d4945e6fdc1a20885195753362798b2064397ece9902f33204fa480f895f4b5a3d451aad753d05a52093b0a465ba4b7daed2c9fd092962a0ccc64625c80844f69ab5108434b6ae30185587ac1f2654a367fd6d36992e4e7cf8f431fd96da107900c826106500189e1917ca14a0582bd6ee82b56c6e24831304583b8759829ab227360926b92aa4d74ee745f5addffb27b278f147859084b367fb4f4f2d068d84841b34c1cb87e7762565e680ef8f464d981a80b888a970f1db842cb11bdda3f89f0e4f0f168f79c653c223a6dca6e0bf3fec7a60eca6a0603e2bdf4506e0b17ff5c11e0de53f7d3035e076ebedc47df176bb733a8313be1f3cc2b6481b4d6fbb9823be803e838ef54bd14305fe9629f3ec6bd5385bd92cb9be965f4a6d481e139221bc4797f23693f636b78723dab9cc01b579cfc5a01580b49e00c073da6c50306844d8cf135bb5e86570698a98cd0954b4cd8267c8b5642036af7c02812b92135883522ebf330e5dc4ed18ce67e2304ca49f72642769644289dcadb6c760920f0f4333465bc326c976e550411c6aa688ff3a87480ebe730f3eace6f7b0ce7ae6c6596e8549ddb3c6666e6e3df2bc8655dc0ff7e1c23cbc40247f78d1c6df0d7425129a390ef18eadf8a80b5e566dbaee243f87222da36ad91fdc5bbc0cc34026d61ba045777e71d905f884f18fbc81b97196a9d7918727104f69556ffa9529be7e9ec3e0575881c8fb252746fe3f3309d1dea3811f64a1f7226c246621cf0dbe4dcc8031269934326cd7d88e9b95f1988afe39ca42a63d41ffed2f1106e8fd748c846180c6495210bf65401847040f6ddf36eaf2406dbda6b316bce1b84f240d894ac81ac6e7ddfa14f92a857e3fbe398ee5cbdbe0b0b855ee7de806b01e3e1f06a8e980550afe2d30c40","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
