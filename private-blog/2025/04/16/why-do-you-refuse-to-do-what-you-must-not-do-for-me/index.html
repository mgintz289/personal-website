<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"86bff864007c0455908c4d487838fd4c829c5c159f1ef04f915cfc940df79d0dd74fa861a10acbc888909e8641b5906d49c4abff15ac1d72147de5961a4eb53e47a21592de8018a2c711d5ee752736a0d20efd429e3d9d4f3c84a85484a5dfa9b44a728cc76fb7eea917bd749b8290cfb2cac11564b23ddd0eaa26f1934ffc57cc6f0d6e48e70a528099b35389946f9e73bee85d1d734bbf049aad0aa51d87e333db635e1eaf9f550de968c6fe56a760122c63e522b932cd684db7ef5e20e8fc5c8ebab3e9df53e55747cac70403810c5e77d40bbf57785b563228ae8d9290d8d0446d1abe490c9b1b768f838fa2c807c98e6126d46a28fa21656bada83a26421f72b41aac186e0bc47e337a65f187b8c43163b72f529e3d635767b7d884e5e7004ecfe0bd1a76d64c1af108103cf6ccf8332332f0d522091f988e44b0579a464f321ca6bc6a0c2f74e7708e7da6f74c003a1ebb78455ffbe5757fb1ae7e67be4839ba0b271f63632f02a0a27173737bcf002a27015f5dccc4e5b2f13c148f16f9ee8c66ee8bf35cd14fcad3f62027eb99a0ac941e754960af8518668302c0872ed58dabf6b48d71086dc1472b443003f8ad94c58809d42a47cc26f0c124c2bb437791bc9b60d5b0115c65feea4b67c4858f228446fc620ea670d21bcfcfb942521c2269f14c140f386df15b0568947099f9621f572d072e654feef82c59d67b38362c3d44a7e23f75e3ecf6b67fe239cecda07f534ce73ac4671eaa0c5ab776d0d8ef80134f3b5327ca44b455b344113ae4ba3b1040231be4b5cb514e9ac89e34fda54943f14b245b18022356a7759770323520e02269eaf47bc928240835c72717f2f42fe63f310836828372161f2c2602db90f7871d2e333158e3c0991025f1edd311541eb9af32890ef7599b84dd20c02585dc8908362961216f5541307afe7e6b10e9bb9df4f7d86fbbd5b58ff2e5700469cf4329d0330205392f8995bdb6c5344e4470f505578c33fdd42f44716c1b716ee57e760d70da6b685ea78a6e4fb11bbec7210a028bb8874576cb83fce29143a2e190af9540fbb4711a5d229899c9dd7872ce19a2371e76cb3213e506308d1672b6df9b1664c065df8fc688902f3b29ad6539456bce5bb930920eedd67bfab4eb6561940c919596df64e1764f84699491f2d21831bfb1f607d18c7988bd74713d7d49ddb6fe6322494678bbc57a06f06b660a063b9de9047bab3c4ba606442be13f784ea4923ecf1b8b79d8fa20321880796ded9371d4420b03cf617ec893f71292ec8b3e72e029dfc3c526783eb7eb0d77a8503d6cb3b07f162a3fb066000d85c52f5b906efa52ebb0dee33c33709785f5a5a90e7aa72224cbaef167af2a9a4d763ea34e52af9b36406c9daad768249709aa6a57da4eca88ad2ae9338fb1727c5f458c72cc0830831129dee71b9dfc7e3f81e712b895cf6931255cb28435ff3c4f6c1e7f9aa2f8a44d6b5bbd5166269248ab0d62e7a51cdbd37823485cb2e91fcd57aac0ec8206e349339b7e169740b281ac1f126b6167c07ca9100853ea8f4198823ed77e42ab6f3a6d28ef03b734f517849b7e24bcccb3eec6b41834939641afaebeed2cd04995547e814dbef99b083eb3151c404cdd949ce0909ddc3a2baf13278c70c4fc119a63558d75893c23bbeeda346009d3f92a0e40b9f87324e402d358a81691a766d663f0072b3833d3df4cafaa4bb007471771262c7e17d37e29d2cff413b415061cb6fdbb3aeddc2bebfc1225ad909bb7596c416a221ebabf08b6cc33ef31f94999976cbaf422f2d642738cba64e89bc104c09782e727d9c9e187631d3d5c1d3f4a894a859471f94aa8519bda306f5ca0f3965906881f948d7692208de0b7ea073322bdd7cfc05691f85a360a7d8e609f36f2b0b1efbb363021224a2d2441da7d90d08ca7cdc5173cddad4ea4300e1d6ee1d9e1fee70fd31f1ded13391da262ffdbdd30d31b2b3e402f56aca0a510e0c3cc3f669962a917925955ae9b4a78d4c28292c3c7033b417aba44593184954283feb52531d2e0fdd46b24117cb32d868f0c3b1517086c2a8c93086037327dfacdd8482fafd31dd095a17e8fadccd21eca445d3de6b961ede53c7090e1c252dc61b0a8e7c444e0122b33f1443bc43fb850531270500fe8be07084bbfb8165f72bf8ec1fe3e998891bf8b74200b89e03d47e6d95296047370c3b1a2627d44970abc1b9cc97826d6bbb698b0ee88bc37749a6f651aef45fd3da15f64eef5ca54a39677f87fdbe3907a88ca78b735dfb0446c8a04449728dcfe24333afe9e8a86e380aad1266d3ff00367d602fef5b2985484734f9850231043490ab4c7a327f04f1affa160a8503269bcef3d6387c78d6ab2b45af659db2ade6d0345f2e180d725d1ef427980b0bdd057919b84a525692738b804b33ef17dcf605fcec0c021b6f97f6c7e838e68fe1f1accef4629d4a41f72c17afe77c41a38b092b2a50f095150a9965ec79667f2cbf782cc506a71965e14950ef2aaf5c47bab8520a829081590f0403a901befd22a5915d208390653cb561614e00ec5af593f3d6999005f72ca2aaf6050fec8e255314c776241920bbecd0a2fc820b7937661289c385d6b5b8655ccf89ac54c8a296898c3b57737916f5d4b2bd5127d144073a2706c94ec8f2583484780f9bae51514c5b26712d328652b2aff7371a62c8a228162385c360c5ea99b174cfd4d7bbe50a8c0c856e9dfd31e02dce61da44d3326eef70103aabca7b13ea46bc742db8a9632f6b625768eaadcc82d3ac724c9dfc024888ae4e8a5c4fbebe6415571f50fbb0ea3b9d048b958588135fe2845a28319efb019347ba949115edae15f3d4aa221a235b9f6a0ba5175fd1363810821ced2965c32e4bfe465e27fab0e58ee930243ec2f9db7efe987271378dd6dac5f555e8b3483bf57fe2c034d997d66beb4638520183f1c9064e5745d0d47da9ba1668607cb7b895413d3fd07423dcdfbcb5341581e33ef2e99c3f42937a4cea1b248e5e4f0a670fe1994c588d3f65f8971784dd9e8e8b5eeb83a7202af40531a8dddf549167837f7f4aa9ef534b5a69bf714b5346234c242b970042dc81088fac1acda2c90660d05b80d63467e0be7a48b83da324421cf741b48fe4fe1300ef56300ef0705f3dc36ac50dc351b77322cfe6b21fc7d36b28f988ab0905521e44f31482e79959769451bc0bc65e9fdfab2cec22de757e1277bd203471f3f9ff62207d715b1d5974d9410823183f26108524a98d07ebcad4b25652dc5154ce304f2e8b96e2cb47d3f30161d11480cd149c20bd9218c2b46158bbbf8e937171be643b3943a771e81b2f4e440c69a510cea79fcd680fa891c377c466e913991c63df490ce92de40d3839ecf490de2d38cbcda5a79520313790f490f4ed6eb3482b18bf218c97bb5dc8949fe227f48f2cf5c9f4bab29bf2774228348fe959d57de9757188c406e95446c50e63e319134af1f09881f04f6853d66cf8f747190f4cd1257791fae9b64b14ba3b2f8056bcf8a123208d1982db9e045674646c51701ab7cbd61a4265fcdc6bf9281e926cdb6a60cf9482a648d630a99af7888f89480c0f647f702c86e1c71be6fbc094942d5059c0999895093b962d77426055430d7b6f131b0966dbab1d07da2433d8428d0085a8f35dc60b6b5da97e09d818f08726e8461ef4c95aec09a69b3c54d0a6e371f915d84d7c4cf8c573ba10861e993c0b495b8fef66df9f5afab64a6999b62167cd062b8b1d0ac0b03825a37437553a8a1a8c4fd53d83b516949998bc72818d9b6b1afa115e1dc445f424b9b1273068c0e3822229655fb2c258ced60d9569f041150f2d61a1d87f80b43e6ceffb0977063daa92fe87807a8a192a049a217e9422da8362a9f6e34b4b83009dcc3abec9ec8418084cab5f266dca9c8a5fd69b51ab02fbffdae53763d6b4aaaa4e1ab40dd5e7602abfdb38849c3cdd925b96a5d4ed68169b86f1e3dd4fecdfd98d3af0e3787452c2341fa3f779954d4bcc29571de59bb9ad16cdfc41967f7150c414dd5e96921192ba4c54c4c0145c6fac1a046ff485c6fefa816e809fa45a903aa8879638ca4c8cc55697d367623b4edf8bc974fa0111403a20363bb531f3e324e3894fda2495ab9389a0a436806f9c4dd7a012e7a8d9ab36c4abf3fd8946ab22c1d74d56ca7adb1136d61c687a1a7997b4b00a633fa598ecb82aa3af8bcb56493f3e388f5dede3f4a42d35ef005618ac835d863df13d6598168396d8eeb6733c02143aac101adf7dffb58a2601761e39ab26e52e95befafea170317c0b4adbce1c9e5c0465fc9bf3618005edaa74e3eb296bb00bcd3daf534b6c9064cb58d5a50636f9d5fbeccbfaa45008d28bfbf8574b1944661f98d453c5538a0168cc64911bb3c20caa9dbdd65a63d00365839717a3ef0b8cfc71b83735565bbd68a65668efcfb4aff36c9bce420a3eebcc9472f34ba878a463043690b7619fa3e3e77aee2669e6c5d650a647fdbb51ba1367a7216f34cb807696a0387885078abd53dbc8a4b4330cf8df5fd47521dbd0af182578e3c0bae2b8c04d0fef291580a3955dc3cdc05d68e2ae0284d3209c4043b5b31143b40ace8e4edc2f744eff6cb306063080faedbc4792f15918c9f0dad01effae714473ce2c43f19e2de535fe4e0cde4be464cd9f4834a4adf26e9a181f6dcec41db926d96376f2cf94bec112d100a566ed376007dd51b3c90d2156f56999d5ea8a06d777ee68e953831da9693ccbdd099095707823d4deed9ab98f0a0720660e3c81488bdb606755a556de2c7f60b20c7f9bb0e85017c414951f072ca98f865bb3483f56ec1b884301d73319920129e518f685c6d5608358658ac4b21954ee99c65865e78ef57c9942c6cff098bc412370d991f13a2d784f4769c5ac8ec29efb65dc37ea82862b47d597cfcf300797f0d52415dcef7c1fe141312bd274599912deb39c48ae485bfb3b4d78b2d283cb067e121f0b2c94a0b612b567c3038da7802fd2e8e5e670661834e45ee30586decd8f9b1bb6b1598cc479861e0b47e0fd396b456ea78d98168cc184767e7588ceeba9ba532ce00cf4b350d0842922563f4e2651cbcde6b80623fb843612493ca1660bcb0dbfa5ba414ff9befcf88b54b530dce9973b7cd80f250ece13593e687e5e7b279eb0cb32fa13fe5282a39ebda3d08215a264718585a7ae78dba3e932de9b54506cdce0ca765cb773823c0586cd8869426f214f0ef687661eef7b083fefcb01189a5ca4db4267e61e3b8721e78603b74ce5ac332c7279ac7cda2a3d077c8aacc0b25321648957b37ae9d2b42b9c2f2c9ea4c5d7b0a567897a950cfef335fb4da0f9f7b77ddceec1833942a240349fb893901de95891ce922a8ed5c62a414ee55923d6a4947342259452a108f642304a4eb24c0df3ca3c212cf7a0b4cb2dbf810133d80e46cdde870dd8e2d1a932cb98bcb8f34231ecca597618981a217a2e88bd4af49619b6b84fef20ad35e6fbffd52c757ec479297f873f7e6e4b085e0192cb9ab4f5f68d505ec17e3b9ff19a5ce69522eb1b5e56b04fcc1e2ab29589dff602d4d88f8ca5f924a9468dad505c8eea628caae7ef4aaf08d6ef91bdf821fd2caa802ed31ae78a52063a796ce9d1934005f3f5a51be62e1be6e681060804cd1d9d16b54367ecccd732bcae352548a3b547f04a8de97ea7763866c9e6e2a17b5bb4545479d3e72a53aed172d39a7b8352abc221d2395ea2021e32bdc9f5693d5cc611d0720420c2dd83941ef3da9cc2f76d1355a40d84dd9e7d10d10e419cd7820ed741d1ca1b405b33e5f28ead6c8aff58414e5993819bb3ff436a55a1279e73b558b1aebea46850f89c09eca944831c747117007805932f5b996237a50d2953464f41d5c55772e4e769661fbe5c53a5275096bfc0919bcccf2f241f8b24b2a287f87654c0b1aada34a27d08e6fc383cc297df0da127132c9dc8c5891f7752265b0eda2b488c15be4b2550e374582c9cc877af111a519c66e0c8a4927561d9b60a2091b12db14090b05609a3b88184d2f289533c07a61fd945496f02e01375dc6c2c7e16ea190a5f6f791853e44249d44ea37e69741546a16a485bbdbdb496f44f4c3c2f7f35ac847c5f17dcf1d2e8aac7baea8d190f9329b8f460de7ebdfbffc366edd6a4b711460b1eca3a5fbf9135ffbe9e6dd485d1e7671c17a6e1ef217c006a81d4c502263f225c01a8bc68b390a6612a13ab9178aa081ff7d355cb8db52908fab307c3ecfd32d86a2fd7097e45e67980649a1f5b2ccc2252be19bd05f7a326b92d97daf244fb8d2839ed7a5ad9f3408f2960c5473fc22a0a6196e6af055d714898350c666f315f3d05132bfedc88c2bd6c0a8b9cd5537676c63bd09c9e2ed71e48966108fdf33387b622804ffea892cce2927d8aacb430f5b00fff8fefcf33f0407ef117ee525fd16c3510e483a2945623bd2704be184c9e701c131b1f4ce53165a50574a71d91f1192a923deac991342023f1d266bf41c0e356b80000468255c0480b3413d3f14fc1830ffab22f38058c8ea6ad5e99af96d68d1dcf7639ffb476a4d86ee3371fbd09eeec8816c306914cacbcae5f75d826210576a28365f94ddc31b004f1f68f8ba8bcfa3fda50e677584d1bbe7d219dbeff887a01fbf1c90e6aea8dc4301e6e9babd63ecdfc7604ee22b9b18f0a8d4b413b8a937eae7dc2c99faa028ed515cda1f32838e0e7fd789d304e2707b9975659e8effbc220f84f4521984935022aa413d8e805496b42cc3c2d50e7394c8db098674873feb72bf120f26d84d23f0ca228c382e363a188dbcc5f10f1cb87f8d5976dbd240c6919db481abcc3e561705e892f241f10b2b578ccef8e95da2a458e160949bcfac2f5f55031a492e0b4d254a618454363787963a17c4352da1ed8d6fa2ac3b133a60f57a9e9b39ee4bc3e90629c66c0256a36aa6af811ca0179f18e345062e08e5f2b01cfcf6a42a725e82fe72385e74bfa4bde923e31bf14d9a970acd7f3298797f8e40637b6013d427d3a1e51a2b6b1e4cb082b597b9d3941cc6332774dd6185c46f5ee20897a6ad307faae72406ffdefaaa232f585876469cfdbf5717f4544fb0d4d6e4c4845501dbe3bc5c2f408658ddf1a5ba8b3c1cec7639b6b28f9251cececba8db6673c43e80d1e1a6e5622664ec2fd47e27aadd9b138a17f53f75ad1136cfe4d937b65fd6570e384a9f4c9639dd035737405c3b8b9635e3551d6fa65e26d36acfc11812533ae7849238cb6916dc308aee97b7a744cdbcbf8564bec21044ce7b457b460221d6dbbecf16dcd055519671c49e83c16ad0aa36708085cf47172cfa123d1033eb0e982fa78ecff1c7073153ba0f2f40760f516ed2daa677d42b667c62d2a50232910daca51302b327560758d7ffe6a3a833c28ae7371efef143fc52fa4faa4c299d11a9ca8a0a5414aeb2149bc33ad78bf6b9f8458bd5a498b7497243addaa15904badee154f1d54b051d02aaf8737f38333806a7d0c55d6137b3d75bb812c1edc24d50ac0c2f75ba737eb028cdd56e5d252206a3ac92a9a77ca607a4fdd140592e3237f94575912208caa71614b21322aa185097269d2b2a16d65031a5c24b2a796371c28d170afc10038d025fc75f4a0c3d28f8779ea9aee11d825c148243385794a2a661c5f0212a9f2a2ff5d565df89445bab13ba355af5792e1f97c84f41d56f9b6bca2c0b9421e9b44858c62d042a42aecb12cb15f372178cf8fa811f688a8daf3eac387f0020f7621d9356e517e681ec23e845748cbcb65df48fbd4a7ba86f43c7282d474b8270feee2f60032b2105c42cec9e15d545d7bab128d6e0ac653f9cc2ba0b91657dc65683ddf43d36f69bf408ea1781f5394818d2524d5561350adf0a5f5e3dd14966483b89d9122cff811adac495c4c1e4a7d7006b90f36ddeb0cf9160aac813ee1ef59be567cceaeb6ec0177e5113637be171b46d60be892974ebe3853387e01b21645dafd92f78a0e3f2ca8e7bf19f9db6a25c790521d48ffa620c2c93284440922aff459d3aca27c0293f66a965049b3bf89f6c1be8436ee7e156cf7d7b91f05026c4cb1740cc74e3b51b08b5bba80de8225e5711507f85caf14482828da628e067d27f1c1513678d7c4931a07a8fbab08f40e7400536a9686f7c8f546507f974532b92c1c683f9aec5d4190bbd70edcb55ee744cafbf97fcba2cd7f03b5609133326fbad535810c9f3625aa8e950c2da365ba42a1549d6c2f8048fe4816d5fb8f008fa6f30436535676c7f9797d6caf6f8b46a8f827e7273d1e75441d0e977cdc967c774f824c8fc98a80fef381b65a3756a9448a7043d61a8f3e726665ab0d860ff1812f240f562af4760654134540a6b355e1ce836a905ff4413bc7e597784456ea98c2d36a09de30fb4b71549dd0d13ed16436f856295165d195f11aadd2c23086a906895cfc1950bdd735ddb81d84bc0e6cff381dd1eaa824ea90523ba59ea4bd0df5af3fbd17de50807ebe44c0fd1b1da0367078e0879e0f17e8dfc5b0183cd10f50bd78da67a8c952baa2f54faead29fc66d0b7bab0d737ad606b0769dcfe6f6b240644ede622c2f7d63b9679a6e78a74abcfe52cfecadd0e6100ce48572b6353af05a402822ca5b01f14725793622a9407f12aca3922164c4fc49211a60c88aaba734510b7a03d293bfbd3004ac57b0a9ef0c74e7803570f97f0f0c182577689115d973be6fb1f63ef4765461a82bf30e1666eeb46eb835083057e94dd79bd5408ac37a41bbb583da5869913261a92e015fbe45170d539627e6034a917b63484659f29a2e063ce94e81adaa2f32a82e70a31c1004661c6ba5b7138c9e8beb65b570c2059169f7b344a73eb4fea83057c6f2f954b5c23703e2a1180e6e661d2ccd22404af4c15b36fc507e91b77fa87e8453c3d8145dfbfbc5ab33502ddc9b555d8ca6857447b595b2fb94a0f66250f82413f6e7e8f0ff788433c581249d43a40b249f309eed2de221d6342a1a69afc2b51d9a87aa763290977dd42c217e5810152862897479785aac76f0407b1a98aa936425e119a4c1f063545325581e3547cc7060eaa69fad90ea2583c854ab4ae05476966d475eee30b8d213e1acf54b38667dba774eb569689e0987f59149db3d767a6e5cee88e9bc4494dc669c97e5b8b317c42ddae812e2e6ad602c3032fbf91c9aeab72ad981e1fff6128845833a8553d46c5a6f561ea4a319fe238a0fddda1c58d725ae9b09ea53115bb9dc68b40ea2f8911fe014c6f36770e319c5a7b2ff500cffea81378568fe7d346cca0341e9e80953c9f2632ceaf679c1f5b6efd37bb5b91e27023ecf23a4d88e030501338cdadc29cdbbf59da8f40d47089c153311b1a3a6b7bc91ad10bab68b497b5f84f65799371ec461ed9869834b27b7107dd339568c9171d288f891a07c74fbe838801445f0c0f8c38303de9919922132015e22711709d26b8a3aa08db921ecb8550074adc5036db1b95078e16c9d714be0f19097b0250006d40be8c031e48e0b7a9e3bd71d71baa336c7b2c4f6877ba0f142995698eb663574ab854047d5e3955427117e3ae0ddff1b48bc6f2faccdba44cb66fd3a981993770bc614730dbe6b733bd950d4e12089651160282ba47cec11af1f0f2a886848e13d42696e46b939b4730bde99897a89e44d66ecf12f8c7b18ea8df2062575aeab08e55026cf25924450120dad79920531e183748d57af6415ebcefd2f86352451172c923f5ac5c1602f5c719f10f7281ee5f9da0e6ef2fae74f469d5092b21d39a1996d19cf22bf3345149fb61386412c362bc5601cb5befb4e27923d65057d207c57a27c4defb6a2245ce155d49c033fded05e3422e69eb09a470add2513b0706a9a6ede1ce4fd7cc4fc548c5ac97bf75f8b4ff102d002f67f0f386adc9b920ff5b9bdf1cd27997b67ee1928d64ccaa1b42d5ecded6196613d29ceaeea7dbe5ac9ea7a0b8053194fbc164b8bad0809659749edd166ecbd1e3c015642ee15bcabd8051b6eb4c51683987d1e31a9ba683e70c9c99a46db23af8cac54d778db07e3de13377eac0b83e8987dca06fb342c7e2a39e25ce80e73a5f1bcf40ffbb47a3187fad75e574f35edef430b253bcbc1e2642db7c31f2e6e8d342f46a75b28eca9ba538fddc508bf027c5cd894db954ba07f7026b0073861dfd8cee880f42ad674df0d7ad9bfd628a8615dc98f020ec4d41d1575816a39c7099f90ebada5a76c241c13d2109c78634ae7c2d2f6d80b5a633bb978e156a6e425b7b75fc70affe92fea339e164319ae9211ddb5dfbb3b9c2f149d421fc4a24867f282d1d81423759e6b450a1ea4cf77a5a4918d1575aaddc508d4e5b520b5075f97307d6a4e3b8f6346a20e25a2afa7e61e302265cb448f1cec331239f9c4a8ad73d35205c573138fad9281e9f4db7f04a903a25632ecee1bed9e44471ebcda2129d99451730176b1e4785e7ca628bce9dfeda95dfc1b1641181591bbd989e741f77e12d62ab50c2c2a72127dcb142194954b43184e6f780c77837dd5ee7a44ccbcd556efcc6f85c55664ca86459df09dc03b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
