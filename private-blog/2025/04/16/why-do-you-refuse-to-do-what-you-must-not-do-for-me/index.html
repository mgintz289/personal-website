<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39f8951ea4c1e2d78f39b70e04c0106ac6a42b8ecf8a5be34a2c648b396bc4fcc0781e48409f170f6fb9dc27a1227d6a6c6f15282abad10ca804dc253b7789a2266d85d89d82293e637d929041634e4b60e035b4526dff2c145387180a90ccf99b2445b35f8baf011290d1049ee69a4f4fac96e039a4af419df3ddd615466c2c052ad52c78ac438ecaeece5ad81e878c865e7237eb2088af2f8009feafe0b78b98b9f6ef790bcc50fc2817968abd5ed6201b016a02789f538b34f4155999a0167723410c83e2b7511581859f359898a1ffc0dbc816f21aa6ea9db3d2fe9d104c1755a7846832c3e68f20d04e1ab2528fd619d5a16b460b44649e0d7cb32f906fcf2a183fff2b72a663fed3eaead569662e64628da2e543b471aee593aab5e6c12a76dbdc736d26ccfe57f95b7c3700f62fd4b55d7b43d0696573b0a9846c36327cb6909a306800888600e5746cdd4286b3c493858b40aa3830e45d8dade901336306e4a311d3ebfccb03a7c275bcbff4cf3a7ee849eb2040585cf60f959c82335a03b22083f3efbd95fd5ee9de25b03ef1ef440230459807a357aff59628553363c46c2b2f20c2d0994fa5c67e53472e190e1ac5dde027eeca179e39fbf43b736604993cd541610649ac16de7a239fdf5597e1f5428692f7ba901d9e41af0cde2e98f45b37aa6abaaf3cffc8a65ef3ba2881230c633addad29a3206cf959c3cd47196c75db238daa32d913036b4e8e1f75f80aeca070e54d61fb89dd3460b72165721efb3832d53ba3aeccaf3b529cfa78eface99797afa73d2ece61c349280142feef29b3c40eff7f0f74b7e75fcda296bb0d010ef0b5e78cd490067f86d1ea8b9186316a256cef1eb331afb41d2506b55f88ffb3287231fae45db62f1f5282dbf2fa44563ea15934f8b265a292d4778f26f762e49edd5e6ab61b3b50e94448f90afae5573c07d1b204eb1bbbed4d25d13b6f03aa65db8f7c7672bbe0f5257cd3a03f83d231cea53d808d3a7b09468f547e5e033c6d610af850e4ea6f8ecf2094789fa1fcbd9e5aa14eb383eaafc6802e7a8f4d5536f5fc323211bf85e774f0436ef26df6f23e3a9c4a8a580728c6949f660917a5f07fb79b4893ca69837148cafeebb3b1116d39fcced006781f38ff9547409aa9a9269496e1a7f1da038b56a89f37f0d4131cb934f0b223166d06163408c4db405fb568125b5dcd7ca9270bbc213441268d9942cfa1f34a80910e29311fceb08a78e16896f74d695275ab89d595fb8bc1479de47b03a315c007ce07125a01e34e3ce98e8ddaec7e6c925efb777a54a44e77a5e6f44a3a71a30cd634ed50c0709cb86cae7203a1b6cd6506944d50cc3ba3010dab3ba55cd331580e518c810a3d09d10541da0b92ab687a6d98605f0c4d950ba827aa1b567b7f358a0a85d2841d61df8ad40035b515ed965177adb32274fb65a6d0a224eea7fe82a14bea67e40718518112d788d35a6983452f4c0908d10e2ae8799adae12d4dadbca7b915cb2de4956d3cd95c40b28ef8595baafcbe5f82af47b5b2ea88ccd9b2e055f87aeca9bb9865808145f4e28510c3ba4bab470f2606b4598821c3cd84db1f137976fde7bfc171faef7ac4ca5ed78a870a313d9e3f742b36f6d0f47d598fe3bd2ea742b81cf595103da304c086382f41edf525974e4ab9681d7764e41400db107b741959edb3e40386655fd7fbc570ff4d9439a9bf45b47224d8f8cd90dc5b0e05992323e21fdb544481ab2f3acd7ba4b1e689937ad9e9ec12cf16450cb05e496fd58094400abe841b3bc9340391dca698247f39299f1de1dae486f2a3f65b6f2df824e3004785b2b8c74a048ddecd31244b33212778a88f7c76076112b36a184f1f8fe2d237d52618ad1143d332bd1cde7a0c47542f72c9b9121d50d9e803c394f6b98704991cbb28d7c9d1b35ea6a6f4f9a3a1c9b617e5c862d367bd27f204b12d693e10da113eee3859f91aee8032aa1ab991b3c44889b68bb78f3b13a3d5ec5039b49b1eb5c54992220f1e8472f4ef86f2f9d4c8d67eb51c7b4862039141eaa50b96e96968031c58762427d75744e7f690549cefad0439ea403c98c03cd6376a69f0ab11ab6a4ef6bd21ae36d8eecf77793ddfbbf0d51c852c53708b8f46b0d03917d9046fbf94defe587d4ebd92a5fad065e1e4546567ae7c4f700cd63151cc79ec0f25e115c28fab0a32ba37d303890f1330d276cef3efba7c9de6c933b175f13270ddd7f3e9f84cb90fe8f47eb44a30cb2cde0e9ffb90f62c473e9e584565d2aee18fe1441606bffbd526e67f36bfff20c516a409d7420227abe8b979a778a5ba147d52868851ee5752c895aef4f58a9cd991721510177b912287e02cc348d6ef804450312a789d3aa66829f2a387fc85ef4ea26655a2ea60612341541e93aa3239c66f9af0cf4f223bfa6a614a0f2b44a238e55d2b2d595ef0bf61cba185a92d841539301f72511b4769146ab753fbc38b84b6ab9ee0de430cc0c300ce4c2e5236e2a0195eaaa48fba78165752033fa141c6f8c05ec43e1233ebd4c31ece1ac86db02a56a63d880ad0cc416120a8087d0545f99fa82f6ed389da40e7fcbaa71bceabfbc2a9dc494138df6b8a585f61c2bdeb12d2e4cf7737c8105da564a5941cd34bb8b6288684719e06e539b3ec62fcb8b37e582e127a8ba31b97cde5bcf4cf3e155a518771d744db2d1cd60ad2d8657aee7c681b90bc2efe00c1fd1c2e2ebbf5656d073749ed3191c64f2cc15cf63c6b34da96b18165a6fd65dc511209f66c9596117f4745700828dbbf0009be0bf49cb2d2652ae25ee53f7d1c5a1f7fa9c351c921bd2278d2170df68ec8613d95e4acc7879052691431a7c8d2fc11cd3a20308648c1cbd7723378796862ea9d57bab5daf1d84d701af27df3f376c3bf8cd5c5f753df60805a554153c6cb1dabf0439ad32d92fb42acc17e6896207fbc6747df89ef0d79f9a2f133d3bdb50f842626ec6c4d8e3c20e3eab80194efcbe312b693a49285573bda87089b158c5d0a161e450d2d94e32e2757737b31410ab533b5949bce75eeb14c3a1f72bb5a6d818612f84219cfe0a8c6abf1295f833c5b50a5973402e2b6eb61d3926a6a8ceaf8e073d1f3e7511ef5e4f06989199755c5734292f0eedc437007030fbb7617fe961273cd2d98fbb4a16ca22e0bc04c71f289c0cfe8cec5c6e9e463aae2e06a1e423fbe9344280d74ed6c90687ad4a8c0a867477fac0a88ddbba789f10f64ab9ac188b964b253f248a0053fc573b6f454502e2966f42c48a4273012df9e4330b9d9bddf5302d699e8c809fc3f6d14e3a3ac60aaea9fce5b2deb419c4e9c43ad3b564cd2281c6590f4b31a2da4da98db04231ba28bf53e33717e24ebee032d1d7655a96226dc2363fc968bb7da8c225bd6018f2240cf5ea82b87e7dae8f8c078ece97d8f6c3bbcb8c7d84483463c526dabc50a7118a190b0121ab24669eb89279ff150a9f4d46c32ae0411a1e6edadc22900320c785c687d98949ef92f9070d401f44d32439ceca6048d521c95c6cb69efab3a1c4c4322a3bfe27e9ef74c7afc7d937259f01bd6f542b937ea0c04db6bda2d6b2e4116eeb5c6ff8b3f460dd70d50c4b9f2600c93122485145efe189dfb0c7dbccde3878243dbab0b9caa2a9fc37aaba585c2b36342b24fd50e2bebf644c174238f45812fd6e562fc5abf67f71cb7a46f4bf3cbed8bef695b4af75138f61620ac71301ffe8846d82b6ca2097746fca4ba26edd108a9a56eb538383fcd719aa5cbca903b20fbf578d6d8f868bc7085a113c4db1da6867130d7c4ca6c52ebb77a65b55dca899c2dc56dc00b13297e3da6c6d4c86c4d699c8bcc34d832aae88a03221cc651822c4745848bf63ae2cb095cdc24f5ff056d1d64ae23b8bc3d30eee0afaee51fdc4878efc92c186dd1d83248e33b2c0e89b8a6fe11a8715620bd26ab1d3aaa12045e92045ae4d83feba334137a623d13334ca0fa0e60b9b7cc9bdbe00955dba34214f0f4543e030740fccab0fb7d2917ebcfe28f9cebfe160e5347a987c4ca2e3c3505c41efa9bdd494e58a2cc3cf0ab0b7710ab58230e78376583b1fd3286543ec0cddb55f97162988712923b35da7c32b21c9d81f80269fa21303b17623b58678b7407cd2c18de7deb69a03630ead43331eb79e6d54eb3d7ee36e90c6e06cffb6bdca251e653d84875e02e3cc8d3ce3de6b71f702356d9a15b16030be27a0a4be456260bca60ad87a29e85252935d61087b493b83b3d0b8a4e8e367f32ebf974f404971887bddfe192d54fd242add5f83aa54af0ab7cdcf40f70b422b11343f779afaf5edf1916a6b7337287f777cf1f5e87a36dc8f924d45be5c40daed092170201533b10830513f50249ad6f8be6d15f4ad17f04e9303f92ed585e42b80a0478e344bb1d54b7626dc3a01eeacf763b8199e71c72bf3d61230dad550f00924c00a6818dd7c45b805953f678f26c9cc143b34d04d3260da440eb55ede967b9e03ef27940687e1ae6f3e1acb8c24e44aeaf6a5806c5c5b0f42e35328f99c22bf3ba99b0e537a1ea29ee0a0351ce5511dbbff9d52ade9f48083b7ef1cb610bfa20f22c06e14c49b0549917ce5727bad65173a93d335b749806765d66efc6429b79b5320cc665be5ba1b6577eca3e0c3031dafd2c39d16ee5424e983ea98ec3c3d9ef9ec70e4cb8b67f6b1438eee1e4933046107d478576dc366a8e7e89741e528a3b14456944ffb88d76bb5ef841aaf5da4b041ad23752502d7cfd4303edf2706349e9f7ac2d4e06cf8f4e7ac2f23c94041a43ea672fd819589c00051e270c37a4be1ef028a5f32ea65b5e73edfe0150a42c561e7f9617e26b5c9494130c8aa097f4fec6fc32f71fc2352fc07a62d8634e6b66540048b85a10b5996fd332d1e79bc4c64c64facc57282b9ede10370a47e907d251a76d7fd40be023dfc488032d6780014bbe292bccd2c33355a828f3548a6f242339b6007571f2fb1dcf878a94f643b593a03b12674ef933b43579faad1c10c9ed5bf973e070a6d3b578a910531490e6acd3c40a6cd19d2359bddd38d947259fc81e22095c1e7145492a37155c9e17f863154f9b4f03a29d72ab879583dea1b541edcdc3cd854595d6977d10e89d4ac0caedb6eea658932deb72ac096eb3c47763d2e26814d6557cfd7e309da538a037cfe6f91bad8400e9dd817d2e14cc0cf1a77b77f957ac5150b057b1c41a7ce9191e6bfdd27c6d4a1bff01c44524dd5d53e0ee2530007b130f500edb641e072dde1544f1fcd166497f4b653141a350d5acbe93b7b6ba84b08e50209e80387794189de55a56eec2952ef1fbe039e4870e460f46b4d2c82aaf9f20a1636951fbbc3db3384b2e43846907f8e2192440e6376a6bff265572b68955c8208a0bafcfc7aea9814b65d7ea669472b85d5f1efd90bd5427e69dd8f5e0134a56e391ac867923b8276880ab9280bd7509ba209daaf0850b2a4a9aebadc8c7ea88419d80249157fafa4767ab751794f7e74d19517c22374a68e461fc7abf5a16843b914dbbad693388fe637d0a997eddc38e129c0674d72b4c767c98fd696ea7ea254c32fcc9c185d62d0cc08dae74061422957d9d172fb32c51cfbe97ff5b508a4e0b863dac69dea091843bba1cb03f4e32200a7d15acd268a3c9f3fb64c90aaf2a347751ef5d6e42738bcdb93e22464b21fd399aa99bbff5122a6af10cebe31d8e1411281e565652957b0e530403b0ded62f5b615803e38c5c1570daf75a0c6a9ad10030534c70c6cbe19800efa3772ab96202d175a0959872ce255afe8286e20b8708a2353dd94cf9afcf0409daaf9023fad7e6c276d789ee41097e140c6555e94d24bd8b8ad0a6753fbb874543b18e1a1d2d01adf36e6f27347ddd2f29fa1a8606d03a89a9c5bb173fe79b63dc4ca72ad4b6677d1d1131618cc72e67b07f1085d5a68de8e34e5ce4c91859a0897a53cff10c2d505d20ccd3613cc3d621bc90a70f0071775d57df7ed406d581c6d9e0851d838ff12efc07bebad99ce5c7af19dd1fc4de2fa585b90777d4f6cf5a8803e246957eca1d79b2d947d6088e767c5ed45b5dbb00ff14831e3bf64a61cd3ff990be59169efa777f39cc19c09579db5dc9d91fc001f37e448a198d9f8911a3860dcc763abecc7b17f32c32d2808dc788686736bf9da900dbbfeac4038068ede49e086c6c40de2abf061ba601adbf2b1dc26e44c07aaf855e5412163ee9a66a93d9faabfa11aeb5ef3d7adfc3e43f7008354c48a482629c5519b7284dadb083be15c830be246763fdedce02ce8bd4974e553dcbc88a8b3ffb79d76c51ca05d1a1b7c03f540d71d629e1139d5a7b2d61d0be179e0add76bb10f77bd190340998f1440f541ac77d65deb0aa3a5a017029f387a7be012a5e051d3bbf472c7d7b1c28ecebb5381ef3fd8634ebdbf1286123599e0c34147e4597997e3fa5b9119367aab562226b3d19f518b9fab105bb075fd3fdddbe7115356dd9575e201819fc263f484413c11c6b7491b1b6887c6c82f2d863899c2c2899447f2b5f49b0743980266a9a65d8a13a35b961a89bf893d720ae4e9749094bf307786c6d5d51c5973e880cf5d65eb292c6472db34d9b60b9658af7336401fd81fe3675d0cdabc527d6a6dafa997f29325c714085be96318ead8db292dff45cb2f7048c21519269ffb7106e61547bf39a38cb6f488dcc7f0544abc7e08379ebfdd174e46140917ea200f7f86fff1b429349cecabc6f892bfaa88367f69f74e60dbdfeeaf6a90473831f6939bd056bbb384075f53182ddb75d8e4545e14a8f71a2e93b3de312a9dfbf50fb94264bd1044b1782ed77322232fc56ce6431f3595221e100d39b11a8f3cce4126a5431d5da4c411dcafa800f8aa85c60747b7ae0a13519d28a355b80187219c9a9edfa07715742c413749f0f4698993093926a3312baac39bcbd8e723481fb160981c9ba1da580930278eb3f6587211cbd09e9fe9b678056253e380f0b6c5de5604a2afe50c1ff1d7ed05ce2711a9742aacad14b7c1717a900a7f8f60452efd46f3459e2cd129191a4b4ee5c53886586db18441dfec4337311e9a4f978b360c13e405840c4b2cd1371c9a82f5e296c37631f9591986b969a9b9d15125628a4e539c32232a65255f821230b9a67af33f023ebfd4d719965d09e97711bdf1f507b334b538384e974dcbea633fc86ac065f37a8c2668cd60a97d75b6abdb93ba7f3972051e9c276f33df131556015039aec078eeea065136214d5625324f0dda6f4ef5d4f4472051e23877ca47c24f4f81bd943eeb37d93d5e6b42a57fdc5a67ab07e1b4a189d60ccd7dd2bf0acdfd5920a9bf85cd2ee13c610bea453e99eaa8c37aa90acb2797891dbe0bca787b1b938257bca36d3f3d299b60d9411435738b354313edeb25f7eb9128480a9ea0f26dcfab3d6259a73bacf9be8300842fccdd64ae38506d43eaf9e7106714933dac6e8ae2633a7c38ca51868cc9cbbda4987abf62cd8e6a387e6b5111691a9b176d3937b1d75fa0445ff388162e943b71927aaaed79d7fae472dd51cf89ba0ff4940a69691a2075dcff517014488cb8098a6794b70370a366cf838d0aba540601c49f2f3733c5fd641f155dd18606c8f81f9ab5fb2f7daa4d2a3d9d711dd0515fd67701b0df9799c5ccb0b50ced07daa7e660a0735ae9f1fb849d05f16bf74c4e65009df045d4f49ea334aac295d41f769edda9a75717e816d64738139d07f2364503b1055bffe387ea6fc1b8be9cf310dc7c3efb770574a2ac1279bc7301f409f0fefa051f466bf0f961afb5e623edd460262b4afe7b83cc987f2e75869d36dba39d3376f1b24c1138d6ad1ec724ee6d1ac411517167680b8bd762a3fb9f310beeb80d1e260237a374bad725edd9150a7fc962b7724ca12c462832a6299824e9acb750f36f6f60f0c8165e8494c69a26dda465380eaf2b57ccc039faf9bfc34f99764b0f1b276add1f161b87617f5b79e023d218b9fecbd8dbf24a8bdb407c4e396326ef62b4c7ef0515c01e2b5e6567dcc6285ef0b215c2da7afa4010dd3b6d877fa02a536ed758687cb283a761ae70522a1c0c5acfb1164c12302d13243495121649189a39474bbd3bd041894985a4b5240d26fa56369f49b851e6137723085b3c4a4953ffb6d64673eb079430e35364ff7a972e266b7adcafc2c78bb81fdf7d5eb924b5f39ed61ec5b8ae2e658cea016d3d7d43a5471e74fd076b5993cd87e014be8f564d39911ba431f51725144167f41706c824b7f3145c222d7a485390f8dcfcec7605869cd414999722a5ecb2a3ec88f5a9ea9f4c88eee6d126d43675324b0399dac4edb8aefffb157efcd26c8b2fd59f68b28b54e6e4a382b76feabdd8f1429b363c49a74d243c1113af39d677c7dc02e9810b3d970e76e6036356eb50d966770bf51e707de2985e421cdcfb689b2996e39638d30e5ec13864a312b8d89fda40e171a0fead1070c5c67db01f71762c71850ed1466bb2db9d6196fccf294ca52157bd338d70f816e5d42a71b53160b48fd94401a6022bc1df742c043a68ad52b18aa4e22d2209d9d66199bd13e90f9a2802eb25e8dde636325db33e0b031b6bb7ecea27e54fab96d12f292b8d44e8fd17b6205a06b3b6bef894f30898aa825f1887ceef5f82a225c1fc9db754f7caa1feaf5fbccec47765af33b7c3b138181639cd7d02e2f10995a81d47a8c7a40128c9a789656503a7c02232ea8763e21787e6bcfc228063876250a1bfbbd626387ab43ec4446a0cffb6e4ac9d52cc3875daca2a9f255b25e7c5a0ae33147cb460d5a1b7e37e23e5771bcd906716a357a5ad937f738970736cbbc7781c9c6fd43d2ce38d233b6d244888217ce9ccf03ccc2d88b0125f47583266fb11977ededd596eea54fcfe5676cb1d02361e0248d40496c78b26ab130c887b7c3402772c7202d225d83d0aea9c45074ed429d6cf4c9cdabadee5eb60d4942b8e310b4beb17b10dd413ed99bec8653a098574202bdaa6cb907ebec8cdaf877636f37eebc25d3e121634376f4a874eac71341ffa38630292ae73f81c0beb86144f1ad337b8094b56f5b0fd9b1145b01ac0d282a2f281332d029717f566abd838eb0a0c62b8215c4ea32cfd688b822584b0ac1b5d0608377c5e452d90780e12bd51f7722c589ea96622ac3dfc4305beea9eb7aa6abeb8efe0f5045f65df5e56d860626f3f2e26ee76c08159361871e465cf4d558cba2333521e336ac42fb824ea95be875ccd373b376e33951510bef5c3751e059ff24095b972f661df7599240efe25f37ea602072711a8eb68b02ab0b8eb1e4bb0ad76b8808b3012425ea6c425f56af64cb1ebaadc500ff03f06f5ac1a8cb61681c2d306f5f57f9b65c5c594c84153ef1e23452f96b9a7ac47ef5a3d3ec1af508d66693fc2cf30fabb72ba9874316eaa743bbe82d21bf978103d0c21fc8ec994b237e19bb8ed0c7e390c0cc5fe448c454dd739581c227902a7d32317bc17dae5bb776f7e4447e439b7bd5fcc578abf5d0e5bddf4fc5feac986942d2b05980b47170ff7ed23990d6626aa329204de9d60757009f156be7886a4ae0dc23efa0050d171a7069456fbf1671d5f637a335e0f26a44f25e46fff24bd4c903cbc666159fcbd76a4a684fe399c07ec35599bb788c1d3f5d30f5a35aaae6e2e87cf9b6061ccedd23a3c7ec1f2ae18ad27b5f251342d5dfdf309a1b14548ab6aee6cb6244fe406201f6a226b0ac2eb4ba41010551d90e2e07f2b9814cb7db688b42a1bcf21497a4bc081d483d4a5030a98da85753148633ea7057132b8b4b1b22b6139523be0e170e06cd4f559f71f0d55961fc363ab00e0e2617bb6a79217f44209fbdcdf70d6b3641647096aaffa20a1201553d39836c335e993e9cd5a493f60cc41be2cd84e586a1a218746eb34e19347d0720326c8e617981b6655faaa2e29aa7c860a817e151bad9f32882b9b4e8b2d055d4b52a3127de30bc14fddebf942f42c861bb5c13dd58505e565e35a49d770f75d1931b9219e0159e9273908733aaca8cea227f652c58352b499e1e78f33802630cd7f9aeb1dc28534adfdadce756bc32ec595c3220da03abae438ba889fdb84abe4c2e2e0cce76da48a7e8c2737f14c0bfcf61cf40dff57bfdec97e89f84d66bbec0667006bf73648706a7f6802b3406ff476087996717debdef98bb78ae96370d3818df8defb0c2165fb18bfcc0cede0bd35ade404911e61e7319131ddc9f62e38821a2bd6ded920a4aa63c2a7e9d6537ed5d04795248f60f4278bad25d337cc8b6487e3ac7812245a40deeb759708c01dcafd0a0d54fe28c1bd27baac498bb4be5f67fcf8b5e93ecdbcd0db7d326d831b10278605a455a6c885b8bb73c4400c9206603786a23215d5a49bcfee6280095be54ce81199f7216ebef164631045be964344ad17128997155dfcee6c46c289be21a3a6f05e8d92831d95f3f0350eaffeb2720972f2f5cb6959b1f7b4e1354331b4f2e450cff18aa9ae785d2061d0d96b7338673aad5f6825b295ac56e65ee84ce9b7618504d50a65ddac8a3024f15463415f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
