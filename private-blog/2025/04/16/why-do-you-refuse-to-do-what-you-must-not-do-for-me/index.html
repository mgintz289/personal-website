<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8cba49f3b12e7333ffaf7c15f3598ef052df40524009f429b06df680ed04df1b109e6e1ed7f968c5f3545f87623265adfffb71b0fee62de15c2796d5689c62938ee4dfdffc5ab74c65d3870eae79a0a027131947c27ae05d2fe8ce725d02ce28d4f416a900d54c46f82b14d085c607042cd1b1087580ba29a26f227c028605e546529fc3b9b5c489ec999da7fe62e8543762b8201d7d6d1f7f3ea02394bbdf44eae6f8041f515191a2206ff5de6418fd2f012820a22088b242692f41e79ab146e0717bdbadf7125e0cf64669151998125edddef276091431b07603c07fa93d21964dbc8206d7d2f4f5df0c54bfa4d5ca2b9d75bcb46cfc926ef10ef4f6d1567b6463d2526cd44cf7817efaff8b22eb6334028434a72cdef4e173a1435ba6d6d6daba281affb452f0717d7d79a297c4a078126d5c4395c005830d9fbba5577bc4116163068eb156912a53821c61c4bf17e3a34b78be14d7795d36f77045d2da38b0106f4523ab6ed61062ddacd220ce47a61acf606fd5ecfb8dd547e040cdf2959d668d994bc2ca846fbdc6f023156cb27e55b175c57530b95516e1f7d3fbe2c38fb2eb9d0c00a4981762d08546250ef1fc52b6d084ce2877247b98ce1fc99269f078db89dfe5c3372cc45f943524c343dbc45f5f992bab462130f84d410b79ec89b0f2e9c75a0fd1cbe110691433c59c7de84f722eaf9944326f5d88e456046b696985ffdb6c2db3502a96dff9d2a27e315c4bc87289f8cbe3d39d45c0ea208edbb7e4fac466d30d5139c4718f787431f92f54279e967095972969f0e278e15804cffbb78fe63b9ada4e7f88ca6c27eaeecf4cf71be6694ae9b61836eb424eb9ce5f48844d3aebaad4bb034731787dd9991ad52aec783e4a0b4c722f652415735d68d5b78615032e41d7275a7ef23f6122d8371af505a9b8e9441e942677aa53e80b04b8a35d0cd0eb6c1f92c731895c9ddbdaa41cae5b402172ccf7b11df1746015d7f4bc4e9d498061aa1c6c545e97c6af9250433259c9d94b8b489c6144b981cedd753bbc4082468cc0244ebd0744cd8cf150c7882d7b94390bc2bd26198d42e0d96ea65f829682c7c6d4a65be5d91a67f6015b86a4fd728491a503d27f13971f3f8fb21a34bf25d216fe1e0eb52b9584f4d97194eb7bfb32a6ac44fc5e3db9722a8fc4b250705f8d36b301498ab35a2aac454283212af0c379f8a75457ec7224207111923466fdd3a56174fe5895d52637596fc84b11b876d4f9a6228f4545b911a76ebde04f0b9eb34d66ed458f89f73c3d649a07f755226e2f71a6746a3ba649a7bb5d596077f6f035046358393712c9dedefe1fc190142b641963e5d0f4bdfd2d3163cf6fb14095c3e0f248025064a7870769a3edc67b847a1f6041433bcb96687fb3c98508d4eeed1fa27e343160ab7605f34a5f12c92e990bd09d175e45b7ff81149665b6501ce6dd2711b46ea47cf50be22767007e015588a604a3930a9eccdc2355a639643cb1988b6782dcb2f66c0989ec5813a1c4e002f84620d49cf13d9efa9a01c9ca248a99a27359f23b180eccfeffc216162430f225b348ec1e4018e58641cc37a59176a492f16b02780e890bb9fc6960901434c414aae5bdd82976f7a290f29cea95fe768b4a41d143bf242e92c8ad59b7afe9f5ca231619a823b1bb57acab1b43d80a9391954951d83abca9a58082e29dc2a3cad0182b7b7a75fcd846343067b2ddc3cf61ef7cd31706eac50406d4692561bf4e8d096a5911fd98874bb5e6886e811533f17197436d79739ac7e82ff6497f3d77e609360ec77c9cb7d473b2938a33989d4332b20b4fedbb7b9cf22a978e746f5698b016ba0af5a1bfa73b03d5038e6eda858363b61557ee4781042b785130a3d5133d643e934a2298ecc72589e23e6e580e933b6ce16517ac1b05ad3a99f5d6dece4feb412b002361dd603b97b344fe72942b9d80501386d14ebb0284eea4d16c81bf6323d41edcc3e68ad2418a78b4637750817d3411edcaf5e490bfb745358efb367e7034e06d2e34bc7886edf450e85f6a2a0dde20525e436246d00eab8f8bca3a591c7b9203412d0e3a12a1e63a3aeb71da839dedfeebb554ec5557b3708c06f2bb3b6f4b169f10cb6ee7e4012f50263e2f81eaae152ad7aa45ec10ed95c1ac8e3aa4eef1b383bdd0b5751a91c9c96e33d0aa9538fa9248a0dc0fc2d5dc34e03896d351cddd3a1d72af08e534f6e304bce91b44a31761b43af82d301510860bb5b147103aea29ca19acbcaa3578449ab49155e07024ce9a93cf27b42d539ba7c9b6a65f40b6b2708ebc1357b14aae559996e82eefced4fc48eaf0d47cccbe4c61da74adb59a3674a3133d7bd0450e614c8e764f7a4411a6ffa7424c751c6cf9e1cd07d65ad20edae8bf461d440db90d23ed65a35eb5757821f4a9e2924565fb2256dcc0daba8121ba3392aebf34bda921f34d011e2ef864e1afad05a00f85ff71aaaa6025e8c89d8c755c34299389be6290f4a33bcae7e73d295beff5d35a00071c101d7d836f13b4c786e5caf0246262cb8ceb2c5018019bdf1afd7f7003e5e4f8a86abbdb529721eaaebafe42109e53a3a2ed3c7a7d3e9c179d144f5cbe9dbbcc825b9a4734d64d9d37e2c9185060901a4d44cd4a2de3c3049c561f1f57138f5076d42d657a6686eb7f3fa7800d82fd05169858e0996f5ada898bcf0165b29081f3c54bced11821ab13cc518cb80f57a63f5702fd93729cb9fcd6752af64c587143305e87b9fd7a7d499df13c7a725260a68da22d5675878a6e33d78edbabba66aec908493e4e21f29aca90c808db343045e729f30c1de549960feaa899853a30261422c941f1893b2f12bbcc67b0aeb8d45145d06ce5a0781d279da27b5095c3249fd5e974430090d4044a403e10496bf69c5275f459972cc9d050249cf82a4bfe37ae6d714642569827a6dd0eae545b38e0893512827f5ea08fb3dc2f0cec1c8cc7ae5f3001e4e16aa53fce35bf46a67a3f9ad401419b0a29301472ab37c34964a0337af4acfc24fd96a4370c60bce434d7deb928a06a37b3b317bfd55dce778658769d9aed4c28787c69a725816a241430ee03b05702824d460f203b2bf5a7d00ef6770b4a5b79ac8e9aa6e4af1f094ef2d4f608b397b8e127756fb67ec5c446f918bef7a26528125a20a4dc41dfa20d306b5f23fad40ceb57d6aa7258466043682052faf2c9e354ae37683ffa270ecff98bf30b8ad912581fa2eab2cfff7524a4e0fc829cb0b56869f999b11d18b48c741bb32f041374f6eff80956443c7609b38fcad92946b9c0c33a851facf8386117a7e8c7476eaf9ea68ffced02b414a6c836209caca3a5a422b437fa6328e066a3640e02d25f2e34ce5ca1e4fa938393139a4300a63d78350c710bb8cc93a694b600dfbe33409330ef140ef6087b1aca60e0bf88de7d0e05c6d4db32e2ce1d16f0aac3017e0abae443882f80b2fbab96530c59c50f3ae9bd7d93fce1250281a33b55551fc4ed4adfa14213d5619a41b38f25d59084358d08d9591debe0632f9f232a23ba9661999ddb2d0446810ed06020fcf4b7fc471900cb0f91f5062e4e26ff206251d967d282ce9043fd273446a4bce1f5d28fdd1a25f361ad56e9f08b424ab475e07b2900667ef7824dbb9609ffcff46edc6b76328cb355b21eaedc4e86efa6f5e10fd71ca3f62097302a2436f1adcc9db9f3caf825838e700a267f13ab9d7ac4167bbc8565c9802ed6a0bd11e5e549fe724f6e3b73053b9ec2be9019f16015e7cabd38909491ce1e8e736700be3ee0dcf970d7e12951305fecc57e89e60321574a7a47aeaac94877cb92c06a445d1bda068234dd2916c9fa2bbce686e7155465e11009b9f945ab8bd6d8a35a533a97d8e90692aa90ca84b10ebdaa9d3377efcafd23a36e1e5612d0febbd986c10b580dc1cfa409f8373e6d14f8abf7d46911bc18b013d735ee66693a76a87cad57cf6200b482bb513302927d14d042803dbd75790496cd3d99a248edddd094dcc9a361c945772d4636bdd33acd532f653ad9db4e8699b12e4c62fbcb4e91ace68026cd7e584127679b5b3724df0171c1c31ebb9c35c343dadf5d50c6114b67f494fc71386307a032a35892ff34b08d3cbeb5fa6992f0c28fa1637749252cbfca8fd9e0520cb3d5e54f07806c08337eed6219dcfd5f01925d9a3cea61876e42cec06d8abe4d673a084167bebc747e87b8360e0cedb42e868094233655da7c6ff3d6b6bd3eaba02e3855d9a052b662cd28a05b281737aba9bb2fc1e0f43e3948153b0cd15f64aab16bea55ab61cbc43f87a637b3198f7a0355e7b04b4621b89d3924ee761e4b1bd54679dfdc51fd6a4c98ea2cacd7d92aa313c18d3230bffcd7c9a5efb449fa574ee96a54cf752e9f5bb88b7ca72401da8b390f754efcfa269d79bfaa5a4b9e1f4ca694ad7961002ae3f92325a5b2dcd6e84b048c04906221d78c3cfba81e863d883eeb0920f2180f30d95bc7c2316b8f3cf34a0b8295b3c290602b7dc016ed55eda5870b13406584c4d1b0b5b967c94494040ad0040576d62c4b3003f2e656b644e891728a7329e2c51822c487853623a172ab1848623a79025e1f0e78a53c600ee5ed397752552d78afb5eb941fd58085ad88a30dd17f80cd7ed3a2f56693b88fb2319734cb06c046f6bd4eabd821988b833bba6285bc13c5af7a98954b45ddce65b7b0c8fa5883d5a8879fb87818f22a8604350b02c9077d7e1367f8724e18f76f71e1130df5ab03c3ee2f4b92e2567596367de9f0b3342b3463bb04a5d64469605917dd672a1d0ba23a94f1dd07f9502b04a0479065f92f8b0ad45051d266a67e99ded7be90c8b40ea1be7ffc94c1650e7178787971bbc328f976297bff5c395f7bb6c33d665701d0ae2e2282ea33581fc66b73b06bfe456282429c77b15d71a864dd3b88c48ff55b4d5e0b801040966101ac3286bf9a7e7272bd2d0656b3912d2c42420d1876661078c5db7c44ddec7e991359bdc65c7667a65783c9b46fe3359d9f0796a44ac21a35a88ce21623a667d8cd1113c11a16a2dfb8fa31fda0aee0fb5e5e4d37154385b1a360bbac509f92efd0fe43f7587e582e0d34500ff9e157cd42512edfa4721a6ed3054fc276a563d233ab2f11418320a0faa56c6d157d8f7127814afdd0d4411aed349aa98f65979624470b69c693a5d7d71e58a8de2171d369b338703ceb7aed966019727cc0bf73acc2ea215c56a1057635444bd31f5f8368ea5e637df8058443fc015c7516de07e3960f26b40d223f0aef88f688b6b656a1b4fb96833825b31374ffb294d1af327aeaa293045152cecf774e09066892045e5e70a2242bc2756deeb5e9951f8a2e6cfa89f6d6f5bb76bc5bd336c0889b93f6f1aacc39da4d7f488cda625a365b4ba2c95509c9d442ac086085e235c1f822582b995ac31d79ad6e979a24ba0a80604024f9b57fa355fe6c3ddca0c536cab0d07cdf6ab6240020badc50d33370ac4c80e74d4aeba8e6b167ea2c89c3c7dd4245c8c50fb36bf872e93d01e15d0dbf7bd6bb614a4e63ce27d589d9e33e21b155c6f6d83e27826e4b17d13f17d2388d2bfd93119e53537c654c86e568470dd1c7ab19b52fe19518909bf5658391046ca576507baee2dc474ffe988a8d791034ea8e20575d001d4a1dc945f59733d28ae451c1daddc779c819aaf0b75e830814dfc023ac63ecfd5d4540c0f6f34479cf40395a44466b0f98b6e8c856a765234f68a4538265b6598f21cfdc6ccdf559fed311847ce539404dfedfc6200c9e05da2c78c793dc14ac137a35deb14387bca7bfc9f6b1e7a3e4b2ec77246b27363e79098cc302e36cec133cbd614c036da502842362650758dec7ea5385632f12d7f60e67fd322e1d7d83ac09d3ea58c99199237b5679015d5fa5d8447b0ae8755a9cd76e5efce5f7e446c18efba18b15d4f4c3d15cf1ce97e4631033d5ee43bcdd9dfa28e7fb26dfe32163d38483ff4f100bf296daf279efa10c0fbfe83e860a19e137f02d41865d44006bb617a636da4bd16d725d3b9cf449d5be0b09248a6ac840e4c2d0aff81d4357853f98ff37f354501b90c693677c4384b6c4a5024f177226273d3c23dc5695cfc615b345d8656b1310fb8ba94d3b70ec438c5e5b289725e624504296d1b39eba8bef5aa2c677385cd4223ada416a0d5a1b843979913c944f35ea8069da13fa6defa019c95c2b614bb51a233ee5d3a439add42ecb29ce60df9bd4ee5efc6d0a6a4b1b53c88184f5df58d5c54fdfe1b47c414308b1cd5d2bae92e52de7590f89ecda7cd49601bbb53941f122296be34506188a84469b50a47c56ce74c38c51c113e2986989ba063e31dc8054e40c303afb9fe7c08e2843f0d04d12ede54b3c49550c40d4a7dd898d78144c50d5a5a1566c4b940794a9f7d6069f35ea0ca0a341074d37220753bbe93f8fc922065c4c817040f0383e17553a2a52d6d754a185e04b07292d9fec729e3fa14ed1a04574bf22db0f32a3534d056ae8c64207b7ec6fbbfbd15fd915afaf94564bb0e4a65ba677717da85499d3a83d663ca05d4f7b05a9224616f9bc77b6d79fbff54c51937eb2e752f2b5f0427b65f5a50221bfbb7b0d10adbac494703f6a6e303e06269ddf6bf953eba65251e8de63caeba1512d9ad9c441bdd1aea9bf23a6d997a1cb205f33d8b068e5d15fcc31fc13b7808831ff6612fbc6bdb038d6f256141ad40d78f1b0a3b43b093cd1885ce4087cac24185b050368ef50bf7ea383192b6885ed99456a278441c5923517447c9da9ef81e61b9f4a4012d2d43a17d62a9c72d084e07c9860047bb22c16b512e3d6110f8712c28ee674e4d139292a868ae8cfb4668ff090f4776c6b5e22ef3740b43a7ca79531411f54da89220aff69fe3b19f39c4ffd1f2f909b8c639a4a4ddd6a35f97800f7b985eaa3e14708f351c53c62d4bc4a0fe4e5f91393e749db124fbc9a0357323a90adb980647d42211724d1764b6a06ad86debc03afd751d5bb968c9840c8d9040c71984e385a69ba75efcee30f02878c7e9b54e74c08a3a8127a250865a4b3955a01c115347fdaf7d17c9509ed6c14cf4a1fb163312b27b0cc93a492b2bf51cb55f0ee2525246d89175a4c6910f86d99b2782cf38cceddb3b55ba7fb4d58f02911f11480769f2b99c1108a557388f3fecf0069ea17f173fb896dbbcc4859799cc4a54d4cc2af8c92575d0b1bb3f596e7708bb2ac1c4280c741bec24ee501173ebbe06c9948c6b24b2930f9c0bc571066b66ce380ac486223907a21dc93d22aed3a9cf93d7c46ed6274e10f49c87c499d6076d9604c1868d5073ab2c40db6a6f1574d62895dd7c9ba687d14e867107d929e38ce424da48545bc7c28447bbafaf73d5ce7759b97da1da4b43da9083222afdc74613d1d01e8243acc1d5ecb0adfaf3f4e150fdaec506679e0df9533b11017dbf0014d35541df9103d0a600c2be39f27b8483f3dc533d0efe9f0c91279e7e6d951bee4c4016452bb090d655f0397f52273d83a1b25d67668d099be31c4a86f6c40be5916ffe0cccf5737ae097ba837facb55751bc1522a8c4133337f29017cda6ed9da22e883b9efdaa849c8c2dfd1d479be430cd178430a1a4b091d68379da01a8a1da0625aebd5ee4f840c1c79c9421b18e0415c66fe4f628e7e3ff755ab225f63579b4f3db14948e01b3d2e4425d343e042db3d27bae9c50125f81ffb3208d78956980de9842194d4e6394ae1f16a5b2016f855b9ca3299e5dedc51159d40189f77f678a836e0ceb8a8ba67c6004bb8ae190762c42680ade9e88c4245c6fa9b2e2d77388a444ba63befb3c5bcf90b6bbe950b20b87f38726e5d4bf331d27ef8b69f8cce1bd2df2afeba44ef7cc33dbd146d770173d49aa1308e7de4440d5830990dd6b750ee64a5f9b29bb091e9cc1a9e7741cc6ac2f3a46d21c7db6101615badb1f083738a3302f7622047c793c42a9ed6155c5b04bec42e5eaa54346cdb94b81921ef37a1c465f8bd77c08da9cc77fc1a03f37e4808297baa48187a77bd129673c0e2e03d8281c6961b3631b98d24dec062b8a7c7ce3bb25121fbae47f510ca0c6f0296b6e016fed363bf8dc2bc91d3654112354c322ab451f00610306a04bc5941dd20ab8d9a0afa3fdbd9518431f2fb15407e5836067b4e2d89d57761281aca0776cabcdbab2bc64747d8d2d72156def089f8414a986d23c98e43843e103bf96c7684b0b065c4910c1a25579cafa8a86c92c7762e03d8551c44b9fa755b0319360800adca726e1a64bcf3b45ac81215a7c088ee581106c2a7264f87c9d495ebb236f53f66faa835d6bb9e40ceb899b41cd22bd66618613c4d8627078607e68e4d4353db58d574728c6514519b534625bfd09ef9d6ef1de1a6315af2f923a4683881dc32fbe90664f7f57c470d412324adccd955eb3c6a54fa561d79881769363918085019e22f20f692f74a72f1c2e639521652ba564bee5e7124ae1272c307fefe2cc5cf35d8e96a2101a39eda509fb7080d7b6fdc01131a1b545c29eeb2acb0d906b24679a80ad7753bd6a7eee2b92a7ca90a458e44786af7cd4c432fcbc2614f009cd06d3ee67ee1a96d06c2e9009fe3a0ac96db5d12e203549fa1bee3b11e21318b239e243bb34d548615f8352bd115d173eaa9959d94eb645a1d23fc7dfda5dd46cb4e2546e1640e8d88dd8de165191f98eb544aeee28f74b5de765e5e3f837d3247a883716c5a490d87a2bc1659cbab0dc0ea670b6bf2eee7cb07bfca5be7eb9d9204a99c4b3ef10c6bd069dc3f59a757c993fae3cb01fb36b174f71f63c19c3db6bd0c31042b0bbbcd9ccb5789d946a14611843bdfd096c87874142b76f48a9abde35efc5cca3f9f1f6b342c8c9d64381957ba30fc595a9e2cb1e56d84b3dc39f7cdb3b98f4736200f1da169d09070da6ca28edf603d1211554122675580855e4237a95c78fc044a6aaa0854a8af02517a964e5f353e4b0cda77761b2fb0ebd831a90cba26b6b4481cd3942860afe6fa9aa839446d0ca2c9e332028ccf2537ed996f4f348ca6b447a9a7ba3bcadadf239152342237bc55ab93d807d1dca9447575e5b6a9d488e43831d4506933d125d0d090167bad92eb6fe0d8f897d75023637f3c758617df9cb076ce13633ce6988bbcde9d8bb04eb31a78ffe7554d196b08f7e3689f9cbebb4fa8d979f10f3a44270477785b8dcd93c8703ee88888e0592ec0fc361f3e00bd7f4e08e3bf449413b8b64fc07d3336282c978a0ba7f62ac2eb8414fb2210d507935f53b0a0cb0956ff8fcf2b4abd9832aed4cb3b192ae867fd6777d5880d2a0c3c17434c3f9378cde6db472ef78f8e772b583e98c71baf5c50d8aebf51532d913583ae513e30c8e88e678690cbe7160cafb556ed9c3cc4ab426909672b16653cb1eb2c10e199b6017c8364b4e029080f0ab9d2364ab31d420a7cb3770d89e66ddc6cfeb82332bcf77456fbc0955aeb324d836b641e8f8a69f0396b07e6381f85395db42c1891bef49b087b862a9fce4ea32849e4e39ff4e0ca1df0a624087328a64379cde5ce2556836410060075bf3bbcdc1f624275fd4c608ddd79d41296033359b0512bb3f01723b05f28891b2776c0b184da885cdf4d13b39645b7d4675f05ac4b20139635da6017e382760287df79ec44c6424ac8d3dbf198a0d34bcd78dfb66dc5f44faed6e9fc853f61739255af187e4549c994eeddd68fd1a8526ede996091633b83d77d5b6c5c9d7143fd18e95fa7f39a24a147c067a35ecc5d7565c1329bef6ce8dc2e2632e0b57359d5db742340be115bf2364d5500936fd2809f9c5e0d2173c13aba9a23c862ea49c7cfba9f402654c309fd12eaa385427f53b94cb924f2b4bc4a910b19f2f47c0d90ae9a6144bbeb18186d2359ecc22af77a2a53b830686d97a9837b3541e8da6a893cfa3af4c07318ea96e775e35e9f39a89e15186ade41bef3ba73cf5127fe8e81a46a23758c604ba6e14b0f9b215c0ced4d0059b075f0161e908cd6b942d7e4d846252c87fc7cf0adf14005d0453193e944241693b5523b10179c5d1a3a272f9c00b3ba810880878182f6f2000a065d0a4d358a3ec23fca006a1bc54fb8b6777d80e4d0eba35bbbc91e1ba8c5f54f8bb850fd0ba34b05c3fb4cbeb267adb19f3ad4c45aba97af997cb60ef06ec82808cd11e68125b3c3128a27571b45ebf3d81b52cba52bdd55a508b8500d376be5e318cb5af2137024fc87a38523ed2ed774f6d8812355608ebf389c1409128a7fcd6d05db7c52759ff924676412e7e2b369f29e62fea7cdb6e1c2b9cc521bd696a50366dd881e9b0c9685331ebfaf0504cad5086e952c51ee531db49170eee0f58cd41e48b0d9fb633d7f70ce9f40f0a4ce5f2b9bed0917851f00ee774497a51b0dbaa6822994987ab778c0d074a00795a3e10dc74602fd905efbeb8b3853f59193793fa76a33260e9bc98071a6d02bf8d2ac3547542d540c745ac8c3dd0a674ca477a610919a1ed133719faf48a8e9d1db79a84ba812acdb24c13afa93fd38e60a07e6160fc84c1a30b8b1a1494253c55bbb908dacede45d3498cf2c89a147b6253cc442","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
