<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b012aa22892d89dad7dead09e88db9703b567d87dd8fec9be65a8e418f7a9594cda6c4e5f37e9194e34523f3506c45bbc0d8c7ea71427a799b309ab6e2fcc46c7d97070c2cf938ed427cd7a68ad06136a5eb6f10cd8500f5d78ebdcbc5fa6c4e8db91a61f55dcb599153b7e7c835a5d4aeb3a3a091b433f0e2b78247da2ef39f21d7d9243969e5c0ffca7e6656c8e5962b9aff84009b3924846ca5eb252e442d1347f5875f5f30e124dbb98fc7592f4624e14faeff826e77c7a94a8bcc766e0dc0fef5af948382144a6a029f56d66d37121c5601d9997a7ff6d57c264863cf71a9f025af78b16895a19829e8b13e85b1af75ff759e52c5af3fe5ee2c71da68fd6fc54995fe2787a3f6bfc00d542fee68e75eb7c56d25272aa2f3975adc6f0d56e0e4ea102673a5de7c636366f8ed8e86b7d228db4d243f4259850e9ab7833599736af5715b075567e5ac865c167f2e580ea484b41bd4b0b2d7a52410509efb955247336d06d3675f9bbb25ed2dbe3918ff3dba8f23a9c1b3c246c4bcb9ad514570f333ea0ff3d8482efd880fb2cc8a88cdcfa68a519f66c0d41d25a6c4499f0c890ecf68b45e40f9afb3374fbdd98cc6fc9393af36d5ca065777425a45bdcca793344b63ef1c4cc87a6fa4ffcce0fa6849e24d6fc87b08e3bfe3e71ae2c59a42a75fde1cc04e2cdfcfb4f044430bb83d7408380df73ee39164cc6acb56b1498a8d3ee9342dfdf4ce40e37cf3f8ab72ac3674b0877252e2e67e227580a0cba7959c43460f4b31be0d11e1804cad418bcbd5171f505762a36d5bd911f66f4fa5da516845fb45121c8eaf6df55ad359ca8b53aa082064fdfda7a46e114fef7dbacffe2bfe5a81ab0cef9205ea2ba911b8cc47dce2a08215baa490f004cc18a2efdd8b06ace185345e6c5615c59fb6c05893477b82c7da30fc0901f603ef306525a77b93035facd0b9c3bab34fe9fb08132e4ba45d24d896d878106850bdad6b73ea8c7c8e2cacd0734759b6cc14560a2e475f07a50efc8c2acf009192b8a3507523eee38157c5b602a13b405e58d41524f8d85fcfa320d268b8d1ce6e2bf5e836eba649ed4cd1c41c89b95840f4d728b9b4d89b855cc06320d871bb69c0b57a1cb8990136b6e8ce9ffa6da7f12422f09842fb4c5e2f0ca83d4bd25cc115866248816c989d3ee658e422bb34dba02508d972ef0aca1da1a38186f81d2120321a9dea2743cca258177192741aef38a008f4629a53363ee2676f3c3acdd6141c40ff9378c973f5aee04c7826a2650d6ddbf2fbc907f6f90088f02aa7d8432a8a0be42ebe0c6b85102a3cf6c025d4384108ca18da1bcf6e4db1be74763e71ef3fc3b8ee7e2b55f320dede97bb795d5b6779b2a46a7bb74bdae7900396c07744091e4d1073545c2664ad4e36a1ee68292197c28542d7cbf26ae5e6bc3043d190c7ba719f0e00c9b8f9110d7083ce1d1e0b7e3b5c31e48d454bea63ef67ec48cc4c84c502f9ef134c3cb44d18276062e3b05770b345893cbb4b7abfa9dca9e9b1cc0b414f44928a0e312ab83e42824544aa10cb2118d8a0d9705b38585db0308def365c5480ca9f4068d2cc9d2961fd676e2903e1ad28ae9b39240751dceb556ab27225afa9db15256235ba9dad8e2fffec9f32ffc5fbf6d51b024d83ca94e4b98228541da1a0a9c09c82de7ecce3a5b87d0346672dfd9f465046df1ab354d18f690e6e02c6e0ba69c356926d493146ac44a4626bddcc1b62cf1b2dd72ed7fd246925105d7faf69e258afd7b4537b1d25d0d89fb153cbaf575663b18e8b02c44c46e1c5ce0ed364bd9b35fa4676f687bd7c2a2d19e8d59501db19db2276e3da992f9dd2e56135445b518026001a4ec805926e879c984cc466fa383a5d4c454a31e58ef8706e8a69d770f55efb6b63f0effd33a857b8c5f58b12bc9ab9a75a4a7354de6025bd9516f0cfdd3a5f4d23ff320c8b1196965581a196bc04abbe74569b2e632f9412236222c384f393092e59fe6426af052b1105a25ad1f4c1f8ab29bbad38c90e7a6e32722045ee3bfed99b7c341902ea443fcfb2309b16926251151ff97565d59e48ad220d8a026bdaf98f18a375a8f0cbeb4e5d6a4de0969f01f9245aabb5190d990a2585275485f0f51c328e7a89c84571473106ec8499eacfc1d7aedc2165a6dfd7eea0d9992514637452f557ebd97adbca5f718909d511aeac4657f04c31a7d40f53bcf7174c20e210ac84037777cf72754f474c00246b41aa9512b4d6a5a9b8140156cfc2680ac469dc7418635594f97d1aab343cf55ee742a622e7ab010da92586575040aa5d05a33c9c763dbcdc5e6215ab98e0889bcf49f4752f99178c4f37d1f59046bb84c19b9f6a86ca6699fe62ac40a845797ca655ee53665e23f22216f0ac1e260f3182ab1d72b41fa98263280ac1330e0ad52e603a038d784143063b5169474e4be041de4c57791a2b6f0a9279251334fd432f6369b72974ee7e9bfe3520ea8ee75280ac710e3273490618178e104c9fcf4768d922e87abd0086f98475b18d32509d35d0e2860f50794d8e6489eeac7b6860faddf3389ec98a0f6cc159447e32138490eeb0e2524ba5d490ef1eb7f3453eed0502a7de945dd29ff1d72a1479b33da1f48f7509659d81035e6d681d356c24d3e07a74b74ac1c36d550dd9214c4937774d5890708380e6a195734c7bc7a6c7daad43e6bb9f1ad8a5925dbaa2c855ba28e6761dcd95e4afcf4360cb80d18fb101852b80e355a9a799fff1da8bd4344f0fb8ba36922a3a43521cfd73c6951da8c8b89d5e2e2690aba8a98ea3c06696de2d3460f718e62867f97bb1006a2c9b94c16979e4e32435b005dbbc696e9c2faa8956c87bf8ab7a45a4b0497cb81d646a6f56065c9616aeef2b0a898e025b2de67c4f6e34c200f69249cd1a0ed9de2c2bbb2554d5062c92551e15e3b57bf5c6c5a958b93a97145b2766a4c16287fa032a4ed6ccdc33c4dbb223e7ee4dab435b7acdd52bfaf4d2f8c1a00391692a4dfb417d00c4c7f8dbeaa24dbcd5cbccffe1eb3016938626dfcf55957bda6eeb26367e1b47ba76b712264f4ca19f3c9f2d3cab858f2a94e33b856f3a73dc58c78cb3e15b2d827d329f05cd76a875a4e46a0d384c01aff41e641d4a9b5374fae61d656dbb9c45741fb622ba0c81285b279d48095bc86594c293a69b27700cb7af3a296608f56efade5be68f2cd27419651a9e6094be2f2e1dde431475c59a4d17d6fe3fcd131dd7a23aa3fbaea742542e8222ecfb37b77aed7624031bc393750fe854aaca18631a062b5e4b2b41be47b51b5c5c52da701bbef81235c84d7637ea08223e83bd6ea0c01a620c8ada5fc198fa496de3675e0c1cc43014efb2d5f1500b80b04f79efd8d75be42385cfd813aeba349f968a9b0683216bbd388705bd808b5a39843576d987696aa528b57213ea03f1aa76c0faf70a512576fd70849d71cc39bd9195a83ec02f42e39f25c82caec648be01b68bda5061eec3d0eefb136a0db9fc0a8dce69b7fc28c08553c927f91657e0b1ebda5e5546eba3abe7674b9ed3ad94f3fd85afc950fd03175c0875f1d498e4c4f60ee8f456e4657dcd3f985a87a44699ac9d7de5f1d096f54317ca9d8c983b4d9d44ca56754b4f576c60995cb485940bd15ece5c17504ab81f77ef6a72b6c774042ea7c490fee10bd5575680672b1b25cbe35d3035c8b1de8918f764b602cba0cb9ffcd2a58487d2f050ad0ebeb6dbbbb8360709e32463980dfce2e08ac08583dba48d884d76694e37fedeaff7c5025fb26cb2b5afefdcc5446c4b612563979e41c798a7bfa71f8605aaea3dc8043abaa0d34382d87bf502e0c48ad3a6b5a2bd8ca2164b3f09c7a16b4e0a198f40a655425af4e234a8272c380e811ceda0077fea2bafeab96249a462af4d5a9d424dc1e3a62469ba1c5ecd546388c69766c4e11f70d38fd85f4d1b48ff71a0bd094363d2c3899fd94820942cc6fb31555ae6be74bcdcc17085f3f05f4840f15953da2d55a70a846ac757e73b14c1037f988c274e3dcaa51f38c2a06d28b772100d93232e76d0bacf1fb269cec45d3610d5c6bacc233215d9469fb64937fed35f24d6e276d229c2077f81cc8f83a5f908631227d4edc5820e9492c8177639ac9f914fda5e3df8690fe781c4811fb6f7c6a5ada904ce7e5077b644380ac41e876bb84c43ffaf10fc2986ae8ca46d7df12c15f01fc84ef77ee2b361339a7c67b042af543a7b7d5d39caf138af8e50ec819779317aa5cefa0c616c815f79238caeef6b920e1a48124254004971bf6c1ac8f5090f1fe8480311e9f919dec1b626d9197904a9f425e2b70ef2cddcbbb949bfaa09867fbc9b2dc5a26b2ca1582f4b66f5ec4852e24217a8222c070e20cd2934a304eb49551f017d47dda846c756f7abf2d2a7e60f03723bbce080a0642adbcb2f2015ee73a2416cbc2062467d2a54d82ea3446d4341b9501f5cb404990881c07cfe931d2f09c73841c687362b82f23b8c9a140c0666a5a240706260894b877a65005d3c1db46695616fa2e1e58ecbdd307d627b277bd2d14d3917fbb90c56fa552c9c4b2a5609a678357cb137ee9637f6b3126bd58a337c9d2406698566de234e1fd8c2daaafe1a8955aa886e315e1ec04010ba3a3e87252f0afc1f9f2225335f88a2ab2327e97132765a275073bba9e79c2448266124604d31983faa609a4bc40f1c40263d4edbde1a11cd875d1e2c61a0d51979613ecf4d49ce1cde5cef6750dddab6ab63fd059cd2da48f2595761b50af677ccc56a2d2d4b52278dff36d2b45335c30161d6d6c1b776ac36b9e2a9f657120d0ecd2f8744a90455cfcdec8b106ed8865b71acb7d355340b4247aef0593dfa028e87cccc52cb9729c5d3707ace2ccc5cb484043b7ecd2b5b2b76fc3709809fd07c167424826a20a5a4b5b70690c0bd6d2383bf0b73b76aa78a93bfe19a53c8d2195497244d6437228b99829c936770bbad2d2883d46c2344df85fd3c69aa228d1051981bf7a4a4b39e97d2649c3e4c568351940dcba63b697f2796ad0c9d8bce26fef189828ef4e7d3dbb1ced4db54d4fcd5272dbd5199b09ec0476615ebf0e6d1c5d2c8c5a05b863cfd75b88eb3153a3ae404fd0a1a9442019c40f5bee7a974b66674983676c212bf89b7616991f602fffeaf932b2429b1fe9de28a8d60acff26e367b5e0a96758bd3d50581a581ec4cfd0a018d6888c78fa9c0cb89eca91f108a87918170eacd036d80d4deee1b3fecf01a76a3de878080c2fe869c1ebbd3bed873bd3d7dad265c5f5d5fb315c6eb757a7e5909b264129afd57e26ebb9d424ed83c72b2d17a6da7de1a8faa0b57423a43b69b8637e4abbba9cbc340c34730eb77a082a8ecece6c3727c1a955482e07469a2a9e09c3fa7d589c31e8c38a4d3b4abc3d982a9efc1f027664884acf29303507a51b8537e4807cdfa6b28a43cb270c3b2eaabb38735226232305397d8df280680d97b2a71d9d31a6cfb59f5c1cad37984f83db0c3070feff7433304904e425e63775cac7a9d6d7545e9861e3fadd89616c40e7380458037d24dce758107ffff274d6f01d82fa9f59255b2afd7c306412f0fda9c1f8ae94a8177debe93b6beac5448fbbdf6d0ea9d9124fb6986ddad98dd1ff50cabcea9233ba7f2209130b1add22d8fcdecfc90b6377b457cac00a4cc0a5af865d3cf40f38317ae493d42c419838c314219ad94ba7095929ac723677e1c342bc926e84da264c6bdb8274e812f46367138c764018dd830b497a271ccb44187b71ebb168e12c86e8e9cb991ad69b1eb850525d840e6af00c8c5df57320a4b47c2d5ceb04b8a3299ee91420ed5963b58513b895770c50368c0bed73e7646ae3af499a1c9d2adef4ada4d550eaf1da8894a6747533b59eb5cff33c328d8a3edc5d1083730d1aff4d68dac074b1261f8d994a0e04c1f55ee5e6382513132f5f853581384ea60f246fe900cd06f3481a4ad1565770b3682d02f309de70c76fc865817293682d25d4539d99f5b188e141be04bb2bc610125da666bf27d35c0586977af5de4d896e5818f20b8c981e6cfebbf56127d46b7db82d67aa67fcffc8109175e42740b4eeda6f7eb64521af25380886b4e3f7292db21b69c479db178bec499c45f334dc56afaec2624f02de6c53b3898e94ce99d6e79347de452496f9600e9084c48f80724ab92a8d15a191158ea420d6fde9c95058846814bb374a2f759453ea31128948142a39d099093ca4b453d0af2e831f0d35a5bc966a589fb469ff3cb28a71d75a88f3d956916df734bb45639fa161309de9f606b83f87a87a95c9dd5c37942de3080bae7d4f0acf429010463804c02fbbd500b76e82e0e3bd556e369a412eb149d80099f256e1a3388b7cc4e73fec2f5f18673826b1ba0b4073e08721dfaddddb229d6f8f813f1aa178f42b87bf4dc4db4e0f1a5a193b19ef5be5b353f9201f8da630d6e9b12835ab0b62416fa102d07b677b147025939d6971091eb9f8e7e343466856498a4c233c69eabfbdc92c34986794f3fb3e5d75646ebcc8df1bdec89039114da03ddd8fdfd3a9a0ff83846b1af8c86c836a01a84561a6d59dec39099ed1533d399e6f518ebabe8af68175b0b1a16d875d5b59b42d6913ab956b99b0184a6be66f975fe71d2a20591e13bd608dbe257c228dca3278c6bf48307eebb065dd2e6acd5c2a88ea262f0553f106ecaa4ce1bc1b3735fc7a52788541bfe78b25a14ada12574297c144025067e0048a1c8ca7bc05c8d049ea30ddb49ffe7fafaa29f492886bb0904cb10fd9e836711956d4e46c9f52cd331026627da6b688cb799216d05b53ab1e1798a7492a89854e7b013f90d9d7fbd26505bc6bcf43539826775a44dd7d4c6cfd4c39aa78bb93e90635c280f2ade131f1db7e12c68bf74093312d484389314ca26ea022a0bad897a0c389e5df8ab5364bde752a8057da35ecdcd1af27f7546395a9a7513d8ca4c2f2cc04bd2e37652fd0140c4d8d119a328fedfe43f68dea5632f55c5efde5c9d74f951e4a72c66825f4e986b02916e13caff9e8b2b1bfc77411582ce3e1915672ac451b469324ed8310ee7c8d3e43bbd2ab9d46dad90523cd260d42d757cc54ac81d4428c07bf1a0a043dacdf807ec9e55a8ee7e194f4ddc0dc655b89f778fbcfcb18de44f8e879b91ec1f645f12e25b841029b8e9c3bc086507cecbfa12b4bffa587377d99572fe3253dc9a85219c7a40b59368da48504f247e36ec27000a2792b105f351d5686cd32362991b539268d3f661cd831d0843e1023a2793cde20d06b196b7408c481af847dd273c8604a7560919a99ac41253c41c58fced740f1bd982110818b7686bad348182b51553bbe7ed8224ab3b775af608ebc30d3a3349f392f88ffa05f75a3378c3d440adc502a2ac1e1ff131b4676116a1f21ba466d58149f5858d156ada6d94953ee5f9f390791e7a9569eeba708cb16b08eb938bce8c5e554c151273aea8aafa92e0bde60e6f5d80027a4a654db76acfea10a2cf3f0d616a786de56f50578e39914261828ead7ecc806faf26c5fe733fac351249c830cf356419b0f3800b12584e5658da9da7fccdad3f4b8153363940f1c6358b51bf610bf026f678058a4aad0254c23ef32e9f8df2a4e4125404b694b1e04193e06ef97baba361d0933a4099159ed4b328a4b11079f900729e1b26322cd676c6554ed489ec3b90dd44bec4457b5a1e012241df8ea1d135033e9524f51adbdccd34c9a044ca0a3f87c60b18bdfe0e54e477c57dec83140fc600bf6f604a767dcf777bf6e59a0ad4067c5ccba4a1139154c7c22e2a437e3150aa6c523ad8e670418e0f20e78ef40d40c920d3519e0e883b20a911b77cbc33a2b51c17d8118b4f594834fa9a85dfc5567410cd42fdf4fbb7efc7ca310088446ef24e96194227394e5f3f4c16f12c941a10d7c26f7635776fc3b9d37c046105f8b51a3b5741c71fec30278aee34b45d72bf1b13cce22cfad640de4c652f59d5209435a5518a31360c83420a040325c38661ddced5ff9d02cb2ff11efd0d6af7fe5e763711f560d187e69faf8323746cad3c9621e8fc03bff2c3e0d84ce36bafe0d280a9936d262a4a1e82670e740279f90d85de5e614cf8e2379808348314b31fb5dad53bb4cb4b3e35fac085fba00368f0b1b63242a83fefe5b5eedc0e8c318b7d866e31d0b3bb61a6254f0745547acfbcf45b992c7e436065c7af392123def4546540f1c1039f768b478bcff9b66561479a70134fda985d09e6054e856fd69c9e522a0c919b66f46ab769dd60005a5097d2fd3d141a351ea0d0994ef108e6d9b05ca24fbb105f9b658f06f75ee7c779959498875202ef49135de3daac2346ca9bf1872a8e349f7e1937f6fba496b81516ad3b5084d8225bd00e4a854f51400bf137b1d486f149f94aaa084fead57d772ba3ab6e97f4914ffcc9e2916fa02f686a9ab91438e676397f96c7c4044c4dba556cc710ce7e0d6bb4e18166cdaae0f2f8fc905b40262959eee15caca3f3e79e8deab879ea758a2790e758d6d4014101f19a9cfea1f137367df9f804e75ba2bb4ddbc0311e2baad892620cd3985d12ccf305e4a6cb8bdf64339b6a7d9431a5994bab4d871a792825dd3861e497b4c39e5b45c0d9ed46671df745a6c00d5de39bbf8498518f5c11146937256fb90b79e7340fb1bb33597065809059ac1a574d77380c384da58deb6dd91e8dff0658bc9644a30227b17930356548f7ca4b58432d6983a317d3f225f77988c0eccf665965d6954b381b0eddee81d1f65e3280b89644a83eeb80d06d068ecc3fdd72724322f4c25dcac6f2b56a1ff5907d1c4e37a97c7cca3e98a90f674b328c99a77b1a332e5bc0286c1bbbf219352ad4b5b5fce3e9cad2248a59a7eb6efc08593c1f6e3f48896aacb2a22f995ae132768b6c5145026c48208c624ea185eedaeebfaea066122f1ee9dc01a95f3f0e88a8c2621bb7c574a5a35aea1d2d1e23372cb1e0445a837483c7fa41c601afef94600c3ddc802050227ab114126926af8aa61efe21ea58eee32eea63799a8a28b939c0a5d06cba4c034e722acb84474a2bbfe59211f04c3433517d0c5cb74bdbe118c8dd78fcbdedbad11df7360126c904fd74daefce885e2b18c4824c654f8a5f1a8e87e65431b6fc01db13bd6f7afbc5f4959c244fc15ed237f9f420092f9a810c1e209351868952f6f5cceac6a8e3590bb9f262fcaab615d070f80f596b7ffbc46dccfbc4ff396ca8433f157b6b9a49791afe01b83768f9012d66bd0201d6093078eb093ae90da6fca1f18e65c637ea5da923faf9f76826552246feb23f18e32916f2a79fa02bcf3e9f29d36fabf1f6ddf7d0f8f192595a1042de5a3df058ab8bf8dbf968d9420a153d35626491ec1651191483a9893ea69e1257f813061c34f6a9fdcc98e728d55998839b749fb16dbaff87399f2e9f7de61f0b8433fae5533a9299a63871f134dd76d9b29cdb162164dd17f4549e4d2bf4731956f719f3dd4ca0f3409fe66e6e234a2950845c1fffe76aa770d22111c6f18f380ec2076ab473068583e3ebdc7706788ee9e047d782d1b1d7eca521034666cfbaf8085612276fc05cc627984829c6e67fc96e179cc13bdc161fea1fd841950d656bff831b96e31abc72de3a0bbb288e8075a285466147824cdfd1a8f917d80c93b5bd3986e2a5b517b2769ab7d1712deb21f325ce20d37657204f3f89d40572b18a5bec198716b36d08955840794e1aa9b42d1b90e52021d6ecd6f8d3e21e5fdfe5e77c2e537670a26e0e191fe3f8c867f80c1ff02623358863cec67a238a8ad4760757c6b1afdb3bc88eb03463f4a74d1bfe1bbb2d9555432335fb86758f433f9f64a733f6906d482c8bf555aa2fd133953d123daaf1f4238c108fbb2da366097b19837d09f3f393d642c443c2aa7ebba822a9196b67d53df51d639946d081f9312d01164dc1c94c6ddb2817c1827a854430bf2a80991f99b0a33adb120a3686cb10430d86c38f94a1cf842da73bdc7a0ed6d48def154f37a7233118affd16d9e2418a26c5a30799cc2a6130c47661138e1c2c302d655bf51713a7687793ee02e5f395f560c00583d8d85ee23a470aceaca6c9eed41ed0987ae9d8e3c95b7f66e8487445ec7c193222ff7e1067c3eb1f8aad7bd517d501239cd1fe5e83889127b1e2aee16d7f1e55ea9804a176200c9153c0c5343944e5e3b19644cefc9a123bb6cede5c635f5c0f773ff47a4007adc4940b1e351d9490f5ad1868883d7502f26b4201e575f776e2c09edbad02c1976e53b5cc42b80a319afbc3f3819f9ce8159d13651f279d297fc8b573d11c51bf7412e4d27e1e9c8bf2a57c5163e2aa734a73736de88cdbfbbcfa961247446cfb267b375a4ae0e972c62044eef78aade61cebc632fe8b21b14882246f860f786940834bbf4288fb3df492fa33012e6e0a2684b19b71e1da61775502bd3df788bdbe43c11313cc181e90ac4587746a3f82059f5e15686b5049c666ad2430198e0d93113709398987ae98830bc9873d01afc56317157402725d879f639c55a98dcca23aad2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
