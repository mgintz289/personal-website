<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ce70f9553e0557efeb79e85ae3cccd81bed8fa238fe0b60ee501f9ce713520833f3afd208480d596145e300246838ce06831e8e4221ff90e86517d21b9dba7048d96af3d51f9b2b5bf76387d13f20ead9440f7b7f7fb67388f515904ab0fc255515aa7556832a3758bdb49e48d7a0b3db68f2c5aa0ada496c71b868780e15466da6b453564543e7914d61c4e1989d5b2a6a5192d5045eb85b57e6fe201db20deabf4e47c3cf37b427fdd1355d5f141ed332d173c9539bacfb866e4e477b8153cad3e9d24471edf9dbe8d6aea1664b3a4a92aee72da8d034123e901247810a18f3f30c2248eb72008a002eabb893080f99094f78d21ea5656932575deaca4e3aadaa91c735462278b67b0141b3d2ed653be9480bdc3b255fea791b92000ef55674da05d9b9935c88688635aa337fdc62cc55bcfdf4fa37e14223bb3a86e98a18f75fe1c7eca538bb26bf302a9019a53a9316bf82073243fc4252c373e1e9e49fa897edbd2cdd132e6617d6f949891b37a43653cd0c4216fbc43233d4e8ca6c378aac2dd227b65dbd7f02a3fc4a246380dbfd3b81ab54965b1e6bb80f6318e87eab5caa613ba1098b81c772c1c35ea13b7a7747d1fd159c82e719fe489e3acf07f1708237469e5563fca2779884f974e7ff40b4aa43d30fa255c50d8f0422c670191e1a6fbf79353cb3048245b8d6a71ab6f53f188232fcbd754fe852d8b22bbb528ba1c11bb7c90e8363a732c7f955173160491e1f7e41140f237d0d4067dce8fef9b07b442c8e4be9cc88a7ec41527077defa1cb9ec44ee53487de70e526558bdd5a0b4dc9ba1b360dc297d01f90fbb001e8173816b10690589d72d5df6c413c4211c1899dc86a4444a31f802b730dc45997430e5995779d5bbc356040a4a0b93db71edf3d20aaf8fdf355284130d0d217d5dd6b0b30b54b3ff26a5202f8b47bda4337025165859811daf891137db5d31dbd0c2445d7a7240313b2a3abc3d2b82738f0f1bc1fcb04fcf635d93523f284fc8ed34cbb0a42c30b20af4d660100df0c761806bf2766bf7a4914580572070fc04138ad68de4c76c9fbaa3f12f5a8bbab08cc78e7e6bc053d7823983ea27626da9c9d7515a64a003d165b93572ebf847cc9a60246c197c725d8282c4497ecc13184c5ace2246f571501079f1bb1fe671128f55a9b0aad096c15299ff8096a052d4c21d694932121d10ed45c83ca24e15cbb43c628052c1af4c22a0453a073d56fbe0e113d08a964a43a5fd0b746fb27edca68d6e2daebaf202be9f72641d8a338f766b00912811d926367b5f0449b2231bded0dfc4ccac1fedf0c3028a899225e0c1066e0c221ced73a8867890ce73aad775f513922a5acc74208d2fa960e1b52a2c6fcd219b8adced9fafcd9bc02fb0f708dcccb654af2498ab2fb2d7ebc3e0d9dc0334f4cbc75d1af5f8ff63a63598290365f7fd4c4cc93c2022d1390cb8dcfa93923a711b1b146e615dcd1baed962262b7df4030350ed5e952b0eb38248352690f5bf6db0a31ff0c0fb293cceade3ce770bd240e6619b5b514e7f154112d951046aaba0542ed5a4740602cbd0496aefd6da43d23ecbb4bf60f13faeaee482cc02307c367924dae0f66d49cf1192599ed8f1b38ebdfd1eeba257fcedf37e85d9d8402e37c71e96ed20dc11f74dd91e7544d2e1ad99f0ddeedd54158458fecbf33d2200d303fbd2601c493a788ebb0b916209b0b4a7913928362c884fa6b860d3daa207523b2c071916f81fdec323c62a5f93e5700a5622b6fdcc46131440111ee26a2b6895dc2d05c536bc1f48ac21687e2a1ecf6bdb66ee57d0d7dd9354e5d82c26b96e45de85b43861313137a929537976cb528ba7968d71e7b2141fb542f2383d63bab33ca562188cc57e8c5523272b1cfa10e83df948945a6ad9dd9c1422b61d37b80870477782785675df1ff9c0d0b0e0be76f574c0f031752706e3941ed702b9520e0d841fa3add64c1626799b93519298044dce9688a27da4f6419e9062bbaddf7a65caaa2adabaab13f10effc91db251717265152cffcdd397eba402cad77d63f4a379943050aa708c83c570690fd409f76ed8e39b8e50c33d144fce0b6e52e3739acce67693cd3aa1ab07ff26848c92911d681f4c93d5e69fde071546e79a6feeecab3f8af2b3027e551b6db2e9c4addf3b1414fab51af6bd9f85f1a6a5eac66eb37da1a0641b885cfdb06bd3881dd81cbdb06fd06079f4d24db166404c6c301b098b6696774a25245646ca12e08610b9cacc5e4420009b2c3946bf63b36cebb6740dc620cddbc0baf31babac6a48b293a1e476e074a5adff2bbc5fad627018e595a005382b4e760653ddb99d7c3907294ddc1fbda59f1fe40e68af4f458f21cca0d2739a2e226cdc7438399cd778d6016999f22abfc041740f8865d3c453f22e50045d9038f6748874c8afb1e74a578371274aba0e50ce563fa96e71a8c9d77318037960d7dd02886de73999afabd9a83adc33b3f0ad95c2234ea9bb2596dd5ba529bd8cf5425e0894282acbc3a537f994e1aba94ac8c4ef0cce695f47f66ceb64793e73904a29fd2c13987e560f1bbefb7186b906f8f25b578a2f3b3139488fce80bf8beb450c261a0e660883911bd42ad702f27f27fb4a237fae5a5f297d2972ea4e8ffc8d3724f0fdec5876d065c274f6a5c2063f0a1008d4cb928c43b0da010ba59e44cc9751e387eb85d65e5eb6ae4b81b6af9265993dee2d6f402e5706a65ab5a54b89644826ace02f3f83ca1dac8a1163247cd8cd1c8f2f40e47e26a8819e74cb4925bf6b3d1f5d7e2de4b04c1a598314ca4ed207cfbbd942e1c3e433918476c06145858ad1b1d16671e76cce740235c2ac9638d51f8953ae7b690163b53423596f0c9173f3391f067a8c744b48d1d22185ffe05e80501bacd3a9de87b35c9ec0fffd556eb6541075473d37444704240157c6aa7c80d13d5936abf82d96aecd7e25220293c3b833f09b5605510f74a3648b81c9d695523b7fc4afee9a5a61e0d4a44faa0f49b820abb63fe082a270e55a5a8f914cafdbcb84317b6ff500fa85b2009839baaaf2c35ac45653854b85d725f7b74047eed2afc6bd8128a8d5d9e49862027a36e22931fd71c68c12525fb6a04dd9a8cf1d3a120da65dd9400e84f7c8340ee5adcc71bc10c7093234f5f5d75c87f562e70ea8a37a138b28015e95444418e28a6bddb6cf29e0824d31ab2f36322128bc82766f2c6db0ecf00e17dd0b174b638efe1603ddc5ed552f9ff5e1e95799142caebe569e515e5134dde17bb65f380773c260bb57d58adbc130987aa7c36e8a713918b131d808ad19e332c1e3f3379d544e8fcabfdc904a7430a4b36b8c7b592ac1ee3965ac6e374bb4eddd66a27ad54427f786a1517d9053bfc7a6988d20e28bebfe5653c07b5571e95630cc2163d6ba789e53cc1797091c58811856a7c359e09372d1abd9ffbf243ad793a08ce62c4f8b988f43b6012235621fe1edaf8f0ceea9731cd793a3fff6f71a1e9f08ec987a3df47fc5a03d0e3c7e78f2e1d5eae7aeb0c5e1064c0280925d8131bf6c5554bd0d578f2625f91a486a4de2ea84f77c41a888bd081cb1d593ad6a1f2a092d222705b457106e3d8fb9440a1cda62c6931046d253e7818b71966548e5bb9715f15c35a45df0eb156c1a31693b34b9924e1db89076dd7d1b06751108603bc639c64aef189566cf71128752fa0b213e484b3ea1d7df07190057cf9e6cd7f10e2369920c8f0ca98d2227656dd2ff730426763a86e608ba198d9df4d81c15ed22fa12889ef6f841ea5f2af1e52cc81ae51e7aa98f7832148185d2a8058b49e99c26a039ed21c70310a5d53010caf4fa39ab168ba504ba3365a02f9a8c7f04736dbf2ca81ac52eee0f89c9878c84c909ac6b84ff8d39a52faed0dfac8b361aea14b7cb53e5bb82346cc3c0d39a5fdca2df99b96dfb9fcbd7a6ab9d8ea644194b5929415bfcce8a869f1a91e41503c982c333e9e4b7d0b0a1c55bc0ae457732776385b70970b89e5e2041b79d26ccba181c03feacd0413a03fb8e996d44aa439a62aafe1058b89ac2b34c90b659b1896a36fc1222ae109ed89b3f2c510789b5272cf3f6d22002e2291524dcd4ae9ff3ecde0dab294852baa020bcc95917934c20a3c1c04d38e644da1e9efcfb9132bf467c43d701b5909de7da8fa1ee5ec59af8b6c8bc0383f9dcb6c664c6ca55895d6e3a524e4ed1961bf4715f22dd8a2875c447b486415849a623da9f64901b28512b6c0a030ccbb4cba334e07ff07e118a913dcdf64872e6e1d3ec15e391fbc6d275dc737dd4ed59c87b21c4c6f426f2254a7f4058232c7017b85ba621ce1cde08e3618e270e38bae0b07af22230f927f475568b6cf364b95c96948ebc71ee1c9b7fa0cf64ceded5ff9df946747616df9ab7792e768361e4232c70e988ed981f96b4a25021041efb85c64761d34e0f24be170b49b34ab80c985a94be14a1fcba1b7da3c9640b2e886d22e078f87e242ae946708720481be21e48847f1b4ddeb013689c239f87316196d4e974c6a25c87337da74e3d6dd38b4a7413e2d31df7fe26c9a3e117eb8dc6ed15c2490449bd8fc1d091514e9810554909eeadf1e8e6777e72726097b9600ac0493f59fbe98e10f9ada0d7c9af582109d67a00b5c87f6e6caedb565fd5a35911da1525f4a0dbd351eb935795ee806a464b1f2a9cde2e1483ff96d58b0a7fe0e912b21a0b7fa0fa1beceeb8720179ca55fcab9412207beb1caa66d9ffab55fc4f2fd94c414d9aba760e84d34445f3df08a5a64a36da274f1c49cfb11a4afc0c5f355ea8427d001e8af6727bd2279bb2501b8c1130a7b1b280596218988d76e12ebefa65253066cc54a4a09bd472076b41692147546de0baec239175fc88e769c159f7ba1f8aa442c8755bf593b29932a767ec9b1f3dc387d9cb3e358d34639b90686e12cf5ecd0cbe1d69eb163d48670234f7606a8f89636c21451485d3292179abb2322f9f08ba06087e8d755b9c60293c009b73e4cc5797c14d93588a3c44dfce2b39f995434279808462a2dec714e9f56ba15fcdee2249fac3a2813c28e1bac1578784f3cd98405656903ccfa2f6f4b9a1aec28978142b3658ca9f8a1a8ad5455923e0ede9883a8452cb3055fe36011d3fa4274316655e3f459bf4a90b0a5a3b321119072f53d3a397d434c73ac261aa16dba9c0128d04ce5abb9d5d09f32cb930af69448b188d0980e7a60edc21b1c9a13873b6214f6480e2789ca4dedcc0fe253d235e193d3301f5501c67ddb9f349329210e902352216662a6cea6be7a25770b89bbafbbd2be0835f80ecbff03b3856c3df23f0eec70078421664bffe3ab648004fe2a9a6e62d41872aceda6a8422b152afe8b3f4f7576d799bd294de677e92de049f681fb4898f7f95e89af02b38036de8b612231f7954918e1c37db3112413729813e1ad0d1d876c6f234d76343323aa3383fe9e5944080cdd655c5d32a31e35caebb677b6a19f49b05af6f270eed0f08c54d2d8f7e9c2ef757db36b70152fb8b3a3d5669ea0172a865fb45b74a1e9410fa2e0d643d96af5be63b55dc225a30d35e6a23c29b93f00f914ff7db9e05f3aeb79bbfc91473faf1243faa75df8dc915ddd6c141a840ccb3ca8aab96ef513a2a4991ae6b039b0fe96c667b303e5dbb99fe914af993b96ad3efe6875c4dee44af1e7b10d915fd4359adf711177c6e12437d4c8629c1690742c473739b4c3c08fd4949d347e06d4cc7f133e6f0103a36271e90edd7afed80aabb616d7dcff125364228973992317f87f78515197111c43b95bba2ea9a49963a7c5e3a45ab6de5dfc875b4896d07a11c8c58e7e98c1ca9c49746defe48df0ff1f4e5331bd90a5ea6a74f969361f3d477a2cfc6ebbef46ea13263a84d9c738295dd4083a736e15638d3576fb66aaece66993f3b57cae0eb717810ed68ecf3c79d6d2f1abe51f1185baed4d39dc861de662f9a2520ead1dd7f9fe8e6de5339949a5ef84ff6f60aa1f7092e25b4e37651ebafdef7e0b7203c565a86f51c2c1ee99400c192207ad30f111a3040ccbcf9c6d1e8f9c00ec073553795aabf9524e2e2f96dafaa5d8a23523d14f910876918ba1800595a703aba8d7719f2bdf3e5dc614bc34788c65ec8418ca74a6eee80f975c4973ac0dfec3dcee5ce3bd271612d9141ebd1fba51659af437b403ec4e8ffff693d2fcca42e8d1b3a67c9d1f284e527538af5a425e948811a031044ad4c92be7f477b637c60d2f56dad1551f58a0ad6114ba9c31a69e8d6597a576c80a217f87faf884960fdff3978b7e9ddedf3899a3f16c9defb948b5468a8207622d15e85a2906f222b1e675349c557c276bbe633e3d707bbfc51417ebc1c46c17e7d9180ae45b43034955eda4454f9e79acfa481b83552e07b2a6ee5fc65f305af27ecf71d95f59330d64cc66bbfc47d28fee4677f6abd1d6682bed857bf1c7ffabcb7d423e8e4b4b15a6c1fc8cbcce292cee4c643a154b5e6480df2de14df85d7a8935398d15458df65f1119b094d152552e08344a6ec7d2d2fa4791db475702dbd87e2f6b013447778a42f033c0a68421fdc7c41a42d3f430fc9d66d205cbe1b63821c56989e8a2fea1658cfb6360acede1ccd61e9df7ba9aacc6f4da8fb9166027f001371ddd8b0c3a634acb717a82cafc43e43b074204d297595c40faceb660619dd1d38e312a022dd26a29cc7abdf6046fdc85de3ed3e4cff07bc0921198c4a293e92d7e1f97076593a0bc822b126137f3f97519bd683c53be99b5462600d502462d5046a37cf49aa8503aa129b069e4a8a067d7e255b1fa6896ee786789c1acd8de57b9dadf3312a2ee6476481395fde61bd207df36fee76926fec2d100423ca9fc00cdce54e622f49d532ad91d35babef9dcd91b5796ba68ff1b0dceac29537edd1c5d15f7f93435c9000b4af6d2ddece96f2446dd63c35b839a46577ad66bd2aaacd621550ac1877e97ef3632751bd386d6377cb06bc3900bda5fcbded0b97dd9beed2d2ea159e770612e4893b9ee3223d9b92358fe9f9adc8e7ed8701de41831413d9894651261698f67b7c2260455b1fab57eff01973c1e7d55b2b6e043c1bf4d39d5a5a6e0ee53d49c31a66b6ecb4b80fe99f0f37ae30829f00f2ad1f328bdb5efde9ab9967c7cee1a936154c3af2d8b18003ace81fa1df7c25c1d54c9c6f64986ce88d59fb1b1f5301b23cc14ee456fa33481ff8ec619c3f6e3b7b3af967b20068426e31625e61c72cababe9806577a6e65a1e295cd453f85f4396c8b04b4b3a49f721ef70e531e91c4f57c7fafe4fc2649d592ae13a62fb082639643a46fc62f7ad8640b3d9d7bbb5a8e44813dec12b744fa17a3dc29e504905777833b380113eda34f91791333598f6faf1ed5e8cd1e49c05c78577fac1863bf75bb1f2a02546285a0995ecaefd38bb5fd4feada011888436b262eb939914ba5d5aaa30e5b1eef603ddfa19e2645f0993967488972488f4d1ce9ed7c1382b3dd5d44da901fa9b5c56d0be4732d7d4a540285b27c2d501bf20acfda52c7282b69b9feffc3d6da0d2e726a48b60cc1dbc4da9b7249b4b21e5ede62a6a032ad2d346c46e64302e2bc052c1b0bbc3b3f1c162a85b3c82ba6b2cd16afe13ef8374eb335f0ab118c0e82a21b3b92d3d69e8409d841b0f7e5ab4ffce257a18d1f2058e4838a64cf687c270ac9c1b02318599a7fb60a61e1b9a7331f56d43b1652391367dec99e63d328801b203a3f2d4f5ea1d550bb82ee653ecb9b20eee73d05b066b09ac5b28a69ed2a11cb08b1942f131908c78cdd7148350b7a693411695e0139b96080961d90aa60155a3903185b19f9462eb5fd54f004e66b8118eac6113b6cb928a2491c3b2f41534099363a891967676694de44cb8471f5a048a3dcf95431e76ce1f1a45d37c7b1b383c68bb6d4d4420e1b6af26c29f033dece1b16b5a94000ca6f2c73a994b924e29af3a570aa340a53225bf692a72a4fc64bb59162bd5d6224bc4a3ac4a2b58c50ae9236062bd424bbb2177c3da80a179408c67d601c130485e074c0c55c021cd0044dc0a2641aea1e01dd9806d0d7a1f28f30597267adb5ea7f0d264788e0c6717866ddc4b4e3dd051da99960105c379aca0250824be2b6c51118acafb273a6fd63771c8ea2844b6251e2c350c7c96949304373e1fc04976c42e3d52197ca88aca973a33949a0c423c24c1b8902a5b0d7d6901b3bdbe54f1621323231b1b7a55941774fbb38ad6aca0edb2e15f6df1c354ac415d9beadf65afc919ea761c67478dfa2601a0e4186ad6cc7ad71fc117edd899897588af19af8aabc192f0a9eba4d25cbde0c45d69b12c32afd3251db30c52ec823648dda395b180170538b03607760f6e3ab448d5a7d0fa877070aeeef08c1dd698b3ef5b25c2a5f185ef0a1853b1046d758b1edbf30c4be1e5b619417ad0621f0169e8dbb5e8b246d45757d3de0bb0c0f5a0c29e803962f90d1c180e7f963476c3f083c4735f3ce75d8d4819cbaea14e117b50a2804be79996851f352b254439600ffed5c51f9ec48210fad224eac50b792e4720267f44ef4c41dc3c1cdafcc096c829663367eef065f6f2c826e2902da983ac2aeca6814502b8c99a628e200fce2fb9ad3fb566a4a652e2ebef358f8ce04cc5c3a8ba7d72acc60f52b8adb2ab1adb20c1cd13b3a419fdab1c8dec9b9061d66b844390b2a28c270a17ec9a4beb7462f9e9c9fb319c35a1a56b24e767d4707dbc197166c23053e229a3e3f79ee4bd3d7a7e21733d8bd3576313eba7878f5c5b12f090ccd8900a1b773184ee166e41f5ebbac22371a3bff641d1674d4a79294fa8f0e2c3149dfbdea4f7c862a933c5f73c998ea18d24f323712a452131c185a1613f0f09f720d203ba2c83a428988610fd2ca2e2c046c4297eea23619dc77290ed8f59e68f275eeca16796510b5e21d83ceb66b656f6982fde392033371af5dfc2dda8da021647bb5e55d5b582cf1a80d559062bd5f6a66bb315366623bc3d2cfcec277ba9d2bb2dbbe7755345a6746ba6ca976629150a8dacbc977f489f24fe5d0fa98d7c50841809b480649a483b02e19225026cc0f3234156f1d0be6c11e4c2d29fa829deacce2c1337da05cbc2eb02f889ed676e5e43e529aa70d06e095ab2b124e242bf648dc8fdf5f4677a5ee3e9858985f736c979b9586dc381a0eeb291df5e08326da5d46f2118bd201ee50e0dc0287db14d62f9d1030b155c23f7aa3dafc83d58610aaf3d8ccbe36d4b8776172d26cf9969e6d0c8b313e1b11e15d753a7830cdc361cb277495324404dba596c9805b4595a9a20aa6467f5d1ae63a1644f0d7963d3153359c159f215c6df69f00e268707531dc432834f6ff28d9831c16e7ebce74a80a1acdee3819d021461aacc69e9320cda3ed9f1300c0d30e9863c3d2039267d122a8f49443b0ad84066bfaf5f1d08b9642331a47e56c22a569da28fb412a735ef72f0b842176df0b19eef278b60b3931d15c109b2e149a1d1c240a9936454df887800fc2fc679ca5b02d82bbfb816a434276e65975e26c0093cf44705d3b59a7468658500e4f28dd976bae63a0d9e6a34121fe9559a7a7f7400ce67f9c4b2b6b56f7610ec57aaa10eaf8fc6af5ae390807b277b16c9c45cff4387d43750ca24c2809123036b867f7bc3c8a8b0a892da239f16949c23f9c8635dd4f7e8293d89b379219678f2be608d75233d0383a0ae6cbecff2b9c113094eb169e47ddd916fdaa398f634e147155fbab312f67862d0f1c59009a983fe8ac68d0381a68d7582832ec613dba3ce7fc901a87f8e53262ef38b6351fda793e21523ccb2170e0c30949e1673d3e9c7ae773ed2f909e656f083708bea2dd6b8e08c937a822d862388ef12d44f72619cc77f9bc131eba60d424afe26961d9b91d47502f5db0e55dab1a1e773ecd7e87cc1287011ef00c0c4b3fa5b98611f63c55e3e58b10536b82177fa65518cccff86ba2aececfbf320a7543805bdbd1d563e02d32f8fe4177b1189d0d6c393b28562a3a05464a0798cf10eb24350acb7c418f0d62fd82321b879e8082d655d1d880ad3cb9ea0b93ac0d2b379eab129d8c44b5b91a0e02ff54755ea23d041150093c9599a36ce38d9cc0ea1572c9e8a3d190fe0dcf14036dc6c00eda5a31fcdbe20e1647934f707c7111d336bc7be855aa0a227f8f2970e4b9c77b0efa78ce2ea140869ddf4bdea8ee4bf7d09b8cd8f15ae5010caf77e7f0cdff7e72ba307f5a6b4e0c1014013a6314b842da6637964ac1dd095e2f925ca3ec46035c49f787773b1430ce28347b8e25885697340bb6720cde084b0702dd699461f4accfba07bbc38cf7a9f450abb64a615f643f736a90a4d30ac5537ca330877845fa1e4d16c7c0bb4550f322895b4ab53f6b1ca9b4b9119520b11c76f470c47204c2e139c165b0f37b68f6e2dd806e1ce5eca6703b066309b4335f2628b8a9f7ed740b8c3d945c7ca7b37a8faf1bb64f5b178669b27aa66a0c6daa851dc20f3d2b7b933e71d0447a67189d0a8cb894f2e420d5feb08f13c1a1ea2f461b668876966a402509ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
