<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"331cbaf48b70848e936d852381aaab6ba22f660c0005f0a81a479d486a0b351879ce162bac48e2f7594a63163a73b5cebaec42accefb982ea2f6b58059670bc48c385dd4eccd4a84d0b89b91b050baa6aa3285cf039293f2688150ba8bcf16e877aa2d9245ed9f3b962b2d745f3447f468378cf5ac111be5e7975aaa206c62d22f1b31d6846e19e384a707ef7b3983b304629ac67ba705aa4a0af17962963d1bde619589c4519ab03610495a58f37c111f6c13f351c4f31036c4f18309dea1407395b202286fce1d49105aa053a32e4a2efb59760eda5b8dab13c3a40aba930bafa3cf61384359bd4c7c8861fe1a435c31801d4d8eb7f60089e5f17896979220fbd92dcc52ed5cfc688b914358291a7ef1d7a5c9fb7294936148a1d943436bba5a3e4b44b57339365392d57e62a11b6767f21da6d173b8a9ab949434e4dc57dba3d3b661e43f9bfef73605ea502d4483f14e6eaad377907ae4a7de5c2adf118b60bc67e103ea42d1225c2e976d8527fb3d28a44ba8534606219586fdded21f18252d9493f608dc87f8405ee0a55ed5197902013f72b6247793266ef31492d92601d2461ac056f0902a0f5a1d495051e324b8d66e7dbd89aaae55b464af13d9cb96282cced3b0f5b05de2735c2bb64bba3d89cf14b129f701daca86289a27399bf3246d58526e7b750d59dfac41aa4d305dcf9248fe6195228a317fb741515d42b4c057d3b232deca2057c73073afb4739de908fda6edab35f19bf9b0774929acc5797f9039d9ff4b7cc0db08b3c527578222e9ed9aefaaf465e3bf7724098f28a39db92b7e226cf386dfd5e0bd11f8c3cfa3676fc6ac3ec8ec4706e899c12a16a6fb04c33f42822867ef4b83d81256552369a786bded2ff370328f2b3e0176f51198ce155a7b9f6315343a76f910dbf856d3e5965ffa27f0e7092ed89ff69e6aa9cb10545fb444113b41e478c88fa51eb55b5533aa76e14d3751c7577ecb387d4265fed798297c5a8be6b45b3bc0b9248feb8742ef32c546f45a0e0418e16ff24d53b9cd9550808173f23d6f02025e2040034ae6b408612a12efe9e8008f8dac755234ca266e4637b80ba060468e7c2d68f71407d658c4fa1c3cda28c5b26f4d4b199a49584a57e695e0df988d526c852ac9e571f45359e82e2e105cda102fc5c44bff75bc97f7a7705d089e65a5f90cec5040e649c857a09135c72adbe39615827ca015710dc89c2e7e4ceb3b94e53ab9966ffbdf0f25147302bb0ca4baf925f5b99fbcd1ad1cfa1eddf3b531de0f3101f89397753d30a82dc43a161f92e58251868f420ce4daf1a8857cdf4badfe21c5df5d240cc7c7683992dd9532523b23e4dba38c5c34f686950a35517526d8628dce2020e6249e2c21ba0aaa3913f6d591e96fffa1ab2aeb1f845cafef4dd3adf8bf45aa4d890c14e922824c5de2e86138ab37714c8b4b29482b328cffa29e860f6d9a180d5379cf649d4321efb62be99878f681edb95eda226817bbcd298b0e0a4576533be7d10b4f6caecd0ab71bf61bd08bb6d567533f3b07505e74930f82c63ae4e4fe512fe24ae45ad9c6f5c5544b2cd2dbc3139aa62df5b005d817020493150eab1fce9366a7f0f191939872e04e091555a7d74e3496cd49a2b9aaf0139f000d7718e14b116a087c1e71e1b6d17092e60218c6b978211a4b6866aa00c8f88732588b70ad699ed7d8a3d76a56137bb78a18a2a549a1ffa93c8d6b777114507e9c2252abb181e956204319764a6d8f2c0b848f48db10e8e480a13ca7aa7450ddaef8e780f6cc2de7e830d2546a77ab8c4ca101bc48c5a3d9a752faeb6536e9333a3070317cda0ff381fb3ca29aa2a215f2f374fa82aabe3184c4650763a1b8197d554d73d8ed33a5e51ad7f042bbb6dbe62aef014f9fedf313bcdbff71fb76382fcfa84859684a7c349d0f16cf0aae37debbbe4e364a56b3e0c0f946331e13dbc14e4f59ee173622f0efd90c8567917c0424f849fb01314818b570b82c6d091beabae27e884d6c0d50bdb9bb6eb2c5f35be021c490285bb0b2f4c6514edba5a461d4506bccf20740d47dfb474b385878737060005bb3eaf0abb397217b20cc9b3b5df59e309fbab0a19fdffa1ac1898ec862c96425bca2c7ea491aca5d60405d0e2cda89eeddf599484f8ad6a919b44254b143e71ef9f86f89d8d5e1cebf717b96f1327993358ac5f646f2099469897e4b00ba9c89f36ec0f0bb1257bc69f71521e20a7bad5eb09ba8e375e2d23b0d32c2d49a17a06863cc5add51752b70c23e3cedf5898838f35408ff624e2afee5564bfa1d1266da24989e51f002b4f6cdcdab69dab8ac2755ef444d6f21b62b3460eb3d0e81e9883955bd790edff36141efe50f147984929b5f70f795587b0b52d302290528288227c0d78d7f1a83d0c7eabe8175c84795d0389bced1f9f89932bb0f0fecd2308827100e5036f48adff7011438616a5e740b67cede4258588aa86e4a5317a45b2ddca2d8074d1250638df8511cb505ec5872a8be192868446865a2c81febbf9bcd49a0e8f3186a15372053853e0733fe0867a3024b4bb740ecdcfa9ce4d0d5f4f04e6b60e62155208277ad86b27a1d464535c04fcaca26b41c07cf0b6bde85f1290043a78307b83c5ffbee96884e7885567817f70220b8251d074ff229bbc6d78d7e9d67d5e17ac5e0c54f85769c3cd5afcb9cbd6830a7805fceba9a6d70652f2d4aee09fa308bd909e4bf8189b6cf9a1be5c9bc29c605cde524c2c47b463e718db39085f4f3d9050674f1ede5c2f52a75f3c48454b5aa809e36c718ec95b7aedd44cd52f6a19b4b95b2145aad5f76fa775c8641996854b7fc3d345b3fd75582402fa9a81148c32664fce90bb103b686da149d7be4142e1da31101ed928959504d77e267e8c9420d0c4dd9a5f997378c2fcdd239fd377c979690fe481e6070c7073fe03e20f5aba7c347253978a288c743a8ee0b2daa718f655f295d5c12596c7544c79fd1df41f195ece61aa75666c1db061f6543ea65099708a0d54d7f9f96841d8506e75eb7c4bb0ffa6fe3f2a5ebfe41c5f0bdc17216c6807310ebbc6f4c4f79f7724ff2b0fc606a26741289e59e5a795676ec406e6dde356404e536c859fd1a475c419caab4262dee4b572f33f149d0bfaa95bba843482b8e1e4ff4970962d96bd76b7e4c4b7ca0e887e7444dabf8b9abc3df271187c40b4f546c7d2e5658b80217f0826f5fe41ca926e8541dc3caaa8d629eacc093141e78d1dc41c572b00f3a27d74cb2d34461a6deca597ccea1a483ee3f5daec0234e826dc2aedfb4bcf9a34694f8af940c51239906e877320d6e3d21a78fac5ce24cb7da1729c3b96effd73fb1af52f4e435ff42cb3e59646bdced81f1cd257921f5bbf303c4e8ae250e4ff8f5ca53fdd02557586e677c2bd744bb6594edfa69673d84ebbcf092f1832c55c33e528f85157a19d9471a3e91ca8a3c9a25f09d00fadf12e703fce6265c54555fad38761496a161ec02fee9141499ba000e30f7f711937cf4d373f202eb0cb0b82ec29918902f587462f64599f8e5c0f976bfcfa11a613686d4ba315aa6402895c7ffe5f7e3b2932c0809be4f54adb21585a1bde6f55aa27f9e715689423a7631655c7dc79b758340ec44935e314d2ff33996fa8166c0aa93e65de1e9a2868016fe1b8994cc229c0c99295160d387c70dc4955f92005bd0b1eb444eecd86097b9ef03261bfa56632d9535904e58e3050a732e5a8b40812b0687afea5acc6442fb465208874d7c01a60b4566b19af9a1375e5da1694fd337aaa455e1a1c629b603f6ecb7a0c21702c9970dd6d34d4170c2307c56e6134a96bbab02e77465f3d95fe9bad9677e0bb389ab6485069c641332ff8a2a28992133329907bf4dbf47ff02c1cdd3c0236c23ca1ee78eb94d83d7b79065a2d155f2479b9fce7422a24cdaff46d17ab4bee0b005a0f9237972f3b3aacf9c348f4c55197487aa1f73ef5259d1bbb2c734592e2424d81ffc1c2374f6942bfe4fe2b52f94b578f9e10ffea453732742e47fe8494ad49840517c63d145d2862b780482e8d9fb042b585af9a4781b10e323619c3fa5a873b7a45f527668d0e648ddf686fd325b49edebf54a9ace0916d773002e419460c607839b09cdd4bfba1597ea6feefd1ac11434f5195ee0b935e0d4f0cbb3a46fe2e2bcaa43717169d43be78fb7fc7bbf3da518d3496276288032a0b092b43fb7dcac42602fd89d25c011b893acddc8445112e403c26fd40ddaa035534042cc3a7c1c0cf92632626923354d5711b63d494607cd41e7b33c244ec261f7bd3119176c8fbbe03e0264b7cc9a10cca9d046ace26c22d6c753cb684078a7420ab3f7c121cd071e10c26d3f15d9ad3c8532ecdff0512612a4154679c47ee8aa5c83ad375f2cfb4578541e0394a5260eeed6ce9dff0095828577e713bdbd9a08d57ec98f6b1d932c113da8a0783ac0fe4091876faeb81d57aa71ae433573bb336f7954884a42b323701bf213c69f2ddc2ff1be179b634b86eba569f7348c5b2e9d99221c0ab960620b0607cb48a04a7cb3013da71910e0ee222fc7d7a3dd1238067c24e9e28c8880c96a2e76f6a4d7999c38f4041147579e0f0db7b8432062ac906dc518a295bf12d97aef7107aa152874e88d4ad01ad6f017e88cc1cd6d95cb17bd73f8cdb4e608c0537e11b8aed6738f1d1ff7151450b9a0d785190be435653492080e2874137be7d1bd35949fbc8cf3462e0daa968d3548af327a66e1404eeb2d373ab9d7202f785aba3380fe251ff3d7a0652292bcca8f46a2b1235b54cb35f7fc7787bbe1b2af6de72570765e382b26c57233246e37c500911b522dfa9d94e1e2ffe83f4233dbd71363241ec2d2a7ef5ecf686921e202660794fbeda9007dd82c499ddc1e1c8d15e95615521d22ecb7d1188584acbe0ceff80541e4d06bd119a5995ce65b4c976135135dd2f1b89b7d0dc350cda53000d6d550051652f4964cc1fcfaa8fc3d49dfeae971b36e394915ca8862f67de1d9ace00bfd40c3f32eec46852f166e2c2534342a86a0db3940e535dea929c2d3786e38b5f19e91dcfe2c754cab59b98212e5f2b0bc33dfa799e4b4c69db29a5015285e664d2c86c0c57cb67ec546b558af134a8bfc5820f79c60041dc1c5c976d296e83e3fff18e0c57399df56ee62eba6ac22c08e4c6ed0e7dc0bf434df6f16333f19f19c2767a03bf1636ca9154bc9397d597f67331a20cb66c1e4c3378007d866a76de3c5ed458bd5326303c77bfe7ffa7b51dbb89f9b36c7cc919c2dad6c5c71c2d614b932ca9ac06f4aa32e4921404c50506efc460f161f48aab5bde934c9b4a11c8e5eac792392bf38e404e7e8f9b0e6a72632f366d7e019e3ddeb691e0ba515282d16fae9c621a0ac288bee1e2fce157e7debc7148e1453c1be162ea6908306ff2918d75a2a355078a48fe7fb7617a2788f24ffe3e5810a463a1d02deaa73bd5fe5ae72ebda245adda8bf7c3355c36f5f746790467c36f24e0eb31595e1e451429ed8570cf16e406d8784b43956548450c8a46e0abbb762e11c71696c8a96684a6ad1307ca07d769c59d620a14f2c810b78e21437909b461b4c869a565b388b107751d4d39f01fa44cf6ff037886bf616e3f88cb336882d8974449232e127fa5815066d4a7392dde0b11c1860b2f73e00d1734a12833dec029b0deb770ed6d355d6db9c208d993bb8f0634304193d8f33879003a40e87c6de7d296746018623f10b8a8a2bc6f5df28b7c96fd0b3037cf5084eecd97481e67edff95b362be3c657e42445beee3f1f8b4f58262d8686b7c936f3ccce229466eabb26e3311d091490518ca9a8fbd73a0b63753dc1eea2ca24de2b74a217d06289673ba533d171cd201b78633e40d9000fec90639f811908d2d0afc518898f622a4151bd78e9d00ada7ce7fab09c7aadd4b0c0ccf68fbb6ed3da2d795abf8b28baf6eec8d610ff25806c45114a34109ae257edc0da45d609409fe1d1becd4a64128db551e1485c5303a39918cacb2a0194320c08f65e344cfe7f4c2ae61be8f091f38b6d33afea0bea06b9563101fdb26cf3e8c1ba04796cbf113a075c1753cde3cabd5cd569a56d59a2a2e633e2212353f68b00bd14a5037b56a32a2a458d88e95391c537588a51447d6c373c40b4a71159146c0fd06913e9fabc3a637f644b43ba40d9c9dad96766b3f1fe6844058a4aa8050d1f341a3a4e2726e609d2c4136c34fe9d94c03bcbe0235662553888bbaeb6f8300bce2309360b41855fec201993342c33c062699636ad086727307608ee21b403f4b3f157be56bb33dbe8685f45abefdeb1dea350579c19bc2d14ebf306d35a3b76a9dae7b67251e495115ddb2045544d171dba688ceffdabe9e174fee12ae22184b2f6861881af28ff2c03e7085faa165efbafba698076716065c9181032be834109ace368b991ffccab03ca593c6c8ab5348976e57375f5604cec5f44823973c63e004d8dd08fdab7711de06cc8e00aa5f7f8ef0644f710daa0eee0d721952055a1fbb87d1da4f13307c7ba45d2197185319ec926cd4228a1a7743b8f3ee73e616c9696e68b0ca3b69027906001822eb0bf3d68823dcea11cb879be8e18c4d71473bce9be2c68326a47886511728fbfb055ce5c4d9ae02e899f36a5116b59a8892ea96647975b4f9c3b390c1a7faacbc9b91f602f9708bc434bc078798fe55a8e2a98a0db0d9dffe01433ac2a856480013a9a04e5894009a5e4108a46d1954f269c283644ca27a76ebd732035cd6bc698f2501359e9ce49585c5d7ff7a5eade83a12fa8536cc603efb8bb17dd5e7100a7002c2bab11356bac14b202f34d0c8c6046b446684ac9b03593fcb32e2bc9d15006b5feaaa8253a060eda74ea16326e1c357e3c10b2174873b82f6ea86e658d9652f8ac03a87490e3ad6eca88541d408bf7deceb6491d9fc8ac4a18b58c5783df2488ecf99c042610ccc2bda69b070483fa355e29225dfedc4d7591a1c0c7316d4901096e91ad0e961667718bfe7b38aec326a382df46e098bb2f1f644cfff391d5fa9dbbe03ad992f594b5ae17fdac95522ee12e3f73493fa9daf28de9f62f2cc0c9d651e95c65d7b2579192368a2f6f967ccb7d4157e93897a6cf4bb7659c4821029da9ace6fc827747dbaf26c986235a455c10f7026be5e0430e08ee3d6d304dc505595d2f96aac18d59fb47cd6650d8fe28adf53fc6a4fe200e71d5d0cf6515d179c74d5ebb969479acec64bc5b7bdf93d21b7938f3bfe784aadbf914222e68c672ec9493878fbd5334af4bdfa400c9669cac42ecf14a07384fd03b4a833cba78271f06d065091702e341b2531130df51638422bdf09bf86a38e1895b5bb688191725c62f6cb21705676081923c94f1bc54082a61e8df70f813bf7881825b7caf46031f7ec3a964a2196cd9386ab1a68c3b181f1da64feb89bb95ae3799422b0169ce3469745bd4f4608aa5405a689f32dfb70000f79d139e250065366f40f0a12826a8bae98e1b2c1827b7552d3319b6c7749224e26cd0b9d3deccfeaaa4ca351f571bd46922c8986d700fc9232040fc8ded63a221a579ccce884b78b5b89142743c0f3decc5d9a4fca3ab2082e0b2915d8814990f8acc22a31d3b45c82a833075c2b43202033c9ceca4c8b350c83d3501293bffe5e903b02a7ac989be45b41675808ac8169c78b178f20f92761cdb7499826d2fa00d1f45bebfb6524d1d1e1a1ed1e0df8604094646a36374277fb6a0df7185539e851bf6fca2493f4629dcecc17d9a8034df51193d32e3c3a4deec6ed65f11f4891b463e483be2fba988272890f9143edd500ec0ea47f6dc8a2c2175d063d23400ba2768e99248acf5dfc5605ae27f5357d2c073d89dd7b4583a54a17bb871c40c9ca76a21e2b2b159e9a62d43f73fa37fc958e00b21107190c8c4ba1a945d3ca1781f29d5202ed9f424e9b4e2495ade2f3aaeb44b3157a18619c26e3d90f9852cdcc39d0e419634b6bd3d086adca13867a0c1932f3f8e3af7668c0faf4f663e8921758cd71a9dc541fed25ea0be6eb51b8bf97331053acb47bc4569dd5ea6f228ac0547076f9689c7ca43aa08f2808fb377e94c48c92a964f34486eaee78d65b25aa11d7a40fadc7dc39096999658fbec98530809af42f061e5bd5f55101790f94bcf7357d6b50d75c92291bf4f633824a01f6da4ca6d1b5d2ab2e76ed26b20aa9190102a240c9e429dac3dc2c5928d548eeca0634aa7d7437d8f7b97662759d7fc2c2201d3ae9cdf7229c051e93cc822186b7d0fb80c3aa53952a116ca5c98a3861baf3c45529e91ebff49dd02d1fa151e29e1e01e793f0e407ee1b62aa19bf90ee30ef16782eba438b2103ed82370bb860d1e6f80ad97f779fe7bffa9a74362ca6b5e84fd12f3ffcc00f4f7586874cb580f295803a20886e2aa0ee59a38cb323b4659982467961fbff4c2799d10c5f55e096b473cec9d114ffc7f8200dfb55be0bc6c27cdb6173f036aa06be092d27fdef34784753b26ba80415d66c87240f3489b509594a23027d44b0de776b25983c83df290b2f2e4407c8303b09ad97fc078950a1a618cb137141eb3cfc357dab250326093b2596d0c5f65c1668bf6986bf790b4fdacc8fc3f25a7db8d110028501fe3460ef2f6a60dba3e0520447b08fde44b820e60cea92bab630a36d22dec978cbf5734b637daa2ef2a616f37250ce7f725d63a0189847e544fe777966e24ce725d5bbdb7264513e7d87dbfcfb7f75237e7642d474cf4196ce01ef59ad256f369b88c97bfb0961e71ce013e9ac8af41d8d9b9a59340147d241a3e5f1aa74b2869ab1c7481cd11de522751e1c0b8e7ba869a138e9e7568c668ec60aa2c1087ae6544791c6c76fa026efe52815dfc27ad99e923c448dd22a684f7c16119ad94e04e849f28debaf00df9b2ef8a0f813f1cb36b5b2c0e36b70026a80e47eed2c2a29f87fbfac3233d228f73be06953080723b6b679361f1a658a54c440dc6c261cbf9e7eb512554e486972fc2e77056baddcedf1abee7de049f85cef17d7a073e9f87d26e30e97113311fd000dc00b16682b7efde0ef4cd386f44dab891ff373d970a1975be6598c2739864f0458db43163f53cbd594ff910c015aba42a305ac8171b51277281663a47f2c686befc41cd0f1021273313327c91ae757390c212e49354b5e2bcfedbe1a9be5c239f27adc2e7035f181ee83d0c6b16f0da6b19eea91b55ad91a8a641218fb0b7f133a360a928865d8147deae51a0a4220704fa3863f5b597f1eb52b94bfed8c3bf67e58e9c145cc3eaf41ffef0f0092d44d1da42bcf2da4288e10dbd57a27ca6f9ebfa52420d4adbb73929d87cb9cfd2633aadd7ebd58215f1f03eccc1d5285b6896163fc50b1f3ed06b7749f50f474397f4de15a86b4f7700a684acfce76cc1188d0d41be7a8a9a30233ca7792da399d786e10bea79b903b95a0dc5ece710e288a72f7b67ff1f41cdf2d96d00227901c90759d86fb039f59377a978417cfdd72a0e9ce84a0b94dc0c79f56f0d700f9a0758f0db60b9f7034930a4369e240b09008ccb74139b6d6542192629df81098b8ac91e3f59611732018762e53f9225683b79afcc254eb14e8353cc962e1a4714a99ddbe7100802f00d5997d0068a7f559d219bb2f2e15c2e87177f58fc4aee8269395d6ad0674a539e25c6fccf707de6a27d3d5adb26647f923360a416dddbed81b2c727fd1c74dedb0cd09fbd46fdcccf1630aae2edac43005ec9d97cd67a8bd103e6b0e0296c577a301c222586816a053910e940c36a212718a97e8a2e5c8caad21c9415c9e94fd0431123846ac208981d451d34809d51e2f93ecccfd0c2540bcf565bc4d67eb92422f47d607eb10266d43db088f80d1e3631220b679f447e3758acde0de018f13f757abb80afece20c03009dad1f8426b1e76d8c8d67081dde58c6a8ffb40fa44afd09027e1d857ae0fbe27d805dcc4f7254a0d75a440448f9bd83272266c038fc78edef45351041519b05b0a3396446803f735e04bd58df7c6cd9b1b16935bc1c601590e4246bfe732f7b0ca594f7638d546a67b081cf06c3a691a4ff7417576b77b57adc06b0ba743a07ff9aeb2c30989ef3fda02831ea865af619b9438b42e200e60efaf360e8a6993b360a38d4654feb9b4d44eb07bf49ec39649edd77606f5f4ab000c321f32ca49bc079e030f8255f32eb30c65c42d227b2323f68ad7fb04ba54c9a280313a8623ceefc277539fe63c5f5e0a7775edb286fb68f4e3f73134d3788f832544bccd8dd2004037a7d2dd22c776ae25a79e8c029f0d545b1b9aa4400e3dd3f3ddda2a9f61038c7910ac32f7e85aeb286b3d021aadd6d2fe93b474631b385aed176938f59fb5469d53d643d5eea4630652916e2b3ebe9b4a295207f45469673d39f50e24f21bbb1b26555fcb0d3fcf684491f6d93f1063072b0621d703dc2813b8956d09ad1462aa55ceb59538a32d980cceca6f2d8da50a2416690fec572eed3a2ad4bb13d01d893ab3a7a986b3711cd7337f590b8361d10313d041336544809dc0f94baa4b492e1ed9df9ad2237155112777aee73aed1c51b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
