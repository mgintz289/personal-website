<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/private-blog/assets/css/main.css" type="text/css"/>

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-decrypt-button {
                cursor: pointer;
            }
            .hidden {
                display: none !important;
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden"><header>
            <h1 id="name" style="padding-bottom:0px;">Michael Gintz</h1>
            <h3 id="name"style="padding-top:0px;">Private Blog</h3>
            </header>
            
            <div id="eight">
            <div id="whitebox">
            This post is password-protected.<br /><br />
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />&nbsp;
                            <img
                                class="staticrypt-toggle-password-visibility hidden"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        <label id="staticrypt-remember-label" class="staticrypt-remember">
                            <input id="staticrypt-remember" type="checkbox" name="remember" class="hidden" checked/>
                        </label>&nbsp;&nbsp;

                        <input type="submit" class="staticrypt-decrypt-button" value="Log in" />
                    </div>
                    </form>
                </div>
                <div id="more"><div id="space"></div><a href="https://mgintz.com">go home</a></div>
            </div>
            </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dcc17fbe867181b7fa275e0fb15875cbaefb69066da27522afcc5cbb6cc3637b5680c72baf11ed86edcd26f93c19fa9361a20ca23541ba050bd35476da5cc52fe700201b42a3c429f0cc9a9b1775c19c3239347adc03e57e04b1072ee4613045f64a638e3b74d781e39a88f0f84da15f1692a71c86df15e800222e39c002867b1b83fedfca2f31d222bf957120b86ff634c1bb20156640aac1d29b4c0f469b010fd889f2d20388a4b9177169c7af80bc6c08f7b241542abaf13ebfe66b39e136b7401b2c4236a7cf65ef965518f8eda653e37feba365b21662b3478cfabf5047debc9dd012a418f112cb9b7c0e0f9eb62d4ac79bab0d45ec1f90d96ebd07543423f08c914aaf3b08dfa79eff882e5288c76f91539050631a470d5dabbac27bbb05f579ab482313489e1da30e14df03f5edf0098cbd4e0d74f98d937aa3a296a8fdfbbbe41b5000695f7d1a2d6ff15ceda30b45a1ecd1bc782f85c2c907cd720db57d5189467f7f2b45305b2996ebadc491bf54e07a6c9d68fb37b026c73794917423fb2bffa4b5acd94a3daa1538a04c6d8a94647948c1b3dbd852059a51cb663aec3276fd028e7e65d0fd3c68cc0bc967f15254a26f47340336d700027aafcbdef8189af4edbbdb025a8629612408e5182836428521c38c51ff6595c89d3b5b4a6567c7983576d63718a788d5c091f0004c5fe0a156f94a9f6f547ba3da077d0c69ffd437587a3c18ab8fffa812f33c5d7b5004a2d9c03197b63a363b55d444654b47a99605b5ae6bb4f130d50c7c45770429fc8df2b5a4af4a73add26059b5152e1fb97340cfa747362728cde1c08fc32f94ec2ddc03ce09b8b18ec09045a0eb36de44d91cbb525167c774cb9465e71eb58e75b0095d59739a293e12a11826cd095e2e363c5f2d98439780a33c91e331d20fc9635174554b22df377272377f02b65f6074f40b2215eac021b40ba2bbb8035ffd8d5f4faaef94dc3f05ffb54a6b8070215a216ad63487412b895abc9e93ef556719e3f94a49377b92b7b8d46c875a300ec0ef9174fbc1f161b5b46a04e4a0ab24f51c0179e352eb0842b2f3fa834d6daba55f99e2a95b19e6fb7979f762eb9bb937d7f640f9b0a76760e9190aad08854462e1d444a0c88f577f8f283f16a2e6953f5caecc0a341ab1e90b74fbca6a86c39dbd75c5e0709c61af6ed080d166bb5e0ace75043bdb920d7da6f43300988e1b745fe63e4c5ff3e4e8a93d60eb13e33b2954c456e4475685de53407e51482cbaea4ad5f956b736496d56f6fa004f701df2a8d91394479630120bb4ac1bc8cf9cb37375a92c795b8cb15ad6d4f4e687d9ed508e6d582333167e795e7d647d855d2cc0ad88088d7368b8896eddbfcb7b2a9169ba981d2634a81415b18406b0afdd4df0a37ba35b7dca28f9633ebd147a02ef4cac43eaa517400054831ed75f5847f1fed3188cf2857bd392237a88030e97dd8ce58c38ec0fbdfc0946e308ad8fd086c967d11d460407f93b1626da45d89a20fba2b758bcf97685a8e122fbd799aca513f522cb5386d4daee55bafa110e7ff7d767584b4b5ca76b7c4432f38b2f6dcbc2f2db9a7e269720517cc7c125758137ed37ec85f9b7a9430b2495e746b785cc5cb71e3b4437406694ab874cf8387af950e5e1f00d78bc9fea11adf26d1ecc807e2c8c0487b70ad18d8d147899c7775dd55545e7c9e7c2d278a522847b4a5b8b913a285512820874c6cac99825b741202d1a5a121cbf8e3a8a426073606b3ec30b8310a4dcca2aaec23983ea601f708c60752019a7c8d6aef8db082fcd3b65ba612a673523ea38d4b51a72b8a799fe2664ead7db4fb7b44a44ca11d1dcd991b38590399fa8e93a57c9009cde37d39b520ba18d3c3ef9166f5a4958cc3402fcbc25a9c6d5a73030c6ac7aeaa64702ea31ac6760c8d8af7d66e42f6eee273f0ca3f1b7020112359c2a8d4adc5cf1d4e226a29cf2c5d2b521b4b458ae5ad352e79742cdbaf0bbc87724c094e39dcce90008e8f20b1df55f8e05dc68b38fe0702368a6cb5f564e775f3941104d6e4b5177fd9bcd3536e3b39425a0c3e876b7029771fa1307d3bd48e8f8567cd53c27ee9ab69a17d340563f5dfc91ef8fabb5dd0a7b0f2ed98d4afd58ac4df1a3acb0f0ba49d2f3f5b9a33d490cd3020e4486e2265571671d3f0b00f683a60cb1e4bf88e0bd1e1fa3a549ad1ecc4bc05e27138fbc0c4886669f570408d21425237e762d8ad102bdc530edffe366b338c8739475da8ebb0f3ac2012b9f5eed3d8f400f3b32faf2100e4c5d618f3379790894e158ccfb696087517a2f3f58fb080afa7f5e0a0e70aa3339104a227eeccc337ebbc164106bcf7d229ecc4e1ce1d569918550aa246267dfaa4cce2a67b9c32790e824bb927bc8b89f44a5dd2b6f46542a2d1b590e06280145f6c07332c176bdcc8ad783541c3e82638116518c0db2b5ab73c9e1a6f09312d8253e3fff6e948e7ff585ddffa9a18ea1d66ed76e1bc19218f0f47070a6f61cbec05d4f87083ee62626a970829a8c3b18f0274c8b88b41471276566029b60c1ce9dae542cd225c29430708c5327c566b109594fa1dc8e919230bc575c042139ad3f19ceaa630148e27b63b2814bb6dc8c89ee41bef4ec8f55baf022a8daaafe20a9073e351cc750903e2014122033f695fa69286404320ff234cf050f81fcfecad424d3fe2a42e3c6ac3bdd5d502ab8021eb2bbd54899466912b047bfa258aadbb7ea91d2fef30a9d2cb64ba17b4fe430f3d8ed8ebfccfb612f6ca18e8149f27f911d4889c703ea7983a9b39a9410893932f85a6fb5e4ef728aa79a2166a7aabaebf4cb3c4d562b263997b6960856be40b5aa21f5d6eefb2bf97b4834a4b43ff83889e07c2cf5ce514c2f32a553b98d0e618f46b9160da95b859983e1952c009092836cb75b2b0f39a49e880b30640627f6393c4c9af425cd199add4ad023dfa8c00b00a268cba589e49e4483477eaeb6a3e4df7c6e1607bf787046a0de09628385e3911b5b808e0f84936a0a5ff18448cf6885a8d176d2f8aa180a918ff944810f97544675ac3fe2e70072cb054fee7b8456d046708a00f19556a4a7989e46669550e824c8b40d97ce4a5f0f777dac3f81a7625397e68022cb3ed34948375fb35634b6257453d9b8c761ce90359eeb4eea9a8aa463094f9471eb7f8fd38c9f85b3a7705bd6d2a5d261bd07d3fbb2c8b80b1d937ce74d26dd8ff02bc2271b811c93abbd7c95997af8f514a99edf6a9066337ad65c974ec108dc022fbbbcd885c851266c21725bfc6d7802d9c76bb633bbb21146e406b22e86d43a8d2efe7d340ee30330c40c8ccb75f0bafafc154c53d16cd6bed1dc86798be481e43e6077885f13eeeaabaf6a4aefb81dc0ccef0996b54920d7fea767bb63a8fffdf8e4b5b11b0e632085d2a86b4011d3933d5bdbb799db5fd620a211e7a11d14ec6a685b3fba633cb86b5445fbf0cafe5a3de6c08d54051928d49d231387825af6741ec978ee11303577b78ef8cdeca176bb2f1ed5d7fa5fdd7222452cddc8fecc5ea8b1f9de97d447859b80073f810bbe01eb885d6a39dcf80defbfc56b2dbda7c7e9f6b9994f9dc7ac821e166e08774b46e428523e0cfa7e7ec21f3c0f6f52518856dc07b581385667879ee0bd8e6bebf93ddf21345f3036386ea698c8990dccede6ff89916d4d498f5d51a1b80c298c15cb37ca53930624e7af97827e6c47b59a36c684420f904f216db4a9fb7b148f98fda9f1a85ba2a0cbb89d029aff6b2653adc5811a464909594d70b51250e8f6c7cb395387b6fa0ed301e0e22ce0ccaaa3c0ca5811df3f9769ab17deef9bf6b25bc4121852da14eed134e95de9bdd7bfdaa5259e6802ae7161c1dfcd82e065d88ea09687e0deacb226052315d701f59b046b3ad86ed3565900743f160c31e8aef478af2e3ee2c9bdee74fee67a5c22b431df03b0ff3383bf7a7e73f7d5779dd888b2772597824963960a62637baa9fd94e8a1fe0c41876bfc6006f09a078f08213fa9727955a0a5df4b19d9c0eb969d2df5c744f8bb78e56a418256e12220d742a5317bd949948189773bf846ec32b1b39d204a4e115698f3bc563b92728a7ef1284b7a5a355bae39ca1b044cc71e81f6696a35ef9251d09316afdb1b9111b5b5f0d37d4423ff231624c103e888fc105879604ba52274793c6ae8a108228c2882f36bc0728bb6d7dd91bb5f861785dd50882d01feaf7bbab2256a9b43ada6ecc8802e0f9d19cbf4bb65e81634e01c5f61c8e2e956b034a86fb5bceca660a998e23922230523e9c83c8014608e8ecb946217bf885f9f1dc96c46bd153456fb72cd1970ee90682ea1f69f17622741cf671a2fb379ddc8d0f77a8e1e5436e52bad71a86572adb54a419a49d4026ed4d2179569c4926c01f6d5473fc00f9a31c4746d1ff51a1c6a7853f9d74740aed9d0ddfef5ef796aee517d39ca4686d3d059a32d19079f5ae467028d2a0e36334db8cb098dc2a8ffe1f857dec7084d8caaecd5e27cf19ad886a1220210f6b3f0722c43cf21ed30f7e3f350aad09cdba5d7ab691f7e07030fdfb17fc2a44bd20fdfd8a5073d0cd2a1d7fd8ac29915506ae50f5293f736141e1519f27dc7b7fff79af1aa5db98f0a037ad97d2186ad7587c966e2e0b803309c38fbd90b67577029286d843842213a3ba2336f90c3bece1749d42029ec60d15eb30bd3635ada003088682eef4ba3ed9440fe9b369c1e549034f2fb08a6bc19168bf6aff745199087b3b474a9880313a0d317e56a31f6029cdbf1554a4948d9ac83480bdfcc54f64a5fdebae2db4e1046e5bf7c34d3dca8512e8228b75fad16703e1e51b5873124e73c75fcfa5156746586eea344023687220d72260edcf74f04df9890ef3f0c159d5e452f678a210413a9deeb075ce39e05c75acc1f265420e988d1c8d3274a74e4e8defbbece58f56aa9cf8a09222ae0cf7ea448870a4d91c46565ed2e20b84c28c94fb9abe6983916206cb9c6845d402d8508762f2423652fd01eb0a31eefffba513aa68063c5acd6ae37ee7f56ea0623c96d57ca52f8c660a5d23906514b4d0d7d531ba246414a50dc0f8aafb4e29fc3b856c056a023ff949e849077f9776cb84b1a85f2a5a9785e49bbc0926042684e0293c8eaeb2d6964c4ea1cb69f9e4fca37839ac0b637105341c70b1ed4608ed4a1e16ce10a1d5ea0f1a83a55e7d2bc5a6d960013cc15c87dccaa47764efffe6d668a2e7f1d31b27263dff467ecdcf2bc75bac031279cd86b38fe2119967bcdea680191f2f5690a597b8c86187da8e84c0649f0d247f37ed567cf8daea41b2e4ae6c155fb21f7531b7b0cc409adfd1610a669cc9adaacef4bd33398ebaff058d8502d90c72a6ef6411e697f6c3f09492f9fbed7d808c2ad25ac9e0cd4cd2fe9bcc2784e9ab2162e599fd1aea464e5f7268ae3ccda67b47f33356c9c46c04bd42ab25b95c6db723d7a657e6c402b6b0da87cce385876ebbe670c15d7b9df7003c37a1cf3987ba6e1fe40d5cc74546dd75f9080e1d96e393dbe878ffda17f03f0ccf3c29c31e43db89ac990101b45269cc351b51d53d7af86bb9949c2532c7d128d6b84cc47a15f1e935db8d7dc39695842fcb2bd831b14169d34c40bbb48a1127ef44f12f912c7ad57a4780629daa6c38778524692e15ebe360efbb884c8e23b819a9e544bff77f03f73d3975e21c9ac10c002aa6a9e8a304d92982608fd1867b0920164b8cea3783a683aa67c4d53f97d3d00d282ebb15ebec0bf1347b86333b8f09df8e9c2b3e38c094d676c6641731ac17cb2c29f8101de9e97ef142331f50818597f0b48f9a7902217aba787012143eb758025da8fec9cef6f51cd404c9f1f6b7871c6f9d6309df7430741f6a8953ce8b145440dcdb6d20eb4513e5895d4e864fa9e9513f7f33a01c7bd541c32402d9b83ad3e186d4a8e531d6cab604674687b2e30ab95868ee96568a18ef53a852c6440e0643e745f6bedffef5704b38aa62d1e5cfded56aef66e7cdc869cc9c41674dc7065f7922627792c6f9e4ca22e724c6a84868277ef38a54a4eef5f1bdc9fa3fd85885f5d42e73a79ed1761502f4c6d767135c0824b05668ec5d16b343a63b084839526c315ebef8b510831d873ae09b730193d19a026bc771bcb4601780fe4e74e552063767a82a958dd196bc1b846329bbb77ab02b162e92ab420d5f9f625ec04d0b4681a3c508af0577c04e0bd2cd0ff09523e823da31c3dc88dec40b5380c2bbfc8f184dab1cca803a81f1085fb5a495fe7f5558fba5b0db034bb2d1e04d56ebc2f3967eada5bbaddda699dfd4f6cef62136dd66ae3b7bf9351ffc3d806ebe32a46745324461941a763d94131d13d0ab1833d252bb229340760b8502a86517a7beb1e2e0f1f4339035bdd1ec81d8e7a97abe0d40bed0d3f91c0a83caa6f1917a0f067a1e1b09b14f6fb79379ceb5d3084cea9492827aaaa4f217323fae0dc94a6f75137b202e2da5d44fdf3dddbb35d03a9852c0e46331abb16ff7b7c6a086d438330226bb5f0a78e0ebaee9e173dd794d039e998dc69e5101e86fb21225de7186dc0886aa61dcf3de35ea362b9931e3c641f3666f0cd6026522feb966ede96e9ba60d42be37847a839d3d3501b0af62ef90f31c572159e3c428a45e54db1bffa4bc809eb3d1678524a3ddada0c3ae05e2bae11bf8fb83cde290bc2a25cbd40caf62de3b8be0ceb8c8416e771c4919ff19dd39e869c61ef0be15d99b1ebaeedb6fe1f5426fdbbdefbe5117ad32e606f587260ee646f2bea3e86a07946a55c4773c873cd351cc82df77503e66cdcafbfc07b026c037ea2de72976ee1212f0bf0bdd76488e61412b84648618aeafdbe378cafea5c0a405ba843c4f60285516da62f56bcea5443ec033fff57351aca166fd632cd3b4e2584be48fd06d8a72a1c346b49c27df1300f05868599438e71268f50bc17d72383397e7a8fbdf6edf0be37f4f6e86ab1538ca3c3630d34b32f2b9fef1206d0660188ac4580889408576dba9c49a777c8ef755c73fec062b2b3ad857e041c58dcc9e519d771323c70b916135faee4f67f7f9367dc4563d706a1cd9e0ed999db955e277914fac7bf28dfe486b7ee034d0e6294169f9a8bf97caf19ad4fb412eb8aeca1ddd40f7cb1b0b02b96c97742d4ce6ebd5d7da70038a899f06c325a6d9706bd0a291ce1375757cf1599abd68630a84ba99d4a82856e3878805d842433aff89ef1767bfef1c8b1166afce620233dd08d8e295c4a24946a48dd05ef727f93d1dc160c58946f10bcb825e0cc1eac41b8bf44db05cd45c8cd8da93b0d2d51f98c6c43761d00b1c771cf46b6ba94706725e3d126d9373f76300e00cc03867feb11ac7a3ff7fa0c77b73354d114e1fb050b7e21163299472d198f11345faaa55ca7491f8165b0b2f47660674fbb0894fff24a635cb6e8599a0a55ee4d344abe49b731e510d348942e27eccad1cfaf6de40f524785a96939671bfb041378d3431b5c1e5f946db9bbd0644bfe805af117004b28dbcf220b77ce9578c15ca427d25cb79217bdbba66ee397a3ae45bd77e81bd8632b11e95b5066cb94d9300ac57e62c802361daa419f93c5afda2a372e0a665c9d789c6d463babb1757c13f90cd478401b2313b8d955cfea125f3ca115006a0d1a45dcfa6052c8c495ffcf67369f8329a0a85b4204bed3f8a1759b768c6389756259d64da2171b16b593343294f0bc78d5f9ed1ee26ff8503d40c1036330d417ee9b2deeef33a3fc414bfcae58d22d55161317813f4c0182627186de65357b242280ce08891540e01dc673439773851acdc19d3a3558b9e67d739dc570d0e2e89a2df18b231336ffecdfea2274ddaae0710ad0d256d20728da61fd3c1f1fb5953f60dcea0e70d3cb2e0ac47b2435294710acf63bb005fb9218cee0cfba6c80a9883cb8ebdda96f18a05daa4f198855400bdd1a8b95cd27fa6a51a442278276168185e565b4d117463d3c02fcb5309b6f01758e090bb2a1e26adf1822ca13c17a43c9f7aeff12602ef88629797be9a76ff2b5f0dbb2463d35274a0931a409ec6a787b773778e43af510d5d8405c28a62fca5f6d019ebe15856f3d2b791264973a98378404cf92a9c9d5222bd601fa68bdfc96fbcdef20e525917db7a1b13c7e448ab14c3b71be0a74213f3b4c4a5d8a9ab11ef92d2b9584d5a69516a36ee6e1a4c304399e124b3f7fa9d0e4cbaf8e05dca6f6b0178c8bc1d2c4706cd9edc34ca5a60b36a4cf18157e32dad9ec8765197c810fab4c6d60d60231151b51cbb8cea93cd3332f6ad767d7a0819a3cb8de4f8a9c047c41534e088a1025320d42f0f1faae1ca503f500fe1023580ce305bd6b0b0d17ecf9201019e4a15231ce7cbc87eee61ae1ccda438737bf9b274b38eee83b35a011edba191707cfa9a84244af27c037a5f2127bc75b6f37c4df2df3ad0218083b0bdc413ab038a1e55f131914ce9bfcc0e8436140a8f694078315e09c0209a5a4180d7e3d72cec2bc99e21c115bed72d7a73534d2da666c381c8c41fc554db00f45367f72d7dde763ddc675cfd4e947be376351018f39b18c0963ae69cec70cb7eabf9e38d61662e6a558a787a29e0585f0bdbeefbae1e57dc2e7332bafe4e8f0f5f7c02eaa6fa679d5923c0271d49a459505a075af630e0bed438c33716dcb09033a6d1a50c7ad83f7c82999eaa20f3cb19390be6353f7749346eb8241a9b39243e14408cc94e183900a32c1e15fdc63f1e3b2572d2a2e4a7284ccc0d4d492988c8ae1adab22f3c26120e7afd2a9b6f929ecb19c4bee61caba0d17c1a239913c49864b42e5b8bf1d6a5884ca61e61a802176efaddeb67e2dafb940d06d0273666115b310151eeb2651e7055967ae22d3d41f643b5810804cea8d114ff00fde57dbc869d9cc63f9d7df9c924c22cfe95875028cef6714ecb0cc28f45be27c26707243a8089ae50c5f830ead138561126659db79395df3c5917694a485910b8b64da009acf98edae1627119031925cd3d11d4362fc2cebaa320decced53c52da4630712d6dacf3973a0574c639c218da48a91eb0f3468c60f5b6844bafcb75539aaeccf176b86a993f09e3c34877158b6895be6487409bdba0b623c9d18acc9af49ed7c5492f9980afcea107fc8ca39748ce8a4648d6f3faeddb986655dbc6609d6e19ea8cd16665c5b8dd32c27ad668aeb3395a8c0da3f1558f04e2261bb8099e254ff6c908a2c7a30ec18030b303a6937846c98457c8b8dd12681b0b9e4278126263369e2f2dea16a76d382a90a2c95044347e87eca19efeaf1d5236360d0ce8c855f791f8148ccf4b52768c214d6d8d27479cfce65c4a6bede13888fda189fd3c9da943ac422a6f67c96216dc597077f446b102fa866f2c9d36eff37ad3d2e605216ef30fdce26e19b2bb71bcec49b5feb837ab3c16998fff1ee18ab431bf4b51e7c4ac003e16ecf5de95e8de4c5c2cfdf0b693458d4ca923909c249380da5b8147e9f7de8030ebbbd1631e2c3165183814325dc0dca319c04c1d36acbcdd03fd243da7b41fcb92ab1665e7f509ddd0d49145ffe6a11ad03711bcd188991c9545c219241f40bdba289871fa20c2a12ba284b4edfbe8e2e1b9ef5ab9921e2c4b2f5d31073567484106f426b544e2228f49d5bece2ddc6b915825ac1d7f231f320c6193fd9df3ba20b2e241d6a42178a604f34f2c65fa6f3535044e0e9454cb9eceffbe9248d3bca6bff1a4604296d93767273e0c3d33d9f87cc88860627246bd76ba10171484b874fcd50dec2e8449adb1e951d213798fffd9af589d5a468c554b7c6cb7e042b3dba42ec32f1288566a0fc3dba3f836ce7ae9a20b2171933f0bedfca05d9a98c87da578cb3049976894646a6514d8f5d128b220bef1550b21fd0f9d1ba8f53f1641cbaab7b9489670046b250c8a1f406e8332959aca7d814c60a81f8d89e9bcb6035c3d39a3655325e518f0026b8a5a31cb530d3f0b9c4ac6cbc12863c68b29870b9e6b9843ddf0ac2e2fc8334138dc99399832110f96e17a1cf27b5d86a481b11a887e1b16c957f69886e0f8f1e4ac1ba24e2dcac1dd7c1948e44901fb12f0807117e032e371332d7db3b61e4f456b3647ea9829cb80f3a4d8165f203e5c1ecda2cb14710e927a114d538b2531ddb965b313af9af0871c0c57eede30e5542e070702526f5f0c3154c25e6c6ff0a5fd240586db2c09c34815e94960079269e8a41b1ed1ac57f94bd99de2f12b8e55f916b8fe960d307f76e392a31550e2902624444d5ef04502025794be66ff34cf764251d32953f21ac700f30f0151826ce0d1c7b47f61ac025ae3db2efa9527ee3573e854eee931a72331ffe25a9f879422c3202a281e85feaa4ffab5438abfcc333e8abaca99c210b5b79fe86634cd063c922d0471702da51fd829db944d38719a6a5d46d798c004c71979d790d1fbe65a0199efa7ce8092e618e6665183dc6a945f92ba2c6d648484e0bdb24e4b600fac79cd1996e5dfb10cc4ee0faf2dbc5402040689b5943b0141a9e0b96aaae3edac7df0b55d5a6f7c1026adff3b258f2f627bb7b487caa4cae9964e0bb32b8f5b5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1a2bfb44f7c8277649222d12346ec327"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
